var __TEMPORAL__;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@temporalio/common/lib/activity-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/activity-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivityCancellationType = void 0;
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");
// Avoid importing the proto implementation to reduce workflow bundle size
// Copied from coresdk.workflow_commands.ActivityCancellationType
var ActivityCancellationType;
(function (ActivityCancellationType) {
    ActivityCancellationType[ActivityCancellationType["TRY_CANCEL"] = 0] = "TRY_CANCEL";
    ActivityCancellationType[ActivityCancellationType["WAIT_CANCELLATION_COMPLETED"] = 1] = "WAIT_CANCELLATION_COMPLETED";
    ActivityCancellationType[ActivityCancellationType["ABANDON"] = 2] = "ABANDON";
})(ActivityCancellationType = exports.ActivityCancellationType || (exports.ActivityCancellationType = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/converter/data-converter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/converter/data-converter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultDataConverter = exports.defaultFailureConverter = void 0;
const failure_converter_1 = __webpack_require__(/*! ./failure-converter */ "./node_modules/@temporalio/common/lib/converter/failure-converter.js");
const payload_converter_1 = __webpack_require__(/*! ./payload-converter */ "./node_modules/@temporalio/common/lib/converter/payload-converter.js");
/**
 * The default {@link FailureConverter} used by the SDK.
 *
 * Error messages and stack traces are serizalized as plain text.
 */
exports.defaultFailureConverter = new failure_converter_1.DefaultFailureConverter();
/**
 * A "loaded" data converter that uses the default set of failure and payload converters.
 */
exports.defaultDataConverter = {
    payloadConverter: payload_converter_1.defaultPayloadConverter,
    failureConverter: exports.defaultFailureConverter,
    payloadCodecs: [],
};


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/converter/failure-converter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/converter/failure-converter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultFailureConverter = exports.cutoffStackTrace = void 0;
const failure_1 = __webpack_require__(/*! ../failure */ "./node_modules/@temporalio/common/lib/failure.js");
const type_helpers_1 = __webpack_require__(/*! ../type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");
const payload_converter_1 = __webpack_require__(/*! ./payload-converter */ "./node_modules/@temporalio/common/lib/converter/payload-converter.js");
/**
 * Stack traces will be cutoff when on of these patterns is matched
 */
const CUTOFF_STACK_PATTERNS = [
    /** Activity execution */
    /\s+at Activity\.execute \(.*[\\/]worker[\\/](?:src|lib)[\\/]activity\.[jt]s:\d+:\d+\)/,
    /** Workflow activation */
    /\s+at Activator\.\S+NextHandler \(.*[\\/]workflow[\\/](?:src|lib)[\\/]internals\.[jt]s:\d+:\d+\)/,
    /** Workflow run anything in context */
    /\s+at Script\.runInContext \((?:node:vm|vm\.js):\d+:\d+\)/,
];
/**
 * Cuts out the framework part of a stack trace, leaving only user code entries
 */
function cutoffStackTrace(stack) {
    const lines = (stack ?? '').split(/\r?\n/);
    const acc = Array();
    lineLoop: for (const line of lines) {
        for (const pattern of CUTOFF_STACK_PATTERNS) {
            if (pattern.test(line))
                break lineLoop;
        }
        acc.push(line);
    }
    return acc.join('\n');
}
exports.cutoffStackTrace = cutoffStackTrace;
/**
 * Default, cross-language-compatible Failure converter.
 *
 * By default, it will leave error messages and stack traces as plain text. In order to encrypt them, set
 * `encodeCommonAttributes` to `true` in the constructor options and use a {@link PayloadCodec} that can encrypt /
 * decrypt Payloads in your {@link WorkerOptions.dataConverter | Worker} and
 * {@link ClientOptions.dataConverter | Client options}.
 */
class DefaultFailureConverter {
    constructor(options) {
        const { encodeCommonAttributes } = options ?? {};
        this.options = {
            encodeCommonAttributes: encodeCommonAttributes ?? false,
        };
    }
    /**
     * Converts a Failure proto message to a JS Error object.
     *
     * Does not set common properties, that is done in {@link failureToError}.
     */
    failureToErrorInner(failure, payloadConverter) {
        if (failure.applicationFailureInfo) {
            return new failure_1.ApplicationFailure(failure.message ?? undefined, failure.applicationFailureInfo.type, Boolean(failure.applicationFailureInfo.nonRetryable), (0, payload_converter_1.arrayFromPayloads)(payloadConverter, failure.applicationFailureInfo.details?.payloads), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.serverFailureInfo) {
            return new failure_1.ServerFailure(failure.message ?? undefined, Boolean(failure.serverFailureInfo.nonRetryable), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.timeoutFailureInfo) {
            return new failure_1.TimeoutFailure(failure.message ?? undefined, (0, payload_converter_1.fromPayloadsAtIndex)(payloadConverter, 0, failure.timeoutFailureInfo.lastHeartbeatDetails?.payloads), failure.timeoutFailureInfo.timeoutType ?? failure_1.TimeoutType.TIMEOUT_TYPE_UNSPECIFIED);
        }
        if (failure.terminatedFailureInfo) {
            return new failure_1.TerminatedFailure(failure.message ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.canceledFailureInfo) {
            return new failure_1.CancelledFailure(failure.message ?? undefined, (0, payload_converter_1.arrayFromPayloads)(payloadConverter, failure.canceledFailureInfo.details?.payloads), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.resetWorkflowFailureInfo) {
            return new failure_1.ApplicationFailure(failure.message ?? undefined, 'ResetWorkflow', false, (0, payload_converter_1.arrayFromPayloads)(payloadConverter, failure.resetWorkflowFailureInfo.lastHeartbeatDetails?.payloads), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.childWorkflowExecutionFailureInfo) {
            const { namespace, workflowType, workflowExecution, retryState } = failure.childWorkflowExecutionFailureInfo;
            if (!(workflowType?.name && workflowExecution)) {
                throw new TypeError('Missing attributes on childWorkflowExecutionFailureInfo');
            }
            return new failure_1.ChildWorkflowFailure(namespace ?? undefined, workflowExecution, workflowType.name, retryState ?? failure_1.RetryState.RETRY_STATE_UNSPECIFIED, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.activityFailureInfo) {
            if (!failure.activityFailureInfo.activityType?.name) {
                throw new TypeError('Missing activityType?.name on activityFailureInfo');
            }
            return new failure_1.ActivityFailure(failure.message ?? undefined, failure.activityFailureInfo.activityType.name, failure.activityFailureInfo.activityId ?? undefined, failure.activityFailureInfo.retryState ?? failure_1.RetryState.RETRY_STATE_UNSPECIFIED, failure.activityFailureInfo.identity ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        return new failure_1.TemporalFailure(failure.message ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
    }
    failureToError(failure, payloadConverter) {
        if (failure.encodedAttributes) {
            const attrs = payloadConverter.fromPayload(failure.encodedAttributes);
            // Don't apply encodedAttributes unless they conform to an expected schema
            if (typeof attrs === 'object' && attrs !== null) {
                const { message, stack_trace } = attrs;
                // Avoid mutating the argument
                failure = { ...failure };
                if (typeof message === 'string') {
                    failure.message = message;
                }
                if (typeof stack_trace === 'string') {
                    failure.stackTrace = stack_trace;
                }
            }
        }
        const err = this.failureToErrorInner(failure, payloadConverter);
        err.stack = failure.stackTrace ?? '';
        err.failure = failure;
        return err;
    }
    errorToFailure(err, payloadConverter) {
        const failure = this.errorToFailureInner(err, payloadConverter);
        if (this.options.encodeCommonAttributes) {
            const { message, stackTrace } = failure;
            failure.message = 'Encoded failure';
            failure.stackTrace = '';
            failure.encodedAttributes = payloadConverter.toPayload({ message, stack_trace: stackTrace });
        }
        return failure;
    }
    errorToFailureInner(err, payloadConverter) {
        if (err instanceof failure_1.TemporalFailure) {
            if (err.failure)
                return err.failure;
            const base = {
                message: err.message,
                stackTrace: cutoffStackTrace(err.stack),
                cause: this.optionalErrorToOptionalFailure(err.cause, payloadConverter),
                source: failure_1.FAILURE_SOURCE,
            };
            if (err instanceof failure_1.ActivityFailure) {
                return {
                    ...base,
                    activityFailureInfo: {
                        ...err,
                        activityType: { name: err.activityType },
                    },
                };
            }
            if (err instanceof failure_1.ChildWorkflowFailure) {
                return {
                    ...base,
                    childWorkflowExecutionFailureInfo: {
                        ...err,
                        workflowExecution: err.execution,
                        workflowType: { name: err.workflowType },
                    },
                };
            }
            if (err instanceof failure_1.ApplicationFailure) {
                return {
                    ...base,
                    applicationFailureInfo: {
                        type: err.type,
                        nonRetryable: err.nonRetryable,
                        details: err.details && err.details.length
                            ? { payloads: (0, payload_converter_1.toPayloads)(payloadConverter, ...err.details) }
                            : undefined,
                    },
                };
            }
            if (err instanceof failure_1.CancelledFailure) {
                return {
                    ...base,
                    canceledFailureInfo: {
                        details: err.details && err.details.length
                            ? { payloads: (0, payload_converter_1.toPayloads)(payloadConverter, ...err.details) }
                            : undefined,
                    },
                };
            }
            if (err instanceof failure_1.TimeoutFailure) {
                return {
                    ...base,
                    timeoutFailureInfo: {
                        timeoutType: err.timeoutType,
                        lastHeartbeatDetails: err.lastHeartbeatDetails
                            ? { payloads: (0, payload_converter_1.toPayloads)(payloadConverter, err.lastHeartbeatDetails) }
                            : undefined,
                    },
                };
            }
            if (err instanceof failure_1.ServerFailure) {
                return {
                    ...base,
                    serverFailureInfo: { nonRetryable: err.nonRetryable },
                };
            }
            if (err instanceof failure_1.TerminatedFailure) {
                return {
                    ...base,
                    terminatedFailureInfo: {},
                };
            }
            // Just a TemporalFailure
            return base;
        }
        const base = {
            source: failure_1.FAILURE_SOURCE,
        };
        if ((0, type_helpers_1.isError)(err)) {
            return {
                ...base,
                message: String(err.message) ?? '',
                stackTrace: cutoffStackTrace(err.stack),
                cause: this.optionalErrorToOptionalFailure(err.cause, payloadConverter),
            };
        }
        const recommendation = ` [A non-Error value was thrown from your code. We recommend throwing Error objects so that we can provide a stack trace]`;
        if (typeof err === 'string') {
            return { ...base, message: err + recommendation };
        }
        if (typeof err === 'object') {
            let message = '';
            try {
                message = JSON.stringify(err);
            }
            catch (_err) {
                message = String(err);
            }
            return { ...base, message: message + recommendation };
        }
        return { ...base, message: String(err) + recommendation };
    }
    /**
     * Converts a Failure proto message to a JS Error object if defined or returns undefined.
     */
    optionalFailureToOptionalError(failure, payloadConverter) {
        return failure ? this.failureToError(failure, payloadConverter) : undefined;
    }
    /**
     * Converts an error to a Failure proto message if defined or returns undefined
     */
    optionalErrorToOptionalFailure(err, payloadConverter) {
        return err ? this.errorToFailure(err, payloadConverter) : undefined;
    }
}
exports.DefaultFailureConverter = DefaultFailureConverter;


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/converter/payload-codec.js":
/*!************************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/converter/payload-codec.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/converter/payload-converter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/converter/payload-converter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultPayloadConverter = exports.DefaultPayloadConverter = exports.searchAttributePayloadConverter = exports.SearchAttributePayloadConverter = exports.JsonPayloadConverter = exports.BinaryPayloadConverter = exports.UndefinedPayloadConverter = exports.CompositePayloadConverter = exports.mapFromPayloads = exports.arrayFromPayloads = exports.fromPayloadsAtIndex = exports.mapToPayloads = exports.toPayloads = void 0;
const encoding_1 = __webpack_require__(/*! ../encoding */ "./node_modules/@temporalio/common/lib/encoding.js");
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/@temporalio/common/lib/errors.js");
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/@temporalio/common/lib/converter/types.js");
/**
 * Implements conversion of a list of values.
 *
 * @param converter
 * @param values JS values to convert to Payloads
 * @return list of {@link Payload}s
 * @throws {@link ValueError} if conversion of the value passed as parameter failed for any
 *     reason.
 */
function toPayloads(converter, ...values) {
    if (values.length === 0) {
        return undefined;
    }
    return values.map((value) => converter.toPayload(value));
}
exports.toPayloads = toPayloads;
/**
 * Run {@link PayloadConverter.toPayload} on each value in the map.
 *
 * @throws {@link ValueError} if conversion of any value in the map fails
 */
function mapToPayloads(converter, map) {
    return Object.fromEntries(Object.entries(map).map(([k, v]) => [k, converter.toPayload(v)]));
}
exports.mapToPayloads = mapToPayloads;
/**
 * Implements conversion of an array of values of different types. Useful for deserializing
 * arguments of function invocations.
 *
 * @param converter
 * @param index index of the value in the payloads
 * @param payloads serialized value to convert to JS values.
 * @return converted JS value
 * @throws {@link PayloadConverterError} if conversion of the data passed as parameter failed for any
 *     reason.
 */
function fromPayloadsAtIndex(converter, index, payloads) {
    // To make adding arguments a backwards compatible change
    if (payloads === undefined || payloads === null || index >= payloads.length) {
        return undefined;
    }
    return converter.fromPayload(payloads[index]);
}
exports.fromPayloadsAtIndex = fromPayloadsAtIndex;
/**
 * Run {@link PayloadConverter.fromPayload} on each value in the array.
 */
function arrayFromPayloads(converter, payloads) {
    if (!payloads) {
        return [];
    }
    return payloads.map((payload) => converter.fromPayload(payload));
}
exports.arrayFromPayloads = arrayFromPayloads;
function mapFromPayloads(converter, map) {
    if (map == null)
        return map;
    return Object.fromEntries(Object.entries(map).map(([k, payload]) => {
        const value = converter.fromPayload(payload);
        return [k, value];
    }));
}
exports.mapFromPayloads = mapFromPayloads;
/**
 * Tries to convert values to {@link Payload}s using the {@link PayloadConverterWithEncoding}s provided to the constructor, in the order provided.
 *
 * Converts Payloads to values based on the `Payload.metadata.encoding` field, which matches the {@link PayloadConverterWithEncoding.encodingType}
 * of the converter that created the Payload.
 */
class CompositePayloadConverter {
    constructor(...converters) {
        this.converterByEncoding = new Map();
        if (converters.length === 0) {
            throw new errors_1.PayloadConverterError('Must provide at least one PayloadConverterWithEncoding');
        }
        this.converters = converters;
        for (const converter of converters) {
            this.converterByEncoding.set(converter.encodingType, converter);
        }
    }
    /**
     * Tries to run `.toPayload(value)` on each converter in the order provided at construction.
     * Returns the first successful result, throws {@link ValueError} if there is no converter that can handle the value.
     */
    toPayload(value) {
        for (const converter of this.converters) {
            const result = converter.toPayload(value);
            if (result !== undefined) {
                return result;
            }
        }
        throw new errors_1.ValueError(`Unable to convert ${value} to payload`);
    }
    /**
     * Run {@link PayloadConverterWithEncoding.fromPayload} based on the `encoding` metadata of the {@link Payload}.
     */
    fromPayload(payload) {
        if (payload.metadata === undefined || payload.metadata === null) {
            throw new errors_1.ValueError('Missing payload metadata');
        }
        const encoding = (0, encoding_1.decode)(payload.metadata[types_1.METADATA_ENCODING_KEY]);
        const converter = this.converterByEncoding.get(encoding);
        if (converter === undefined) {
            throw new errors_1.ValueError(`Unknown encoding: ${encoding}`);
        }
        return converter.fromPayload(payload);
    }
}
exports.CompositePayloadConverter = CompositePayloadConverter;
/**
 * Converts between JS undefined and NULL Payload
 */
class UndefinedPayloadConverter {
    constructor() {
        this.encodingType = types_1.encodingTypes.METADATA_ENCODING_NULL;
    }
    toPayload(value) {
        if (value !== undefined) {
            return undefined;
        }
        return {
            metadata: {
                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_NULL,
            },
        };
    }
    fromPayload(_content) {
        return undefined; // Just return undefined
    }
}
exports.UndefinedPayloadConverter = UndefinedPayloadConverter;
/**
 * Converts between binary data types and RAW Payload
 */
class BinaryPayloadConverter {
    constructor() {
        this.encodingType = types_1.encodingTypes.METADATA_ENCODING_RAW;
    }
    toPayload(value) {
        if (!(value instanceof Uint8Array)) {
            return undefined;
        }
        return {
            metadata: {
                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_RAW,
            },
            data: value,
        };
    }
    fromPayload(content) {
        return (
        // Wrap with Uint8Array from this context to ensure `instanceof` works
        (content.data ? new Uint8Array(content.data.buffer, content.data.byteOffset, content.data.length) : content.data));
    }
}
exports.BinaryPayloadConverter = BinaryPayloadConverter;
/**
 * Converts between non-undefined values and serialized JSON Payload
 */
class JsonPayloadConverter {
    constructor() {
        this.encodingType = types_1.encodingTypes.METADATA_ENCODING_JSON;
    }
    toPayload(value) {
        if (value === undefined) {
            return undefined;
        }
        let json;
        try {
            json = JSON.stringify(value);
        }
        catch (err) {
            return undefined;
        }
        return {
            metadata: {
                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_JSON,
            },
            data: (0, encoding_1.encode)(json),
        };
    }
    fromPayload(content) {
        if (content.data === undefined || content.data === null) {
            throw new errors_1.ValueError('Got payload with no data');
        }
        return JSON.parse((0, encoding_1.decode)(content.data));
    }
}
exports.JsonPayloadConverter = JsonPayloadConverter;
/**
 * Converts Search Attribute values using JsonPayloadConverter
 */
class SearchAttributePayloadConverter {
    constructor() {
        this.jsonConverter = new JsonPayloadConverter();
        this.validNonDateTypes = ['string', 'number', 'boolean'];
    }
    toPayload(values) {
        if (!Array.isArray(values)) {
            throw new errors_1.ValueError(`SearchAttribute value must be an array`);
        }
        if (values.length > 0) {
            const firstValue = values[0];
            const firstType = typeof firstValue;
            if (firstType === 'object') {
                for (const [idx, value] of values.entries()) {
                    if (!(value instanceof Date)) {
                        throw new errors_1.ValueError(`SearchAttribute values must arrays of strings, numbers, booleans, or Dates. The value ${value} at index ${idx} is of type ${typeof value}`);
                    }
                }
            }
            else {
                if (!this.validNonDateTypes.includes(firstType)) {
                    throw new errors_1.ValueError(`SearchAttribute array values must be: string | number | boolean | Date`);
                }
                for (const [idx, value] of values.entries()) {
                    if (typeof value !== firstType) {
                        throw new errors_1.ValueError(`All SearchAttribute array values must be of the same type. The first value ${firstValue} of type ${firstType} doesn't match value ${value} of type ${typeof value} at index ${idx}`);
                    }
                }
            }
        }
        // JSON.stringify takes care of converting Dates to ISO strings
        const ret = this.jsonConverter.toPayload(values);
        if (ret === undefined) {
            throw new errors_1.ValueError('Could not convert search attributes to payloads');
        }
        return ret;
    }
    /**
     * Datetime Search Attribute values are converted to `Date`s
     */
    fromPayload(payload) {
        if (payload.metadata === undefined || payload.metadata === null) {
            throw new errors_1.ValueError('Missing payload metadata');
        }
        const value = this.jsonConverter.fromPayload(payload);
        let arrayWrappedValue = Array.isArray(value) ? value : [value];
        const searchAttributeType = (0, encoding_1.decode)(payload.metadata.type);
        if (searchAttributeType === 'Datetime') {
            arrayWrappedValue = arrayWrappedValue.map((dateString) => new Date(dateString));
        }
        return arrayWrappedValue;
    }
}
exports.SearchAttributePayloadConverter = SearchAttributePayloadConverter;
exports.searchAttributePayloadConverter = new SearchAttributePayloadConverter();
class DefaultPayloadConverter extends CompositePayloadConverter {
    // Match the order used in other SDKs, but exclude Protobuf converters so that the code, including
    // `proto3-json-serializer`, doesn't take space in Workflow bundles that don't use Protobufs. To use Protobufs, use
    // {@link DefaultPayloadConverterWithProtobufs}.
    //
    // Go SDK:
    // https://github.com/temporalio/sdk-go/blob/5e5645f0c550dcf717c095ae32c76a7087d2e985/converter/default_data_converter.go#L28
    constructor() {
        super(new UndefinedPayloadConverter(), new BinaryPayloadConverter(), new JsonPayloadConverter());
    }
}
exports.DefaultPayloadConverter = DefaultPayloadConverter;
/**
 * The default {@link PayloadConverter} used by the SDK. Supports `Uint8Array` and JSON serializables (so if
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description | `JSON.stringify(yourArgOrRetval)`}
 * works, the default payload converter will work).
 *
 * To also support Protobufs, create a custom payload converter with {@link DefaultPayloadConverter}:
 *
 * `const myConverter = new DefaultPayloadConverter({ protobufRoot })`
 */
exports.defaultPayloadConverter = new DefaultPayloadConverter();


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/converter/types.js":
/*!****************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/converter/types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.METADATA_MESSAGE_TYPE_KEY = exports.encodingKeys = exports.encodingTypes = exports.METADATA_ENCODING_KEY = void 0;
const encoding_1 = __webpack_require__(/*! ../encoding */ "./node_modules/@temporalio/common/lib/encoding.js");
exports.METADATA_ENCODING_KEY = 'encoding';
exports.encodingTypes = {
    METADATA_ENCODING_NULL: 'binary/null',
    METADATA_ENCODING_RAW: 'binary/plain',
    METADATA_ENCODING_JSON: 'json/plain',
    METADATA_ENCODING_PROTOBUF_JSON: 'json/protobuf',
    METADATA_ENCODING_PROTOBUF: 'binary/protobuf',
};
exports.encodingKeys = {
    METADATA_ENCODING_NULL: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_NULL),
    METADATA_ENCODING_RAW: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_RAW),
    METADATA_ENCODING_JSON: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_JSON),
    METADATA_ENCODING_PROTOBUF_JSON: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_PROTOBUF_JSON),
    METADATA_ENCODING_PROTOBUF: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_PROTOBUF),
};
exports.METADATA_MESSAGE_TYPE_KEY = 'messageType';


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/deprecated-time.js":
/*!****************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/deprecated-time.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.optionalTsToDate = exports.tsToDate = exports.msToNumber = exports.msOptionalToNumber = exports.msOptionalToTs = exports.msToTs = exports.msNumberToTs = exports.tsToMs = exports.optionalTsToMs = void 0;
const time = __importStar(__webpack_require__(/*! ./time */ "./node_modules/@temporalio/common/lib/time.js"));
/**
 * Lossy conversion function from Timestamp to number due to possible overflow.
 * If ts is null or undefined returns undefined.
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function optionalTsToMs(ts) {
    return time.optionalTsToMs(ts);
}
exports.optionalTsToMs = optionalTsToMs;
/**
 * Lossy conversion function from Timestamp to number due to possible overflow
 *
 * @hidden
 * @deprecated - meant for internal use only
 * @deprecated - meant for internal use only
 */
function tsToMs(ts) {
    return time.tsToMs(ts);
}
exports.tsToMs = tsToMs;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msNumberToTs(millis) {
    return time.msNumberToTs(millis);
}
exports.msNumberToTs = msNumberToTs;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msToTs(str) {
    return time.msToTs(str);
}
exports.msToTs = msToTs;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msOptionalToTs(str) {
    return time.msOptionalToTs(str);
}
exports.msOptionalToTs = msOptionalToTs;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msOptionalToNumber(val) {
    return time.msOptionalToNumber(val);
}
exports.msOptionalToNumber = msOptionalToNumber;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msToNumber(val) {
    return time.msToNumber(val);
}
exports.msToNumber = msToNumber;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function tsToDate(ts) {
    return time.tsToDate(ts);
}
exports.tsToDate = tsToDate;
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function optionalTsToDate(ts) {
    return time.optionalTsToDate(ts);
}
exports.optionalTsToDate = optionalTsToDate;


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/encoding.js":
/*!*********************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/encoding.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Pasted with modifications from: https://raw.githubusercontent.com/anonyco/FastestSmallestTextEncoderDecoder/master/EncoderDecoderTogether.src.js
/* eslint no-fallthrough: 0 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decode = exports.encode = exports.TextEncoder = exports.TextDecoder = void 0;
const fromCharCode = String.fromCharCode;
const encoderRegexp = /[\x80-\uD7ff\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g;
const tmpBufferU16 = new Uint16Array(32);
class TextDecoder {
    decode(inputArrayOrBuffer) {
        const inputAs8 = inputArrayOrBuffer instanceof Uint8Array ? inputArrayOrBuffer : new Uint8Array(inputArrayOrBuffer);
        let resultingString = '', tmpStr = '', index = 0, nextEnd = 0, cp0 = 0, codePoint = 0, minBits = 0, cp1 = 0, pos = 0, tmp = -1;
        const len = inputAs8.length | 0;
        const lenMinus32 = (len - 32) | 0;
        // Note that tmp represents the 2nd half of a surrogate pair incase a surrogate gets divided between blocks
        for (; index < len;) {
            nextEnd = index <= lenMinus32 ? 32 : (len - index) | 0;
            for (; pos < nextEnd; index = (index + 1) | 0, pos = (pos + 1) | 0) {
                cp0 = inputAs8[index] & 0xff;
                switch (cp0 >> 4) {
                    case 15:
                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;
                        if (cp1 >> 6 !== 0b10 || 0b11110111 < cp0) {
                            index = (index - 1) | 0;
                            break;
                        }
                        codePoint = ((cp0 & 0b111) << 6) | (cp1 & 0b00111111);
                        minBits = 5; // 20 ensures it never passes -> all invalid replacements
                        cp0 = 0x100; //  keep track of th bit size
                    case 14:
                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;
                        codePoint <<= 6;
                        codePoint |= ((cp0 & 0b1111) << 6) | (cp1 & 0b00111111);
                        minBits = cp1 >> 6 === 0b10 ? (minBits + 4) | 0 : 24; // 24 ensures it never passes -> all invalid replacements
                        cp0 = (cp0 + 0x100) & 0x300; // keep track of th bit size
                    case 13:
                    case 12:
                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;
                        codePoint <<= 6;
                        codePoint |= ((cp0 & 0b11111) << 6) | (cp1 & 0b00111111);
                        minBits = (minBits + 7) | 0;
                        // Now, process the code point
                        if (index < len && cp1 >> 6 === 0b10 && codePoint >> minBits && codePoint < 0x110000) {
                            cp0 = codePoint;
                            codePoint = (codePoint - 0x10000) | 0;
                            if (0 <= codePoint /*0xffff < codePoint*/) {
                                // BMP code point
                                //nextEnd = nextEnd - 1|0;
                                tmp = ((codePoint >> 10) + 0xd800) | 0; // highSurrogate
                                cp0 = ((codePoint & 0x3ff) + 0xdc00) | 0; // lowSurrogate (will be inserted later in the switch-statement)
                                if (pos < 31) {
                                    // notice 31 instead of 32
                                    tmpBufferU16[pos] = tmp;
                                    pos = (pos + 1) | 0;
                                    tmp = -1;
                                }
                                else {
                                    // else, we are at the end of the inputAs8 and let tmp0 be filled in later on
                                    // NOTE that cp1 is being used as a temporary variable for the swapping of tmp with cp0
                                    cp1 = tmp;
                                    tmp = cp0;
                                    cp0 = cp1;
                                }
                            }
                            else
                                nextEnd = (nextEnd + 1) | 0; // because we are advancing i without advancing pos
                        }
                        else {
                            // invalid code point means replacing the whole thing with null replacement characters
                            cp0 >>= 8;
                            index = (index - cp0 - 1) | 0; // reset index  back to what it was before
                            cp0 = 0xfffd;
                        }
                        // Finally, reset the variables for the next go-around
                        minBits = 0;
                        codePoint = 0;
                        nextEnd = index <= lenMinus32 ? 32 : (len - index) | 0;
                    /*case 11:
                  case 10:
                  case 9:
                  case 8:
                    codePoint ? codePoint = 0 : cp0 = 0xfffd; // fill with invalid replacement character
                  case 7:
                  case 6:
                  case 5:
                  case 4:
                  case 3:
                  case 2:
                  case 1:
                  case 0:
                    tmpBufferU16[pos] = cp0;
                    continue;*/
                    default: // fill with invalid replacement character
                        tmpBufferU16[pos] = cp0;
                        continue;
                    case 11:
                    case 10:
                    case 9:
                    case 8:
                }
                tmpBufferU16[pos] = 0xfffd; // fill with invalid replacement character
            }
            tmpStr += fromCharCode(tmpBufferU16[0], tmpBufferU16[1], tmpBufferU16[2], tmpBufferU16[3], tmpBufferU16[4], tmpBufferU16[5], tmpBufferU16[6], tmpBufferU16[7], tmpBufferU16[8], tmpBufferU16[9], tmpBufferU16[10], tmpBufferU16[11], tmpBufferU16[12], tmpBufferU16[13], tmpBufferU16[14], tmpBufferU16[15], tmpBufferU16[16], tmpBufferU16[17], tmpBufferU16[18], tmpBufferU16[19], tmpBufferU16[20], tmpBufferU16[21], tmpBufferU16[22], tmpBufferU16[23], tmpBufferU16[24], tmpBufferU16[25], tmpBufferU16[26], tmpBufferU16[27], tmpBufferU16[28], tmpBufferU16[29], tmpBufferU16[30], tmpBufferU16[31]);
            if (pos < 32)
                tmpStr = tmpStr.slice(0, (pos - 32) | 0); //-(32-pos));
            if (index < len) {
                //fromCharCode.apply(0, tmpBufferU16 : Uint8Array ?  tmpBufferU16.subarray(0,pos) : tmpBufferU16.slice(0,pos));
                tmpBufferU16[0] = tmp;
                pos = ~tmp >>> 31; //tmp !== -1 ? 1 : 0;
                tmp = -1;
                if (tmpStr.length < resultingString.length)
                    continue;
            }
            else if (tmp !== -1) {
                tmpStr += fromCharCode(tmp);
            }
            resultingString += tmpStr;
            tmpStr = '';
        }
        return resultingString;
    }
}
exports.TextDecoder = TextDecoder;
//////////////////////////////////////////////////////////////////////////////////////
function encoderReplacer(nonAsciiChars) {
    // make the UTF string into a binary UTF-8 encoded string
    let point = nonAsciiChars.charCodeAt(0) | 0;
    if (0xd800 <= point) {
        if (point <= 0xdbff) {
            const nextcode = nonAsciiChars.charCodeAt(1) | 0; // defaults to 0 when NaN, causing null replacement character
            if (0xdc00 <= nextcode && nextcode <= 0xdfff) {
                //point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;
                point = ((point << 10) + nextcode - 0x35fdc00) | 0;
                if (point > 0xffff)
                    return fromCharCode((0x1e /*0b11110*/ << 3) | (point >> 18), (0x2 /*0b10*/ << 6) | ((point >> 12) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/);
            }
            else
                point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
        }
        else if (point <= 0xdfff) {
            point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
        }
    }
    /*if (point <= 0x007f) return nonAsciiChars;
    else */ if (point <= 0x07ff) {
        return fromCharCode((0x6 << 5) | (point >> 6), (0x2 << 6) | (point & 0x3f));
    }
    else
        return fromCharCode((0xe /*0b1110*/ << 4) | (point >> 12), (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/);
}
class TextEncoder {
    encode(inputString) {
        // 0xc0 => 0b11000000; 0xff => 0b11111111; 0xc0-0xff => 0b11xxxxxx
        // 0x80 => 0b10000000; 0xbf => 0b10111111; 0x80-0xbf => 0b10xxxxxx
        const encodedString = inputString === void 0 ? '' : '' + inputString, len = encodedString.length | 0;
        let result = new Uint8Array(((len << 1) + 8) | 0);
        let tmpResult;
        let i = 0, pos = 0, point = 0, nextcode = 0;
        let upgradededArraySize = !Uint8Array; // normal arrays are auto-expanding
        for (i = 0; i < len; i = (i + 1) | 0, pos = (pos + 1) | 0) {
            point = encodedString.charCodeAt(i) | 0;
            if (point <= 0x007f) {
                result[pos] = point;
            }
            else if (point <= 0x07ff) {
                result[pos] = (0x6 << 5) | (point >> 6);
                result[(pos = (pos + 1) | 0)] = (0x2 << 6) | (point & 0x3f);
            }
            else {
                widenCheck: {
                    if (0xd800 <= point) {
                        if (point <= 0xdbff) {
                            nextcode = encodedString.charCodeAt((i = (i + 1) | 0)) | 0; // defaults to 0 when NaN, causing null replacement character
                            if (0xdc00 <= nextcode && nextcode <= 0xdfff) {
                                //point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;
                                point = ((point << 10) + nextcode - 0x35fdc00) | 0;
                                if (point > 0xffff) {
                                    result[pos] = (0x1e /*0b11110*/ << 3) | (point >> 18);
                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 12) & 0x3f) /*0b00111111*/;
                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/;
                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/;
                                    continue;
                                }
                                break widenCheck;
                            }
                            point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
                        }
                        else if (point <= 0xdfff) {
                            point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
                        }
                    }
                    if (!upgradededArraySize && i << 1 < pos && i << 1 < ((pos - 7) | 0)) {
                        upgradededArraySize = true;
                        tmpResult = new Uint8Array(len * 3);
                        tmpResult.set(result);
                        result = tmpResult;
                    }
                }
                result[pos] = (0xe /*0b1110*/ << 4) | (point >> 12);
                result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/;
                result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/;
            }
        }
        return Uint8Array ? result.subarray(0, pos) : result.slice(0, pos);
    }
    encodeInto(inputString, u8Arr) {
        const encodedString = inputString === void 0 ? '' : ('' + inputString).replace(encoderRegexp, encoderReplacer);
        let len = encodedString.length | 0, i = 0, char = 0, read = 0;
        const u8ArrLen = u8Arr.length | 0;
        const inputLength = inputString.length | 0;
        if (u8ArrLen < len)
            len = u8ArrLen;
        putChars: {
            for (; i < len; i = (i + 1) | 0) {
                char = encodedString.charCodeAt(i) | 0;
                switch (char >> 4) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        read = (read + 1) | 0;
                    // extension points:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                        break;
                    case 12:
                    case 13:
                        if (((i + 1) | 0) < u8ArrLen) {
                            read = (read + 1) | 0;
                            break;
                        }
                    case 14:
                        if (((i + 2) | 0) < u8ArrLen) {
                            //if (!(char === 0xEF && encodedString.substr(i+1|0,2) === "\xBF\xBD"))
                            read = (read + 1) | 0;
                            break;
                        }
                    case 15:
                        if (((i + 3) | 0) < u8ArrLen) {
                            read = (read + 1) | 0;
                            break;
                        }
                    default:
                        break putChars;
                }
                //read = read + ((char >> 6) !== 2) |0;
                u8Arr[i] = char;
            }
        }
        return { written: i, read: inputLength < read ? inputLength : read };
    }
}
exports.TextEncoder = TextEncoder;
/**
 * Encode a UTF-8 string into a Uint8Array
 */
function encode(s) {
    return TextEncoder.prototype.encode(s);
}
exports.encode = encode;
/**
 * Decode a Uint8Array into a UTF-8 string
 */
function decode(a) {
    return TextDecoder.prototype.decode(a);
}
exports.decode = decode;


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/errors.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NamespaceNotFoundError = exports.WorkflowNotFoundError = exports.WorkflowExecutionAlreadyStartedError = exports.IllegalStateError = exports.PayloadConverterError = exports.ValueError = void 0;
const failure_1 = __webpack_require__(/*! ./failure */ "./node_modules/@temporalio/common/lib/failure.js");
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");
/**
 * Thrown from code that receives a value that is unexpected or that it's unable to handle.
 */
let ValueError = class ValueError extends Error {
    constructor(message, cause) {
        super(message ?? undefined);
        this.cause = cause;
    }
};
ValueError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ValueError')
], ValueError);
exports.ValueError = ValueError;
/**
 * Thrown when a Payload Converter is misconfigured.
 */
let PayloadConverterError = class PayloadConverterError extends ValueError {
};
PayloadConverterError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('PayloadConverterError')
], PayloadConverterError);
exports.PayloadConverterError = PayloadConverterError;
/**
 * Used in different parts of the SDK to note that something unexpected has happened.
 */
let IllegalStateError = class IllegalStateError extends Error {
};
IllegalStateError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('IllegalStateError')
], IllegalStateError);
exports.IllegalStateError = IllegalStateError;
/**
 * This exception is thrown in the following cases:
 *  - Workflow with the same Workflow Id is currently running
 *  - There is a closed Workflow with the same Workflow Id and the {@link WorkflowOptions.workflowIdReusePolicy}
 *    is `WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE`
 *  - There is closed Workflow in the `Completed` state with the same Workflow Id and the {@link WorkflowOptions.workflowIdReusePolicy}
 *    is `WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY`
 */
let WorkflowExecutionAlreadyStartedError = class WorkflowExecutionAlreadyStartedError extends failure_1.TemporalFailure {
    constructor(message, workflowId, workflowType) {
        super(message);
        this.workflowId = workflowId;
        this.workflowType = workflowType;
    }
};
WorkflowExecutionAlreadyStartedError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowExecutionAlreadyStartedError')
], WorkflowExecutionAlreadyStartedError);
exports.WorkflowExecutionAlreadyStartedError = WorkflowExecutionAlreadyStartedError;
/**
 * Thrown when a Workflow with the given Id is not known to Temporal Server.
 * It could be because:
 * - Id passed is incorrect
 * - Workflow is closed (for some calls, e.g. `terminate`)
 * - Workflow was deleted from the Server after reaching its retention limit
 */
let WorkflowNotFoundError = class WorkflowNotFoundError extends Error {
    constructor(message, workflowId, runId) {
        super(message);
        this.workflowId = workflowId;
        this.runId = runId;
    }
};
WorkflowNotFoundError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowNotFoundError')
], WorkflowNotFoundError);
exports.WorkflowNotFoundError = WorkflowNotFoundError;
/**
 * Thrown when the specified namespace is not known to Temporal Server.
 */
let NamespaceNotFoundError = class NamespaceNotFoundError extends Error {
    constructor(namespace) {
        super(`Namespace not found: '${namespace}'`);
        this.namespace = namespace;
    }
};
NamespaceNotFoundError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('NamespaceNotFoundError')
], NamespaceNotFoundError);
exports.NamespaceNotFoundError = NamespaceNotFoundError;


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/failure.js":
/*!********************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/failure.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rootCause = exports.ensureTemporalFailure = exports.ensureApplicationFailure = exports.ChildWorkflowFailure = exports.ActivityFailure = exports.TimeoutFailure = exports.TerminatedFailure = exports.CancelledFailure = exports.ApplicationFailure = exports.ServerFailure = exports.TemporalFailure = exports.RetryState = exports.TimeoutType = exports.FAILURE_SOURCE = void 0;
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");
exports.FAILURE_SOURCE = 'TypeScriptSDK';
// Avoid importing the proto implementation to reduce workflow bundle size
// Copied from temporal.api.enums.v1.TimeoutType
var TimeoutType;
(function (TimeoutType) {
    TimeoutType[TimeoutType["TIMEOUT_TYPE_UNSPECIFIED"] = 0] = "TIMEOUT_TYPE_UNSPECIFIED";
    TimeoutType[TimeoutType["TIMEOUT_TYPE_START_TO_CLOSE"] = 1] = "TIMEOUT_TYPE_START_TO_CLOSE";
    TimeoutType[TimeoutType["TIMEOUT_TYPE_SCHEDULE_TO_START"] = 2] = "TIMEOUT_TYPE_SCHEDULE_TO_START";
    TimeoutType[TimeoutType["TIMEOUT_TYPE_SCHEDULE_TO_CLOSE"] = 3] = "TIMEOUT_TYPE_SCHEDULE_TO_CLOSE";
    TimeoutType[TimeoutType["TIMEOUT_TYPE_HEARTBEAT"] = 4] = "TIMEOUT_TYPE_HEARTBEAT";
})(TimeoutType = exports.TimeoutType || (exports.TimeoutType = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
// Avoid importing the proto implementation to reduce workflow bundle size
// Copied from temporal.api.enums.v1.RetryState
var RetryState;
(function (RetryState) {
    RetryState[RetryState["RETRY_STATE_UNSPECIFIED"] = 0] = "RETRY_STATE_UNSPECIFIED";
    RetryState[RetryState["RETRY_STATE_IN_PROGRESS"] = 1] = "RETRY_STATE_IN_PROGRESS";
    RetryState[RetryState["RETRY_STATE_NON_RETRYABLE_FAILURE"] = 2] = "RETRY_STATE_NON_RETRYABLE_FAILURE";
    RetryState[RetryState["RETRY_STATE_TIMEOUT"] = 3] = "RETRY_STATE_TIMEOUT";
    RetryState[RetryState["RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED"] = 4] = "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED";
    RetryState[RetryState["RETRY_STATE_RETRY_POLICY_NOT_SET"] = 5] = "RETRY_STATE_RETRY_POLICY_NOT_SET";
    RetryState[RetryState["RETRY_STATE_INTERNAL_SERVER_ERROR"] = 6] = "RETRY_STATE_INTERNAL_SERVER_ERROR";
    RetryState[RetryState["RETRY_STATE_CANCEL_REQUESTED"] = 7] = "RETRY_STATE_CANCEL_REQUESTED";
})(RetryState = exports.RetryState || (exports.RetryState = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
/**
 * Represents failures that can cross Workflow and Activity boundaries.
 *
 * **Never extend this class or any of its children.**
 *
 * The only child class you should ever throw from your code is {@link ApplicationFailure}.
 */
let TemporalFailure = class TemporalFailure extends Error {
    constructor(message, cause) {
        super(message ?? undefined);
        this.cause = cause;
    }
};
TemporalFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('TemporalFailure')
], TemporalFailure);
exports.TemporalFailure = TemporalFailure;
/** Exceptions originated at the Temporal service. */
let ServerFailure = class ServerFailure extends TemporalFailure {
    constructor(message, nonRetryable, cause) {
        super(message, cause);
        this.nonRetryable = nonRetryable;
    }
};
ServerFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ServerFailure')
], ServerFailure);
exports.ServerFailure = ServerFailure;
/**
 * `ApplicationFailure`s are used to communicate application-specific failures in Workflows and Activities.
 *
 * The {@link type} property is matched against {@link RetryPolicy.nonRetryableErrorTypes} to determine if an instance
 * of this error is retryable. Another way to avoid retrying is by setting the {@link nonRetryable} flag to `true`.
 *
 * In Workflows, if you throw a non-`ApplicationFailure`, the Workflow Task will fail and be retried. If you throw an
 * `ApplicationFailure`, the Workflow Execution will fail.
 *
 * In Activities, you can either throw an `ApplicationFailure` or another `Error` to fail the Activity Task. In the
 * latter case, the `Error` will be converted to an `ApplicationFailure`. The conversion is done as following:
 *
 * - `type` is set to `error.constructor?.name ?? error.name`
 * - `message` is set to `error.message`
 * - `nonRetryable` is set to false
 * - `details` are set to null
 * - stack trace is copied from the original error
 *
 * When an {@link https://docs.temporal.io/concepts/what-is-an-activity-execution | Activity Execution} fails, the
 * `ApplicationFailure` from the last Activity Task will be the `cause` of the {@link ActivityFailure} thrown in the
 * Workflow.
 */
let ApplicationFailure = class ApplicationFailure extends TemporalFailure {
    /**
     * Alternatively, use {@link fromError} or {@link create}.
     */
    constructor(message, type, nonRetryable, details, cause) {
        super(message, cause);
        this.type = type;
        this.nonRetryable = nonRetryable;
        this.details = details;
    }
    /**
     * Create a new `ApplicationFailure` from an Error object.
     *
     * First calls {@link ensureApplicationFailure | `ensureApplicationFailure(error)`} and then overrides any fields
     * provided in `overrides`.
     */
    static fromError(error, overrides) {
        const failure = ensureApplicationFailure(error);
        Object.assign(failure, overrides);
        return failure;
    }
    /**
     * Create a new `ApplicationFailure`.
     *
     * By default, will be retryable (unless its `type` is included in {@link RetryPolicy.nonRetryableErrorTypes}).
     */
    static create(options) {
        const { message, type, nonRetryable = false, details, cause } = options;
        return new this(message, type, nonRetryable, details, cause);
    }
    /**
     * Get a new `ApplicationFailure` with the {@link nonRetryable} flag set to false. Note that this error will still
     * not be retried if its `type` is included in {@link RetryPolicy.nonRetryableErrorTypes}.
     *
     * @param message Optional error message
     * @param type Optional error type (used by {@link RetryPolicy.nonRetryableErrorTypes})
     * @param details Optional details about the failure. Serialized by the Worker's {@link PayloadConverter}.
     */
    static retryable(message, type, ...details) {
        return new this(message, type ?? 'Error', false, details);
    }
    /**
     * Get a new `ApplicationFailure` with the {@link nonRetryable} flag set to true.
     *
     * When thrown from an Activity or Workflow, the Activity or Workflow will not be retried (even if `type` is not
     * listed in {@link RetryPolicy.nonRetryableErrorTypes}).
     *
     * @param message Optional error message
     * @param type Optional error type
     * @param details Optional details about the failure. Serialized by the Worker's {@link PayloadConverter}.
     */
    static nonRetryable(message, type, ...details) {
        return new this(message, type ?? 'Error', true, details);
    }
};
ApplicationFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ApplicationFailure')
], ApplicationFailure);
exports.ApplicationFailure = ApplicationFailure;
/**
 * This error is thrown when Cancellation has been requested. To allow Cancellation to happen, let it propagate. To
 * ignore Cancellation, catch it and continue executing. Note that Cancellation can only be requested a single time, so
 * your Workflow/Activity Execution will not receive further Cancellation requests.
 *
 * When a Workflow or Activity has been successfully cancelled, a `CancelledFailure` will be the `cause`.
 */
let CancelledFailure = class CancelledFailure extends TemporalFailure {
    constructor(message, details = [], cause) {
        super(message, cause);
        this.details = details;
    }
};
CancelledFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('CancelledFailure')
], CancelledFailure);
exports.CancelledFailure = CancelledFailure;
/**
 * Used as the `cause` when a Workflow has been terminated
 */
let TerminatedFailure = class TerminatedFailure extends TemporalFailure {
    constructor(message, cause) {
        super(message, cause);
    }
};
TerminatedFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('TerminatedFailure')
], TerminatedFailure);
exports.TerminatedFailure = TerminatedFailure;
/**
 * Used to represent timeouts of Activities and Workflows
 */
let TimeoutFailure = class TimeoutFailure extends TemporalFailure {
    constructor(message, lastHeartbeatDetails, timeoutType) {
        super(message);
        this.lastHeartbeatDetails = lastHeartbeatDetails;
        this.timeoutType = timeoutType;
    }
};
TimeoutFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('TimeoutFailure')
], TimeoutFailure);
exports.TimeoutFailure = TimeoutFailure;
/**
 * Contains information about an Activity failure. Always contains the original reason for the failure as its `cause`.
 * For example, if an Activity timed out, the cause will be a {@link TimeoutFailure}.
 *
 * This exception is expected to be thrown only by the framework code.
 */
let ActivityFailure = class ActivityFailure extends TemporalFailure {
    constructor(message, activityType, activityId, retryState, identity, cause) {
        super(message, cause);
        this.activityType = activityType;
        this.activityId = activityId;
        this.retryState = retryState;
        this.identity = identity;
    }
};
ActivityFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ActivityFailure')
], ActivityFailure);
exports.ActivityFailure = ActivityFailure;
/**
 * Contains information about a Child Workflow failure. Always contains the reason for the failure as its {@link cause}.
 * For example, if the Child was Terminated, the `cause` is a {@link TerminatedFailure}.
 *
 * This exception is expected to be thrown only by the framework code.
 */
let ChildWorkflowFailure = class ChildWorkflowFailure extends TemporalFailure {
    constructor(namespace, execution, workflowType, retryState, cause) {
        super('Child Workflow execution failed', cause);
        this.namespace = namespace;
        this.execution = execution;
        this.workflowType = workflowType;
        this.retryState = retryState;
    }
};
ChildWorkflowFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ChildWorkflowFailure')
], ChildWorkflowFailure);
exports.ChildWorkflowFailure = ChildWorkflowFailure;
/**
 * If `error` is already an `ApplicationFailure`, returns `error`.
 *
 * Otherwise, converts `error` into an `ApplicationFailure` with:
 *
 * - `message`: `error.message` or `String(error)`
 * - `type`: `error.constructor.name` or `error.name`
 * - `stack`: `error.stack` or `''`
 */
function ensureApplicationFailure(error) {
    if (error instanceof ApplicationFailure) {
        return error;
    }
    const message = ((0, type_helpers_1.isRecord)(error) && String(error.message)) || String(error);
    const type = ((0, type_helpers_1.isRecord)(error) && (error.constructor?.name ?? error.name)) || undefined;
    const failure = ApplicationFailure.create({ message, type, nonRetryable: false });
    failure.stack = ((0, type_helpers_1.isRecord)(error) && String(error.stack)) || '';
    return failure;
}
exports.ensureApplicationFailure = ensureApplicationFailure;
/**
 * If `err` is an Error it is turned into an `ApplicationFailure`.
 *
 * If `err` was already a `TemporalFailure`, returns the original error.
 *
 * Otherwise returns an `ApplicationFailure` with `String(err)` as the message.
 */
function ensureTemporalFailure(err) {
    if (err instanceof TemporalFailure) {
        return err;
    }
    return ensureApplicationFailure(err);
}
exports.ensureTemporalFailure = ensureTemporalFailure;
/**
 * Get the root cause message of given `error`.
 *
 * In case `error` is a {@link TemporalFailure}, recurse the `cause` chain and return the root `cause.message`.
 * Otherwise, return `error.message`.
 */
function rootCause(error) {
    if (error instanceof TemporalFailure) {
        return error.cause ? rootCause(error.cause) : error.message;
    }
    return (0, type_helpers_1.errorMessage)(error);
}
exports.rootCause = rootCause;


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Common library for code that's used across the Client, Worker, and/or Workflow
 *
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCode = exports.errorMessage = exports.str = exports.u8 = void 0;
const encoding = __importStar(__webpack_require__(/*! ./encoding */ "./node_modules/@temporalio/common/lib/encoding.js"));
const helpers = __importStar(__webpack_require__(/*! ./type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js"));
__exportStar(__webpack_require__(/*! ./activity-options */ "./node_modules/@temporalio/common/lib/activity-options.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/data-converter */ "./node_modules/@temporalio/common/lib/converter/data-converter.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/failure-converter */ "./node_modules/@temporalio/common/lib/converter/failure-converter.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/payload-codec */ "./node_modules/@temporalio/common/lib/converter/payload-codec.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/payload-converter */ "./node_modules/@temporalio/common/lib/converter/payload-converter.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/types */ "./node_modules/@temporalio/common/lib/converter/types.js"), exports);
__exportStar(__webpack_require__(/*! ./deprecated-time */ "./node_modules/@temporalio/common/lib/deprecated-time.js"), exports);
__exportStar(__webpack_require__(/*! ./errors */ "./node_modules/@temporalio/common/lib/errors.js"), exports);
__exportStar(__webpack_require__(/*! ./failure */ "./node_modules/@temporalio/common/lib/failure.js"), exports);
__exportStar(__webpack_require__(/*! ./interfaces */ "./node_modules/@temporalio/common/lib/interfaces.js"), exports);
__exportStar(__webpack_require__(/*! ./logger */ "./node_modules/@temporalio/common/lib/logger.js"), exports);
__exportStar(__webpack_require__(/*! ./retry-policy */ "./node_modules/@temporalio/common/lib/retry-policy.js"), exports);
__exportStar(__webpack_require__(/*! ./workflow-handle */ "./node_modules/@temporalio/common/lib/workflow-handle.js"), exports);
__exportStar(__webpack_require__(/*! ./workflow-options */ "./node_modules/@temporalio/common/lib/workflow-options.js"), exports);
__exportStar(__webpack_require__(/*! ./versioning-intent */ "./node_modules/@temporalio/common/lib/versioning-intent.js"), exports);
/**
 * Encode a UTF-8 string into a Uint8Array
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function u8(s) {
    return encoding.encode(s);
}
exports.u8 = u8;
/**
 * Decode a Uint8Array into a UTF-8 string
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function str(arr) {
    return encoding.decode(arr);
}
exports.str = str;
/**
 * Get `error.message` (or `undefined` if not present)
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function errorMessage(error) {
    return helpers.errorMessage(error);
}
exports.errorMessage = errorMessage;
/**
 * Get `error.code` (or `undefined` if not present)
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function errorCode(error) {
    return helpers.errorCode(error);
}
exports.errorCode = errorCode;


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/interceptors.js":
/*!*************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/interceptors.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.composeInterceptors = void 0;
/**
 * Composes all interceptor methods into a single function
 *
 * @param interceptors a list of interceptors
 * @param method the name of the interceptor method to compose
 * @param next the original function to be executed at the end of the interception chain
 */
// ts-prune-ignore-next (imported via lib/interceptors)
function composeInterceptors(interceptors, method, next) {
    for (let i = interceptors.length - 1; i >= 0; --i) {
        const interceptor = interceptors[i];
        if (interceptor[method] !== undefined) {
            const prev = next;
            // We loose type safety here because Typescript can't deduce that interceptor[method] is a function that returns
            // the same type as Next<I, M>
            next = ((input) => interceptor[method](input, prev));
        }
    }
    return next;
}
exports.composeInterceptors = composeInterceptors;


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/interfaces.js":
/*!***********************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/interfaces.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/logger.js":
/*!*******************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/logger.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/retry-policy.js":
/*!*************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/retry-policy.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decompileRetryPolicy = exports.compileRetryPolicy = void 0;
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@temporalio/common/lib/errors.js");
const time_1 = __webpack_require__(/*! ./time */ "./node_modules/@temporalio/common/lib/time.js");
/**
 * Turn a TS RetryPolicy into a proto compatible RetryPolicy
 */
function compileRetryPolicy(retryPolicy) {
    if (retryPolicy.backoffCoefficient != null && retryPolicy.backoffCoefficient <= 0) {
        throw new errors_1.ValueError('RetryPolicy.backoffCoefficient must be greater than 0');
    }
    if (retryPolicy.maximumAttempts != null) {
        if (retryPolicy.maximumAttempts === Number.POSITIVE_INFINITY) {
            // drop field (Infinity is the default)
            const { maximumAttempts: _, ...without } = retryPolicy;
            retryPolicy = without;
        }
        else if (retryPolicy.maximumAttempts <= 0) {
            throw new errors_1.ValueError('RetryPolicy.maximumAttempts must be a positive integer');
        }
        else if (!Number.isInteger(retryPolicy.maximumAttempts)) {
            throw new errors_1.ValueError('RetryPolicy.maximumAttempts must be an integer');
        }
    }
    const maximumInterval = (0, time_1.msOptionalToNumber)(retryPolicy.maximumInterval);
    const initialInterval = (0, time_1.msToNumber)(retryPolicy.initialInterval ?? 1000);
    if (maximumInterval === 0) {
        throw new errors_1.ValueError('RetryPolicy.maximumInterval cannot be 0');
    }
    if (initialInterval === 0) {
        throw new errors_1.ValueError('RetryPolicy.initialInterval cannot be 0');
    }
    if (maximumInterval != null && maximumInterval < initialInterval) {
        throw new errors_1.ValueError('RetryPolicy.maximumInterval cannot be less than its initialInterval');
    }
    return {
        maximumAttempts: retryPolicy.maximumAttempts,
        initialInterval: (0, time_1.msToTs)(initialInterval),
        maximumInterval: (0, time_1.msOptionalToTs)(maximumInterval),
        backoffCoefficient: retryPolicy.backoffCoefficient,
        nonRetryableErrorTypes: retryPolicy.nonRetryableErrorTypes,
    };
}
exports.compileRetryPolicy = compileRetryPolicy;
/**
 * Turn a proto compatible RetryPolicy into a TS RetryPolicy
 */
function decompileRetryPolicy(retryPolicy) {
    if (!retryPolicy) {
        return undefined;
    }
    return {
        backoffCoefficient: retryPolicy.backoffCoefficient ?? undefined,
        maximumAttempts: retryPolicy.maximumAttempts ?? undefined,
        maximumInterval: (0, time_1.optionalTsToMs)(retryPolicy.maximumInterval),
        initialInterval: (0, time_1.optionalTsToMs)(retryPolicy.initialInterval),
        nonRetryableErrorTypes: retryPolicy.nonRetryableErrorTypes ?? undefined,
    };
}
exports.decompileRetryPolicy = decompileRetryPolicy;


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/time.js":
/*!*****************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/time.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.optionalDateToTs = exports.optionalTsToDate = exports.tsToDate = exports.msToNumber = exports.msOptionalToNumber = exports.msOptionalToTs = exports.msToTs = exports.msNumberToTs = exports.tsToMs = exports.optionalTsToMs = void 0;
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/umd/index.js")); // eslint-disable-line import/no-named-as-default
const ms_1 = __importDefault(__webpack_require__(/*! ms */ "./node_modules/@temporalio/common/node_modules/ms/dist/index.cjs"));
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@temporalio/common/lib/errors.js");
/**
 * Lossy conversion function from Timestamp to number due to possible overflow.
 * If ts is null or undefined returns undefined.
 */
function optionalTsToMs(ts) {
    if (ts === undefined || ts === null) {
        return undefined;
    }
    return tsToMs(ts);
}
exports.optionalTsToMs = optionalTsToMs;
/**
 * Lossy conversion function from Timestamp to number due to possible overflow
 */
function tsToMs(ts) {
    if (ts === undefined || ts === null) {
        throw new Error(`Expected timestamp, got ${ts}`);
    }
    const { seconds, nanos } = ts;
    return (seconds || long_1.default.UZERO)
        .mul(1000)
        .add(Math.floor((nanos || 0) / 1000000))
        .toNumber();
}
exports.tsToMs = tsToMs;
function msNumberToTs(millis) {
    const seconds = Math.floor(millis / 1000);
    const nanos = (millis % 1000) * 1000000;
    if (Number.isNaN(seconds) || Number.isNaN(nanos)) {
        throw new errors_1.ValueError(`Invalid millis ${millis}`);
    }
    return { seconds: long_1.default.fromNumber(seconds), nanos };
}
exports.msNumberToTs = msNumberToTs;
function msToTs(str) {
    return msNumberToTs(msToNumber(str));
}
exports.msToTs = msToTs;
function msOptionalToTs(str) {
    return str ? msToTs(str) : undefined;
}
exports.msOptionalToTs = msOptionalToTs;
function msOptionalToNumber(val) {
    if (val === undefined)
        return undefined;
    return msToNumber(val);
}
exports.msOptionalToNumber = msOptionalToNumber;
function msToNumber(val) {
    if (typeof val === 'number') {
        return val;
    }
    return msWithValidation(val);
}
exports.msToNumber = msToNumber;
function msWithValidation(str) {
    const millis = (0, ms_1.default)(str);
    if (millis == null || isNaN(millis)) {
        throw new TypeError(`Invalid duration string: '${str}'`);
    }
    return millis;
}
function tsToDate(ts) {
    return new Date(tsToMs(ts));
}
exports.tsToDate = tsToDate;
function optionalTsToDate(ts) {
    if (ts === undefined || ts === null) {
        return undefined;
    }
    return new Date(tsToMs(ts));
}
exports.optionalTsToDate = optionalTsToDate;
// ts-prune-ignore-next (imported via schedule-helpers.ts)
function optionalDateToTs(date) {
    if (date === undefined || date === null) {
        return undefined;
    }
    return msToTs(date.getTime());
}
exports.optionalDateToTs = optionalDateToTs;


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/type-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/type-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SymbolBasedInstanceOfError = exports.assertNever = exports.errorCode = exports.errorMessage = exports.isAbortError = exports.isError = exports.hasOwnProperties = exports.hasOwnProperty = exports.isRecord = exports.checkExtends = void 0;
/** Verify that an type _Copy extends _Orig */
function checkExtends() {
    // noop, just type check
}
exports.checkExtends = checkExtends;
function isRecord(value) {
    return typeof value === 'object' && value !== null;
}
exports.isRecord = isRecord;
function hasOwnProperty(record, prop) {
    return prop in record;
}
exports.hasOwnProperty = hasOwnProperty;
function hasOwnProperties(record, props) {
    return props.every((prop) => prop in record);
}
exports.hasOwnProperties = hasOwnProperties;
function isError(error) {
    return (isRecord(error) &&
        typeof error.name === 'string' &&
        typeof error.message === 'string' &&
        (error.stack == null || typeof error.stack === 'string'));
}
exports.isError = isError;
function isAbortError(error) {
    return isError(error) && error.name === 'AbortError';
}
exports.isAbortError = isAbortError;
/**
 * Get `error.message` (or `undefined` if not present)
 */
function errorMessage(error) {
    if (isError(error)) {
        return error.message;
    }
    else if (typeof error === 'string') {
        return error;
    }
    return undefined;
}
exports.errorMessage = errorMessage;
function isErrorWithCode(error) {
    return isRecord(error) && typeof error.code === 'string';
}
/**
 * Get `error.code` (or `undefined` if not present)
 */
function errorCode(error) {
    if (isErrorWithCode(error)) {
        return error.code;
    }
    return undefined;
}
exports.errorCode = errorCode;
/**
 * Asserts that some type is the never type
 */
function assertNever(msg, x) {
    throw new TypeError(msg + ': ' + x);
}
exports.assertNever = assertNever;
/**
 * A decorator to be used on error classes. It adds the 'name' property AND provides a custom
 * 'instanceof' handler that works correctly across execution contexts.
 *
 * ### Details ###
 *
 * According to the EcmaScript's spec, the default behavior of JavaScript's `x instanceof Y` operator is to walk up the
 * prototype chain of object 'x', checking if any constructor in that hierarchy is _exactly the same object_ as the
 * constructor function 'Y'.
 *
 * Unfortunately, it happens in various situations that different constructor function objects get created for what
 * appears to be the very same class. This leads to surprising behavior where `instanceof` returns false though it is
 * known that the object is indeed an instance of that class. One particular case where this happens is when constructor
 * 'Y' belongs to a different realm than the constuctor with which 'x' was instantiated. Another case is when two copies
 * of the same library gets loaded in the same realm.
 *
 * In practice, this tends to cause issues when crossing the workflow-sandboxing boundary (since Node's vm module
 * really creates new execution realms), as well as when running tests using Jest (see https://github.com/jestjs/jest/issues/2549
 * for some details on that one).
 *
 * This function injects a custom 'instanceof' handler into the prototype of 'clazz', which is both cross-realm safe and
 * cross-copies-of-the-same-lib safe. It works by adding a special symbol property to the prototype of 'clazz', and then
 * checking for the presence of that symbol.
 */
function SymbolBasedInstanceOfError(markerName) {
    return (clazz) => {
        const marker = Symbol.for(`__temporal_is${markerName}`);
        Object.defineProperty(clazz.prototype, 'name', { value: markerName, enumerable: true });
        Object.defineProperty(clazz.prototype, marker, { value: true, enumerable: false });
        Object.defineProperty(clazz, Symbol.hasInstance, {
            // eslint-disable-next-line object-shorthand
            value: function (error) {
                if (this === clazz) {
                    return isRecord(error) && error[marker] === true;
                }
                else {
                    // 'this' must be a _subclass_ of clazz that doesn't redefined [Symbol.hasInstance], so that it inherited
                    // from clazz's [Symbol.hasInstance]. If we don't handle this particular situation, then
                    // `x instanceof SubclassOfParent` would return true for any instance of 'Parent', which is clearly wrong.
                    //
                    // Ideally, it'd be preferable to avoid this case entirely, by making sure that all subclasses of 'clazz'
                    // redefine [Symbol.hasInstance], but we can't enforce that. We therefore fallback to the default instanceof
                    // behavior (which is NOT cross-realm safe).
                    return this.prototype.isPrototypeOf(error); // eslint-disable-line no-prototype-builtins
                }
            },
        });
    };
}
exports.SymbolBasedInstanceOfError = SymbolBasedInstanceOfError;


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/versioning-intent-enum.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/versioning-intent-enum.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.versioningIntentToProto = exports.VersioningIntent = void 0;
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");
// Avoid importing the proto implementation to reduce workflow bundle size
// Copied from coresdk.common.VersioningIntent
/**
 * Protobuf enum representation of {@link VersioningIntentString}.
 *
 * @experimental
 */
var VersioningIntent;
(function (VersioningIntent) {
    VersioningIntent[VersioningIntent["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    VersioningIntent[VersioningIntent["COMPATIBLE"] = 1] = "COMPATIBLE";
    VersioningIntent[VersioningIntent["DEFAULT"] = 2] = "DEFAULT";
})(VersioningIntent = exports.VersioningIntent || (exports.VersioningIntent = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
function versioningIntentToProto(intent) {
    switch (intent) {
        case 'DEFAULT':
            return VersioningIntent.DEFAULT;
        case 'COMPATIBLE':
            return VersioningIntent.COMPATIBLE;
        case undefined:
            return VersioningIntent.UNSPECIFIED;
        default:
            (0, type_helpers_1.assertNever)('Unexpected VersioningIntent', intent);
    }
}
exports.versioningIntentToProto = versioningIntentToProto;


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/versioning-intent.js":
/*!******************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/versioning-intent.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/workflow-handle.js":
/*!****************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/workflow-handle.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/@temporalio/common/lib/workflow-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@temporalio/common/lib/workflow-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractWorkflowType = exports.compileWorkflowOptions = exports.WorkflowIdReusePolicy = void 0;
const time_1 = __webpack_require__(/*! ./time */ "./node_modules/@temporalio/common/lib/time.js");
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");
// Avoid importing the proto implementation to reduce workflow bundle size
// Copied from temporal.api.enums.v1.WorkflowIdReusePolicy
/**
 * Concept: {@link https://docs.temporal.io/concepts/what-is-a-workflow-id-reuse-policy/ | Workflow Id Reuse Policy}
 *
 * Whether a Workflow can be started with a Workflow Id of a Closed Workflow.
 *
 * *Note: A Workflow can never be started with a Workflow Id of a Running Workflow.*
 */
var WorkflowIdReusePolicy;
(function (WorkflowIdReusePolicy) {
    /**
     * No need to use this.
     *
     * (If a `WorkflowIdReusePolicy` is set to this, or is not set at all, the default value will be used.)
     */
    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED"] = 0] = "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED";
    /**
     * The Workflow can be started if the previous Workflow is in a Closed state.
     * @default
     */
    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE"] = 1] = "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE";
    /**
     * The Workflow can be started if the previous Workflow is in a Closed state that is not Completed.
     */
    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY"] = 2] = "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY";
    /**
     * The Workflow cannot be started.
     */
    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE"] = 3] = "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE";
    /**
     * Terminate the current workflow if one is already running.
     */
    WorkflowIdReusePolicy[WorkflowIdReusePolicy["WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING"] = 4] = "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING";
})(WorkflowIdReusePolicy = exports.WorkflowIdReusePolicy || (exports.WorkflowIdReusePolicy = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
function compileWorkflowOptions(options) {
    const { workflowExecutionTimeout, workflowRunTimeout, workflowTaskTimeout, ...rest } = options;
    return {
        ...rest,
        workflowExecutionTimeout: (0, time_1.msOptionalToTs)(workflowExecutionTimeout),
        workflowRunTimeout: (0, time_1.msOptionalToTs)(workflowRunTimeout),
        workflowTaskTimeout: (0, time_1.msOptionalToTs)(workflowTaskTimeout),
    };
}
exports.compileWorkflowOptions = compileWorkflowOptions;
function extractWorkflowType(workflowTypeOrFunc) {
    if (typeof workflowTypeOrFunc === 'string')
        return workflowTypeOrFunc;
    if (typeof workflowTypeOrFunc === 'function') {
        if (workflowTypeOrFunc?.name)
            return workflowTypeOrFunc.name;
        throw new TypeError('Invalid workflow type: the workflow function is anonymous');
    }
    throw new TypeError(`Invalid workflow type: expected either a string or a function, got '${typeof workflowTypeOrFunc}'`);
}
exports.extractWorkflowType = extractWorkflowType;


/***/ }),

/***/ "./node_modules/@temporalio/worker/lib/workflow-log-interceptor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@temporalio/worker/lib/workflow-log-interceptor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.interceptors = exports.WorkflowInboundLogInterceptor = exports.WorkflowLogInterceptor = exports.workflowLogAttributes = void 0;
const workflow_1 = __webpack_require__(/*! @temporalio/workflow */ "./node_modules/@temporalio/workflow/lib/index.js");
const stack_helpers_1 = __webpack_require__(/*! @temporalio/workflow/lib/stack-helpers */ "./node_modules/@temporalio/workflow/lib/stack-helpers.js");
/**
 * Returns a map of attributes to be set on log messages for a given Workflow
 */
function workflowLogAttributes(info) {
    return {
        namespace: info.namespace,
        taskQueue: info.taskQueue,
        workflowId: info.workflowId,
        runId: info.runId,
        workflowType: info.workflowType,
    };
}
exports.workflowLogAttributes = workflowLogAttributes;
/** Logs workflow execution starts and completions, attaches log attributes to `workflow.log` calls  */
class WorkflowLogInterceptor {
    getLogAttributes(input, next) {
        return next({ ...input, ...workflowLogAttributes((0, workflow_1.workflowInfo)()) });
    }
    execute(input, next) {
        workflow_1.log.debug('Workflow started');
        const p = next(input).then((res) => {
            workflow_1.log.debug('Workflow completed');
            return res;
        }, (error) => {
            // Avoid using instanceof checks in case the modules they're defined in loaded more than once,
            // e.g. by jest or when multiple versions are installed.
            if (typeof error === 'object' && error != null) {
                if ((0, workflow_1.isCancellation)(error)) {
                    workflow_1.log.debug('Workflow completed as cancelled');
                    throw error;
                }
                else if (error instanceof workflow_1.ContinueAsNew) {
                    workflow_1.log.debug('Workflow continued as new');
                    throw error;
                }
            }
            workflow_1.log.warn('Workflow failed', { error });
            throw error;
        });
        // Avoid showing this interceptor in stack trace query
        (0, stack_helpers_1.untrackPromise)(p);
        return p;
    }
}
exports.WorkflowLogInterceptor = WorkflowLogInterceptor;
/** @deprecated use {@link WorkflowLogInterceptor} instead */
exports.WorkflowInboundLogInterceptor = WorkflowLogInterceptor;
// ts-prune-ignore-next
const interceptors = () => {
    const interceptor = new WorkflowLogInterceptor();
    return { inbound: [interceptor], outbound: [interceptor] };
};
exports.interceptors = interceptors;


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/alea.js":
/*!*******************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/alea.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mash = exports.alea = void 0;
// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// Taken and modified from https://github.com/davidbau/seedrandom/blob/released/lib/alea.js
class Alea {
    constructor(seed) {
        const mash = new Mash();
        // Apply the seeding algorithm from Baagoe.
        this.c = 1;
        this.s0 = mash.mash([32]);
        this.s1 = mash.mash([32]);
        this.s2 = mash.mash([32]);
        this.s0 -= mash.mash(seed);
        if (this.s0 < 0) {
            this.s0 += 1;
        }
        this.s1 -= mash.mash(seed);
        if (this.s1 < 0) {
            this.s1 += 1;
        }
        this.s2 -= mash.mash(seed);
        if (this.s2 < 0) {
            this.s2 += 1;
        }
    }
    next() {
        const t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32
        this.s0 = this.s1;
        this.s1 = this.s2;
        return (this.s2 = t - (this.c = t | 0));
    }
}
function alea(seed) {
    const xg = new Alea(seed);
    return xg.next.bind(xg);
}
exports.alea = alea;
class Mash {
    constructor() {
        this.n = 0xefc8249d;
    }
    mash(data) {
        let { n } = this;
        for (let i = 0; i < data.length; i++) {
            n += data[i];
            let h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 0x100000000; // 2^32
        }
        this.n = n;
        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
    }
}
exports.Mash = Mash;


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/cancellation-scope.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/cancellation-scope.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CancellationScope_cancelRequested;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerSleepImplementation = exports.RootCancellationScope = exports.disableStorage = exports.CancellationScope = exports.AsyncLocalStorage = void 0;
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/@temporalio/common/lib/index.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "./node_modules/@temporalio/workflow/lib/stack-helpers.js");
// AsyncLocalStorage is injected via vm module into global scope.
// In case Workflow code is imported in Node.js context, replace with an empty class.
exports.AsyncLocalStorage = globalThis.AsyncLocalStorage ?? class {
};
/** Magic symbol used to create the root scope - intentionally not exported */
const NO_PARENT = Symbol('NO_PARENT');
/**
 * In the SDK, Workflows are represented internally by a tree of scopes where the `execute` function runs in the root scope.
 * Cancellation propagates from outer scopes to inner ones and is handled by catching {@link CancelledFailure}s
 * thrown by cancellable operations (see below).
 *
 * Scopes are created using the `CancellationScope` constructor or the static helper methods
 * {@link cancellable}, {@link nonCancellable} and {@link withTimeout}.
 *
 * When a `CancellationScope` is cancelled, it will propagate cancellation any child scopes and any cancellable
 * operations created within it, such as:
 *
 * - Activities
 * - Child Workflows
 * - Timers (created with the {@link sleep} function)
 * - {@link Trigger}s
 *
 * @example
 *
 * ```ts
 * await CancellationScope.cancellable(async () => {
 *   const promise = someActivity();
 *   CancellationScope.current().cancel(); // Cancels the activity
 *   await promise; // Throws `ActivityFailure` with `cause` set to `CancelledFailure`
 * });
 * ```
 *
 * @example
 *
 * ```ts
 * const scope = new CancellationScope();
 * const promise = scope.run(someActivity);
 * scope.cancel(); // Cancels the activity
 * await promise; // Throws `ActivityFailure` with `cause` set to `CancelledFailure`
 * ```
 */
class CancellationScope {
    constructor(options) {
        _CancellationScope_cancelRequested.set(this, false);
        this.timeout = options?.timeout;
        this.cancellable = options?.cancellable ?? true;
        this.cancelRequested = new Promise((_, reject) => {
            // Typescript does not understand that the Promise executor runs synchronously
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this.reject = (err) => {
                __classPrivateFieldSet(this, _CancellationScope_cancelRequested, true, "f");
                reject(err);
            };
        });
        (0, stack_helpers_1.untrackPromise)(this.cancelRequested);
        // Avoid unhandled rejections
        (0, stack_helpers_1.untrackPromise)(this.cancelRequested.catch(() => undefined));
        if (options?.parent !== NO_PARENT) {
            this.parent = options?.parent || CancellationScope.current();
            __classPrivateFieldSet(this, _CancellationScope_cancelRequested, __classPrivateFieldGet(this.parent, _CancellationScope_cancelRequested, "f"), "f");
            this.parent.cancelRequested.catch((err) => {
                this.reject(err);
            });
        }
    }
    get consideredCancelled() {
        return __classPrivateFieldGet(this, _CancellationScope_cancelRequested, "f") && this.cancellable;
    }
    /**
     * Activate the scope as current and run  `fn`
     *
     * Any timers, Activities, Triggers and CancellationScopes created in the body of `fn`
     * automatically link their cancellation to this scope.
     *
     * @return the result of `fn`
     */
    run(fn) {
        return storage.run(this, this.runInContext.bind(this, fn));
    }
    /**
     * Method that runs a function in AsyncLocalStorage context.
     *
     * Could have been written as anonymous function, made into a method for improved stack traces.
     */
    async runInContext(fn) {
        if (this.timeout) {
            (0, stack_helpers_1.untrackPromise)(sleep(this.timeout).then(() => this.cancel(), () => {
                // scope was already cancelled, ignore
            }));
        }
        return await fn();
    }
    /**
     * Request to cancel the scope and linked children
     */
    cancel() {
        this.reject(new common_1.CancelledFailure('Cancellation scope cancelled'));
    }
    /**
     * Get the current "active" scope
     */
    static current() {
        // Using globals directly instead of a helper function to avoid circular import
        return storage.getStore() ?? globalThis.__TEMPORAL_ACTIVATOR__.rootScope;
    }
    /** Alias to `new CancellationScope({ cancellable: true }).run(fn)` */
    static cancellable(fn) {
        return new this({ cancellable: true }).run(fn);
    }
    /** Alias to `new CancellationScope({ cancellable: false }).run(fn)` */
    static nonCancellable(fn) {
        return new this({ cancellable: false }).run(fn);
    }
    /** Alias to `new CancellationScope({ cancellable: true, timeout }).run(fn)` */
    static withTimeout(timeout, fn) {
        return new this({ cancellable: true, timeout }).run(fn);
    }
}
exports.CancellationScope = CancellationScope;
_CancellationScope_cancelRequested = new WeakMap();
const storage = new exports.AsyncLocalStorage();
/**
 * Avoid exposing the storage directly so it doesn't get frozen
 */
function disableStorage() {
    storage.disable();
}
exports.disableStorage = disableStorage;
class RootCancellationScope extends CancellationScope {
    constructor() {
        super({ cancellable: true, parent: NO_PARENT });
    }
    cancel() {
        this.reject(new common_1.CancelledFailure('Workflow cancelled'));
    }
}
exports.RootCancellationScope = RootCancellationScope;
/** This function is here to avoid a circular dependency between this module and workflow.ts */
let sleep = (_) => {
    throw new common_1.IllegalStateError('Workflow has not been properly initialized');
};
function registerSleepImplementation(fn) {
    sleep = fn;
}
exports.registerSleepImplementation = registerSleepImplementation;


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/errors.js":
/*!*********************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/errors.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCancellation = exports.DeterminismViolationError = exports.WorkflowError = void 0;
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/@temporalio/common/lib/index.js");
const type_helpers_1 = __webpack_require__(/*! @temporalio/common/lib/type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");
/**
 * Base class for all workflow errors
 */
let WorkflowError = class WorkflowError extends Error {
};
WorkflowError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowError')
], WorkflowError);
exports.WorkflowError = WorkflowError;
/**
 * Thrown in workflow when it tries to do something that non-deterministic such as construct a WeakRef()
 */
let DeterminismViolationError = class DeterminismViolationError extends WorkflowError {
};
DeterminismViolationError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('DeterminismViolationError')
], DeterminismViolationError);
exports.DeterminismViolationError = DeterminismViolationError;
/**
 * Returns whether provided `err` is caused by cancellation
 */
function isCancellation(err) {
    return (err instanceof common_1.CancelledFailure ||
        ((err instanceof common_1.ActivityFailure || err instanceof common_1.ChildWorkflowFailure) && err.cause instanceof common_1.CancelledFailure));
}
exports.isCancellation = isCancellation;


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/global-attributes.js":
/*!********************************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/global-attributes.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setActivatorUntyped = exports.maybeGetActivatorUntyped = void 0;
function maybeGetActivatorUntyped() {
    return globalThis.__TEMPORAL_ACTIVATOR__;
}
exports.maybeGetActivatorUntyped = maybeGetActivatorUntyped;
function setActivatorUntyped(activator) {
    globalThis.__TEMPORAL_ACTIVATOR__ = activator;
}
exports.setActivatorUntyped = setActivatorUntyped;


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * This library provides tools required for authoring workflows.
 *
 * ## Usage
 * See the {@link https://docs.temporal.io/typescript/hello-world#workflows | tutorial} for writing your first workflow.
 *
 * ### Timers
 *
 * The recommended way of scheduling timers is by using the {@link sleep} function. We've replaced `setTimeout` and
 * `clearTimeout` with deterministic versions so these are also usable but have a limitation that they don't play well
 * with {@link https://docs.temporal.io/typescript/cancellation-scopes | cancellation scopes}.
 *
 * <!--SNIPSTART typescript-sleep-workflow-->
 * <!--SNIPEND-->
 *
 * ### Activities
 *
 * To schedule Activities, use {@link proxyActivities} to obtain an Activity function and call.
 *
 * <!--SNIPSTART typescript-schedule-activity-workflow-->
 * <!--SNIPEND-->
 *
 * ### Signals and Queries
 *
 * To add signal handlers to a Workflow, add a signals property to the exported `workflow` object. Signal handlers can
 * return either `void` or `Promise<void>`, you may schedule activities and timers from a signal handler.
 *
 * To add query handlers to a Workflow, add a queries property to the exported `workflow` object. Query handlers must
 * **not** mutate any variables or generate any commands (like Activities or Timers), they run synchronously and thus
 * **must** return a `Promise`.
 *
 * #### Implementation
 *
 * <!--SNIPSTART typescript-workflow-signal-implementation-->
 * <!--SNIPEND-->
 *
 * ### More
 *
 * - [Deterministic built-ins](https://docs.temporal.io/typescript/determinism#sources-of-non-determinism)
 * - [Cancellation and scopes](https://docs.temporal.io/typescript/cancellation-scopes)
 *   - {@link CancellationScope}
 *   - {@link Trigger}
 * - [Sinks](https://docs.temporal.io/application-development/observability/?lang=ts#logging)
 *   - {@link Sinks}
 *
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Trigger = exports.ParentClosePolicy = exports.ContinueAsNew = exports.ChildWorkflowCancellationType = exports.CancellationScope = exports.AsyncLocalStorage = exports.TimeoutFailure = exports.TerminatedFailure = exports.TemporalFailure = exports.ServerFailure = exports.rootCause = exports.defaultPayloadConverter = exports.ChildWorkflowFailure = exports.CancelledFailure = exports.ApplicationFailure = exports.ActivityFailure = exports.ActivityCancellationType = void 0;
var common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/@temporalio/common/lib/index.js");
Object.defineProperty(exports, "ActivityCancellationType", ({ enumerable: true, get: function () { return common_1.ActivityCancellationType; } }));
Object.defineProperty(exports, "ActivityFailure", ({ enumerable: true, get: function () { return common_1.ActivityFailure; } }));
Object.defineProperty(exports, "ApplicationFailure", ({ enumerable: true, get: function () { return common_1.ApplicationFailure; } }));
Object.defineProperty(exports, "CancelledFailure", ({ enumerable: true, get: function () { return common_1.CancelledFailure; } }));
Object.defineProperty(exports, "ChildWorkflowFailure", ({ enumerable: true, get: function () { return common_1.ChildWorkflowFailure; } }));
Object.defineProperty(exports, "defaultPayloadConverter", ({ enumerable: true, get: function () { return common_1.defaultPayloadConverter; } }));
Object.defineProperty(exports, "rootCause", ({ enumerable: true, get: function () { return common_1.rootCause; } }));
Object.defineProperty(exports, "ServerFailure", ({ enumerable: true, get: function () { return common_1.ServerFailure; } }));
Object.defineProperty(exports, "TemporalFailure", ({ enumerable: true, get: function () { return common_1.TemporalFailure; } }));
Object.defineProperty(exports, "TerminatedFailure", ({ enumerable: true, get: function () { return common_1.TerminatedFailure; } }));
Object.defineProperty(exports, "TimeoutFailure", ({ enumerable: true, get: function () { return common_1.TimeoutFailure; } }));
__exportStar(__webpack_require__(/*! @temporalio/common/lib/errors */ "./node_modules/@temporalio/common/lib/errors.js"), exports);
__exportStar(__webpack_require__(/*! @temporalio/common/lib/workflow-handle */ "./node_modules/@temporalio/common/lib/workflow-handle.js"), exports);
__exportStar(__webpack_require__(/*! @temporalio/common/lib/workflow-options */ "./node_modules/@temporalio/common/lib/workflow-options.js"), exports);
var cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/@temporalio/workflow/lib/cancellation-scope.js");
Object.defineProperty(exports, "AsyncLocalStorage", ({ enumerable: true, get: function () { return cancellation_scope_1.AsyncLocalStorage; } }));
Object.defineProperty(exports, "CancellationScope", ({ enumerable: true, get: function () { return cancellation_scope_1.CancellationScope; } }));
__exportStar(__webpack_require__(/*! ./errors */ "./node_modules/@temporalio/workflow/lib/errors.js"), exports);
__exportStar(__webpack_require__(/*! ./interceptors */ "./node_modules/@temporalio/workflow/lib/interceptors.js"), exports);
var interfaces_1 = __webpack_require__(/*! ./interfaces */ "./node_modules/@temporalio/workflow/lib/interfaces.js");
Object.defineProperty(exports, "ChildWorkflowCancellationType", ({ enumerable: true, get: function () { return interfaces_1.ChildWorkflowCancellationType; } }));
Object.defineProperty(exports, "ContinueAsNew", ({ enumerable: true, get: function () { return interfaces_1.ContinueAsNew; } }));
Object.defineProperty(exports, "ParentClosePolicy", ({ enumerable: true, get: function () { return interfaces_1.ParentClosePolicy; } }));
var trigger_1 = __webpack_require__(/*! ./trigger */ "./node_modules/@temporalio/workflow/lib/trigger.js");
Object.defineProperty(exports, "Trigger", ({ enumerable: true, get: function () { return trigger_1.Trigger; } }));
__exportStar(__webpack_require__(/*! ./workflow */ "./node_modules/@temporalio/workflow/lib/workflow.js"), exports);


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/interceptors.js":
/*!***************************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/interceptors.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Type definitions and generic helpers for interceptors.
 *
 * The Workflow specific interceptors are defined here.
 *
 * @module
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/interfaces.js":
/*!*************************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/interfaces.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParentClosePolicy = exports.ChildWorkflowCancellationType = exports.ContinueAsNew = void 0;
const type_helpers_1 = __webpack_require__(/*! @temporalio/common/lib/type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");
/**
 * Not an actual error, used by the Workflow runtime to abort execution when {@link continueAsNew} is called
 */
let ContinueAsNew = class ContinueAsNew extends Error {
    constructor(command) {
        super('Workflow continued as new');
        this.command = command;
    }
};
ContinueAsNew = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ContinueAsNew')
], ContinueAsNew);
exports.ContinueAsNew = ContinueAsNew;
/**
 * Specifies:
 * - whether cancellation requests are sent to the Child
 * - whether and when a {@link CanceledFailure} is thrown from {@link executeChild} or
 *   {@link ChildWorkflowHandle.result}
 *
 * @default {@link ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED}
 */
var ChildWorkflowCancellationType;
(function (ChildWorkflowCancellationType) {
    /**
     * Don't send a cancellation request to the Child.
     */
    ChildWorkflowCancellationType[ChildWorkflowCancellationType["ABANDON"] = 0] = "ABANDON";
    /**
     * Send a cancellation request to the Child. Immediately throw the error.
     */
    ChildWorkflowCancellationType[ChildWorkflowCancellationType["TRY_CANCEL"] = 1] = "TRY_CANCEL";
    /**
     * Send a cancellation request to the Child. The Child may respect cancellation, in which case an error will be thrown
     * when cancellation has completed, and {@link isCancellation}(error) will be true. On the other hand, the Child may
     * ignore the cancellation request, in which case an error might be thrown with a different cause, or the Child may
     * complete successfully.
     *
     * @default
     */
    ChildWorkflowCancellationType[ChildWorkflowCancellationType["WAIT_CANCELLATION_COMPLETED"] = 2] = "WAIT_CANCELLATION_COMPLETED";
    /**
     * Send a cancellation request to the Child. Throw the error once the Server receives the Child cancellation request.
     */
    ChildWorkflowCancellationType[ChildWorkflowCancellationType["WAIT_CANCELLATION_REQUESTED"] = 3] = "WAIT_CANCELLATION_REQUESTED";
})(ChildWorkflowCancellationType = exports.ChildWorkflowCancellationType || (exports.ChildWorkflowCancellationType = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
/**
 * How a Child Workflow reacts to the Parent Workflow reaching a Closed state.
 *
 * @see {@link https://docs.temporal.io/concepts/what-is-a-parent-close-policy/ | Parent Close Policy}
 */
var ParentClosePolicy;
(function (ParentClosePolicy) {
    /**
     * If a `ParentClosePolicy` is set to this, or is not set at all, the server default value will be used.
     */
    ParentClosePolicy[ParentClosePolicy["PARENT_CLOSE_POLICY_UNSPECIFIED"] = 0] = "PARENT_CLOSE_POLICY_UNSPECIFIED";
    /**
     * When the Parent is Closed, the Child is Terminated.
     *
     * @default
     */
    ParentClosePolicy[ParentClosePolicy["PARENT_CLOSE_POLICY_TERMINATE"] = 1] = "PARENT_CLOSE_POLICY_TERMINATE";
    /**
     * When the Parent is Closed, nothing is done to the Child.
     */
    ParentClosePolicy[ParentClosePolicy["PARENT_CLOSE_POLICY_ABANDON"] = 2] = "PARENT_CLOSE_POLICY_ABANDON";
    /**
     * When the Parent is Closed, the Child is Cancelled.
     */
    ParentClosePolicy[ParentClosePolicy["PARENT_CLOSE_POLICY_REQUEST_CANCEL"] = 3] = "PARENT_CLOSE_POLICY_REQUEST_CANCEL";
})(ParentClosePolicy = exports.ParentClosePolicy || (exports.ParentClosePolicy = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/internals.js":
/*!************************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/internals.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getActivator = exports.maybeGetActivator = exports.Activator = exports.LocalActivityDoBackoff = void 0;
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/@temporalio/common/lib/index.js");
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "./node_modules/@temporalio/common/lib/interceptors.js");
const type_helpers_1 = __webpack_require__(/*! @temporalio/common/lib/type-helpers */ "./node_modules/@temporalio/common/lib/type-helpers.js");
const alea_1 = __webpack_require__(/*! ./alea */ "./node_modules/@temporalio/workflow/lib/alea.js");
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@temporalio/workflow/lib/errors.js");
const interfaces_1 = __webpack_require__(/*! ./interfaces */ "./node_modules/@temporalio/workflow/lib/interfaces.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "./node_modules/@temporalio/workflow/lib/stack-helpers.js");
const pkg_1 = __importDefault(__webpack_require__(/*! ./pkg */ "./node_modules/@temporalio/workflow/lib/pkg.js"));
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "./node_modules/@temporalio/workflow/lib/global-attributes.js");
var StartChildWorkflowExecutionFailedCause;
(function (StartChildWorkflowExecutionFailedCause) {
    StartChildWorkflowExecutionFailedCause[StartChildWorkflowExecutionFailedCause["START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED"] = 0] = "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED";
    StartChildWorkflowExecutionFailedCause[StartChildWorkflowExecutionFailedCause["START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS"] = 1] = "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS";
})(StartChildWorkflowExecutionFailedCause || (StartChildWorkflowExecutionFailedCause = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
/**
 * A class that acts as a marker for this special result type
 */
let LocalActivityDoBackoff = class LocalActivityDoBackoff extends Error {
    constructor(backoff) {
        super();
        this.backoff = backoff;
    }
};
LocalActivityDoBackoff = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('LocalActivityDoBackoff')
], LocalActivityDoBackoff);
exports.LocalActivityDoBackoff = LocalActivityDoBackoff;
/**
 * Keeps all of the Workflow runtime state like pending completions for activities and timers.
 *
 * Implements handlers for all workflow activation jobs.
 */
class Activator {
    constructor({ info, now, showStackTraceSources, sourceMap, getTimeOfDay, randomnessSeed, patches, registeredActivityNames, }) {
        /**
         * Cache for modules - referenced in reusable-vm.ts
         */
        this.moduleCache = new Map();
        /**
         * Map of task sequence to a Completion
         */
        this.completions = {
            timer: new Map(),
            activity: new Map(),
            childWorkflowStart: new Map(),
            childWorkflowComplete: new Map(),
            signalWorkflow: new Map(),
            cancelWorkflow: new Map(),
        };
        /**
         * Holds buffered signal calls until a handler is registered
         */
        this.bufferedSignals = Array();
        /**
         * Holds buffered query calls until a handler is registered.
         *
         * **IMPORTANT** queries are only buffered until workflow is started.
         * This is required because async interceptors might block workflow function invocation
         * which delays query handler registration.
         */
        this.bufferedQueries = Array();
        /**
         * Mapping of signal name to handler
         */
        this.signalHandlers = new Map();
        this.promiseStackStore = {
            promiseToStack: new Map(),
            childToParent: new Map(),
        };
        this.rootScope = new cancellation_scope_1.RootCancellationScope();
        /**
         * Mapping of query name to handler
         */
        this.queryHandlers = new Map([
            [
                '__stack_trace',
                () => {
                    return this.getStackTraces()
                        .map((s) => s.formatted)
                        .join('\n\n');
                },
            ],
            [
                '__enhanced_stack_trace',
                () => {
                    const { sourceMap } = this;
                    const sdk = { name: 'typescript', version: pkg_1.default.version };
                    const stacks = this.getStackTraces().map(({ structured: locations }) => ({ locations }));
                    const sources = {};
                    if (this.showStackTraceSources) {
                        for (const { locations } of stacks) {
                            for (const { filePath } of locations) {
                                if (!filePath)
                                    continue;
                                const content = sourceMap?.sourcesContent?.[sourceMap?.sources.indexOf(filePath)];
                                if (!content)
                                    continue;
                                sources[filePath] = [
                                    {
                                        content,
                                        lineOffset: 0,
                                    },
                                ];
                            }
                        }
                    }
                    return { sdk, stacks, sources };
                },
            ],
        ]);
        /**
         * Loaded in {@link initRuntime}
         */
        this.interceptors = { inbound: [], outbound: [], internals: [] };
        /**
         * Buffer that stores all generated commands, reset after each activation
         */
        this.commands = [];
        /**
         * Stores all {@link condition}s that haven't been unblocked yet
         */
        this.blockedConditions = new Map();
        /**
         * Is this Workflow completed?
         *
         * A Workflow will be considered completed if it generates a command that the
         * system considers as a final Workflow command (e.g.
         * completeWorkflowExecution or failWorkflowExecution).
         */
        this.completed = false;
        /**
         * Was this Workflow cancelled?
         */
        this.cancelled = false;
        /**
         * This is tracked to allow buffering queries until a workflow function is called.
         * TODO(bergundy): I don't think this makes sense since queries run last in an activation and must be responded to in
         * the same activation.
         */
        this.workflowFunctionWasCalled = false;
        /**
         * The next (incremental) sequence to assign when generating completable commands
         */
        this.nextSeqs = {
            timer: 1,
            activity: 1,
            childWorkflow: 1,
            signalWorkflow: 1,
            cancelWorkflow: 1,
            condition: 1,
            // Used internally to keep track of active stack traces
            stack: 1,
        };
        this.payloadConverter = common_1.defaultPayloadConverter;
        this.failureConverter = common_1.defaultFailureConverter;
        /**
         * Patches we know the status of for this workflow, as in {@link patched}
         */
        this.knownPresentPatches = new Set();
        /**
         * Patches we sent to core {@link patched}
         */
        this.sentPatches = new Set();
        /**
         * Buffered sink calls per activation
         */
        this.sinkCalls = Array();
        this.getTimeOfDay = getTimeOfDay;
        this.info = info;
        this.now = now;
        this.showStackTraceSources = showStackTraceSources;
        this.sourceMap = sourceMap;
        this.random = (0, alea_1.alea)(randomnessSeed);
        this.registeredActivityNames = registeredActivityNames;
        if (info.unsafe.isReplaying) {
            for (const patchId of patches) {
                this.notifyHasPatch({ patchId });
            }
        }
    }
    getStackTraces() {
        const { childToParent, promiseToStack } = this.promiseStackStore;
        const internalNodes = [...childToParent.values()].reduce((acc, curr) => {
            for (const p of curr) {
                acc.add(p);
            }
            return acc;
        }, new Set());
        const stacks = new Map();
        for (const child of childToParent.keys()) {
            if (!internalNodes.has(child)) {
                const stack = promiseToStack.get(child);
                if (!stack || !stack.formatted)
                    continue;
                stacks.set(stack.formatted, stack);
            }
        }
        // Not 100% sure where this comes from, just filter it out
        stacks.delete('    at Promise.then (<anonymous>)');
        stacks.delete('    at Promise.then (<anonymous>)\n');
        return [...stacks].map(([_, stack]) => stack);
    }
    getAndResetSinkCalls() {
        const { sinkCalls } = this;
        this.sinkCalls = [];
        return sinkCalls;
    }
    /**
     * Buffer a Workflow command to be collected at the end of the current activation.
     *
     * Prevents commands from being added after Workflow completion.
     */
    pushCommand(cmd, complete = false) {
        // Only query responses may be sent after completion
        if (this.completed && !cmd.respondToQuery)
            return;
        this.commands.push(cmd);
        if (complete) {
            this.completed = true;
        }
    }
    getAndResetCommands() {
        const commands = this.commands;
        this.commands = [];
        return commands;
    }
    async startWorkflowNextHandler({ args }) {
        const { workflow } = this;
        if (workflow === undefined) {
            throw new common_1.IllegalStateError('Workflow uninitialized');
        }
        let promise;
        try {
            promise = workflow(...args);
        }
        finally {
            // Guarantee this runs even if there was an exception when invoking the Workflow function
            // Otherwise this Workflow will now be queryable.
            this.workflowFunctionWasCalled = true;
            // Empty the buffer
            const buffer = this.bufferedQueries.splice(0);
            for (const activation of buffer) {
                this.queryWorkflow(activation);
            }
        }
        return await promise;
    }
    startWorkflow(activation) {
        const execute = (0, interceptors_1.composeInterceptors)(this.interceptors.inbound, 'execute', this.startWorkflowNextHandler.bind(this));
        (0, stack_helpers_1.untrackPromise)(execute({
            headers: activation.headers ?? {},
            args: (0, common_1.arrayFromPayloads)(this.payloadConverter, activation.arguments),
        }).then(this.completeWorkflow.bind(this), this.handleWorkflowFailure.bind(this)));
    }
    cancelWorkflow(_activation) {
        this.cancelled = true;
        this.rootScope.cancel();
    }
    fireTimer(activation) {
        // Timers are a special case where their completion might not be in Workflow state,
        // this is due to immediate timer cancellation that doesn't go wait for Core.
        const completion = this.maybeConsumeCompletion('timer', getSeq(activation));
        completion?.resolve(undefined);
    }
    resolveActivity(activation) {
        if (!activation.result) {
            throw new TypeError('Got ResolveActivity activation with no result');
        }
        const { resolve, reject } = this.consumeCompletion('activity', getSeq(activation));
        if (activation.result.completed) {
            const completed = activation.result.completed;
            const result = completed.result ? this.payloadConverter.fromPayload(completed.result) : undefined;
            resolve(result);
        }
        else if (activation.result.failed) {
            const { failure } = activation.result.failed;
            const err = failure ? this.failureToError(failure) : undefined;
            reject(err);
        }
        else if (activation.result.cancelled) {
            const { failure } = activation.result.cancelled;
            const err = failure ? this.failureToError(failure) : undefined;
            reject(err);
        }
        else if (activation.result.backoff) {
            reject(new LocalActivityDoBackoff(activation.result.backoff));
        }
    }
    resolveChildWorkflowExecutionStart(activation) {
        const { resolve, reject } = this.consumeCompletion('childWorkflowStart', getSeq(activation));
        if (activation.succeeded) {
            resolve(activation.succeeded.runId);
        }
        else if (activation.failed) {
            if (activation.failed.cause !==
                StartChildWorkflowExecutionFailedCause.START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS) {
                throw new common_1.IllegalStateError('Got unknown StartChildWorkflowExecutionFailedCause');
            }
            if (!(activation.seq && activation.failed.workflowId && activation.failed.workflowType)) {
                throw new TypeError('Missing attributes in activation job');
            }
            reject(new common_1.WorkflowExecutionAlreadyStartedError('Workflow execution already started', activation.failed.workflowId, activation.failed.workflowType));
        }
        else if (activation.cancelled) {
            if (!activation.cancelled.failure) {
                throw new TypeError('Got no failure in cancelled variant');
            }
            reject(this.failureToError(activation.cancelled.failure));
        }
        else {
            throw new TypeError('Got ResolveChildWorkflowExecutionStart with no status');
        }
    }
    resolveChildWorkflowExecution(activation) {
        if (!activation.result) {
            throw new TypeError('Got ResolveChildWorkflowExecution activation with no result');
        }
        const { resolve, reject } = this.consumeCompletion('childWorkflowComplete', getSeq(activation));
        if (activation.result.completed) {
            const completed = activation.result.completed;
            const result = completed.result ? this.payloadConverter.fromPayload(completed.result) : undefined;
            resolve(result);
        }
        else if (activation.result.failed) {
            const { failure } = activation.result.failed;
            if (failure === undefined || failure === null) {
                throw new TypeError('Got failed result with no failure attribute');
            }
            reject(this.failureToError(failure));
        }
        else if (activation.result.cancelled) {
            const { failure } = activation.result.cancelled;
            if (failure === undefined || failure === null) {
                throw new TypeError('Got cancelled result with no failure attribute');
            }
            reject(this.failureToError(failure));
        }
    }
    // Intentionally not made function async so this handler doesn't show up in the stack trace
    queryWorkflowNextHandler({ queryName, args }) {
        const fn = this.queryHandlers.get(queryName);
        if (fn === undefined) {
            const knownQueryTypes = [...this.queryHandlers.keys()].join(' ');
            // Fail the query
            return Promise.reject(new ReferenceError(`Workflow did not register a handler for ${queryName}. Registered queries: [${knownQueryTypes}]`));
        }
        try {
            const ret = fn(...args);
            if (ret instanceof Promise) {
                return Promise.reject(new errors_1.DeterminismViolationError('Query handlers should not return a Promise'));
            }
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    queryWorkflow(activation) {
        if (!this.workflowFunctionWasCalled) {
            this.bufferedQueries.push(activation);
            return;
        }
        const { queryType, queryId, headers } = activation;
        if (!(queryType && queryId)) {
            throw new TypeError('Missing query activation attributes');
        }
        const execute = (0, interceptors_1.composeInterceptors)(this.interceptors.inbound, 'handleQuery', this.queryWorkflowNextHandler.bind(this));
        execute({
            queryName: queryType,
            args: (0, common_1.arrayFromPayloads)(this.payloadConverter, activation.arguments),
            queryId,
            headers: headers ?? {},
        }).then((result) => this.completeQuery(queryId, result), (reason) => this.failQuery(queryId, reason));
    }
    async signalWorkflowNextHandler({ signalName, args }) {
        const fn = this.signalHandlers.get(signalName);
        if (fn) {
            return await fn(...args);
        }
        else if (this.defaultSignalHandler) {
            return await this.defaultSignalHandler(signalName, ...args);
        }
        else {
            throw new common_1.IllegalStateError(`No registered signal handler for signal ${signalName}`);
        }
    }
    signalWorkflow(activation) {
        const { signalName, headers } = activation;
        if (!signalName) {
            throw new TypeError('Missing activation signalName');
        }
        if (!this.signalHandlers.has(signalName) && !this.defaultSignalHandler) {
            this.bufferedSignals.push(activation);
            return;
        }
        const execute = (0, interceptors_1.composeInterceptors)(this.interceptors.inbound, 'handleSignal', this.signalWorkflowNextHandler.bind(this));
        execute({
            args: (0, common_1.arrayFromPayloads)(this.payloadConverter, activation.input),
            signalName,
            headers: headers ?? {},
        }).catch(this.handleWorkflowFailure.bind(this));
    }
    dispatchBufferedSignals() {
        const bufferedSignals = this.bufferedSignals;
        while (bufferedSignals.length) {
            if (this.defaultSignalHandler) {
                // We have a default signal handler, so all signals are dispatchable
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.signalWorkflow(bufferedSignals.shift());
            }
            else {
                const foundIndex = bufferedSignals.findIndex((signal) => this.signalHandlers.has(signal.signalName ?? ''));
                if (foundIndex === -1)
                    break;
                const [signal] = bufferedSignals.splice(foundIndex, 1);
                this.signalWorkflow(signal);
            }
        }
    }
    resolveSignalExternalWorkflow(activation) {
        const { resolve, reject } = this.consumeCompletion('signalWorkflow', getSeq(activation));
        if (activation.failure) {
            reject(this.failureToError(activation.failure));
        }
        else {
            resolve(undefined);
        }
    }
    resolveRequestCancelExternalWorkflow(activation) {
        const { resolve, reject } = this.consumeCompletion('cancelWorkflow', getSeq(activation));
        if (activation.failure) {
            reject(this.failureToError(activation.failure));
        }
        else {
            resolve(undefined);
        }
    }
    updateRandomSeed(activation) {
        if (!activation.randomnessSeed) {
            throw new TypeError('Expected activation with randomnessSeed attribute');
        }
        this.random = (0, alea_1.alea)(activation.randomnessSeed.toBytes());
    }
    notifyHasPatch(activation) {
        if (!activation.patchId) {
            throw new TypeError('Notify has patch missing patch name');
        }
        this.knownPresentPatches.add(activation.patchId);
    }
    removeFromCache() {
        throw new common_1.IllegalStateError('removeFromCache activation job should not reach workflow');
    }
    /**
     * Transforms failures into a command to be sent to the server.
     * Used to handle any failure emitted by the Workflow.
     */
    async handleWorkflowFailure(error) {
        if (this.cancelled && (0, errors_1.isCancellation)(error)) {
            this.pushCommand({ cancelWorkflowExecution: {} }, true);
        }
        else if (error instanceof interfaces_1.ContinueAsNew) {
            this.pushCommand({ continueAsNewWorkflowExecution: error.command }, true);
        }
        else {
            if (!(error instanceof common_1.TemporalFailure)) {
                // This results in an unhandled rejection which will fail the activation
                // preventing it from completing.
                throw error;
            }
            this.pushCommand({
                failWorkflowExecution: {
                    failure: this.errorToFailure(error),
                },
            }, true);
        }
    }
    completeQuery(queryId, result) {
        this.pushCommand({
            respondToQuery: { queryId, succeeded: { response: this.payloadConverter.toPayload(result) } },
        });
    }
    failQuery(queryId, error) {
        this.pushCommand({
            respondToQuery: {
                queryId,
                failed: this.errorToFailure((0, common_1.ensureTemporalFailure)(error)),
            },
        });
    }
    /** Consume a completion if it exists in Workflow state */
    maybeConsumeCompletion(type, taskSeq) {
        const completion = this.completions[type].get(taskSeq);
        if (completion !== undefined) {
            this.completions[type].delete(taskSeq);
        }
        return completion;
    }
    /** Consume a completion if it exists in Workflow state, throws if it doesn't */
    consumeCompletion(type, taskSeq) {
        const completion = this.maybeConsumeCompletion(type, taskSeq);
        if (completion === undefined) {
            throw new common_1.IllegalStateError(`No completion for taskSeq ${taskSeq}`);
        }
        return completion;
    }
    completeWorkflow(result) {
        this.pushCommand({
            completeWorkflowExecution: {
                result: this.payloadConverter.toPayload(result),
            },
        }, true);
    }
    errorToFailure(err) {
        return this.failureConverter.errorToFailure(err, this.payloadConverter);
    }
    failureToError(failure) {
        return this.failureConverter.failureToError(failure, this.payloadConverter);
    }
}
exports.Activator = Activator;
function maybeGetActivator() {
    return (0, global_attributes_1.maybeGetActivatorUntyped)();
}
exports.maybeGetActivator = maybeGetActivator;
function getActivator() {
    const activator = maybeGetActivator();
    if (activator === undefined) {
        throw new common_1.IllegalStateError('Workflow uninitialized');
    }
    return activator;
}
exports.getActivator = getActivator;
function getSeq(activation) {
    const seq = activation.seq;
    if (seq === undefined || seq === null) {
        throw new TypeError(`Got activation with no seq attribute`);
    }
    return seq;
}


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/pkg.js":
/*!******************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/pkg.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// ../package.json is outside of the TS project rootDir which causes TS to complain about this import.
// We do not want to change the rootDir because it messes up the output structure.
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const package_json_1 = __importDefault(__webpack_require__(/*! ../package.json */ "./node_modules/@temporalio/workflow/package.json"));
exports["default"] = package_json_1.default;


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/stack-helpers.js":
/*!****************************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/stack-helpers.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.untrackPromise = void 0;
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "./node_modules/@temporalio/workflow/lib/global-attributes.js");
/**
 * Helper function to remove a promise from being tracked for stack trace query purposes
 */
function untrackPromise(promise) {
    const store = (0, global_attributes_1.maybeGetActivatorUntyped)()?.promiseStackStore;
    if (!store)
        return;
    store.childToParent.delete(promise);
    store.promiseToStack.delete(promise);
}
exports.untrackPromise = untrackPromise;


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/trigger.js":
/*!**********************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/trigger.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Trigger = void 0;
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "./node_modules/@temporalio/workflow/lib/stack-helpers.js");
/**
 * A `PromiseLike` helper which exposes its `resolve` and `reject` methods.
 *
 * Trigger is CancellationScope-aware: it is linked to the current scope on
 * construction and throws when that scope is cancelled.
 *
 * Useful for e.g. waiting for unblocking a Workflow from a Signal.
 *
 * @example
 * <!--SNIPSTART typescript-trigger-workflow-->
 * <!--SNIPEND-->
 */
class Trigger {
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            const scope = cancellation_scope_1.CancellationScope.current();
            if (scope.consideredCancelled || scope.cancellable) {
                (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this.resolve = resolve;
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this.reject = reject;
        });
        // Avoid unhandled rejections
        (0, stack_helpers_1.untrackPromise)(this.promise.catch(() => undefined));
    }
    then(onfulfilled, onrejected) {
        return this.promise.then(onfulfilled, onrejected);
    }
}
exports.Trigger = Trigger;


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/worker-interface.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/worker-interface.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dispose = exports.shouldUnblockConditions = exports.tryUnblockConditions = exports.getAndResetSinkCalls = exports.concludeActivation = exports.activate = exports.initRuntime = exports.overrideGlobals = void 0;
/**
 * Exported functions for the Worker to interact with the Workflow isolate
 *
 * @module
 */
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/@temporalio/common/lib/index.js");
const time_1 = __webpack_require__(/*! @temporalio/common/lib/time */ "./node_modules/@temporalio/common/lib/time.js");
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "./node_modules/@temporalio/common/lib/interceptors.js");
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@temporalio/workflow/lib/errors.js");
const internals_1 = __webpack_require__(/*! ./internals */ "./node_modules/@temporalio/workflow/lib/internals.js");
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "./node_modules/@temporalio/workflow/lib/global-attributes.js");
const global = globalThis;
const OriginalDate = globalThis.Date;
function overrideGlobals() {
    // Mock any weak reference because GC is non-deterministic and the effect is observable from the Workflow.
    // Workflow developer will get a meaningful exception if they try to use these.
    global.WeakRef = function () {
        throw new errors_1.DeterminismViolationError('WeakRef cannot be used in Workflows because v8 GC is non-deterministic');
    };
    global.FinalizationRegistry = function () {
        throw new errors_1.DeterminismViolationError('FinalizationRegistry cannot be used in Workflows because v8 GC is non-deterministic');
    };
    global.Date = function (...args) {
        if (args.length > 0) {
            return new OriginalDate(...args);
        }
        return new OriginalDate((0, internals_1.getActivator)().now);
    };
    global.Date.now = function () {
        return (0, internals_1.getActivator)().now;
    };
    global.Date.parse = OriginalDate.parse.bind(OriginalDate);
    global.Date.UTC = OriginalDate.UTC.bind(OriginalDate);
    global.Date.prototype = OriginalDate.prototype;
    /**
     * @param ms sleep duration -  number of milliseconds. If given a negative number, value will be set to 1.
     */
    global.setTimeout = function (cb, ms, ...args) {
        const activator = (0, internals_1.getActivator)();
        ms = Math.max(1, ms);
        const seq = activator.nextSeqs.timer++;
        // Create a Promise for AsyncLocalStorage to be able to track this completion using promise hooks.
        new Promise((resolve, reject) => {
            activator.completions.timer.set(seq, { resolve, reject });
            activator.pushCommand({
                startTimer: {
                    seq,
                    startToFireTimeout: (0, time_1.msToTs)(ms),
                },
            });
        }).then(() => cb(...args), () => undefined /* ignore cancellation */);
        return seq;
    };
    global.clearTimeout = function (handle) {
        const activator = (0, internals_1.getActivator)();
        activator.nextSeqs.timer++;
        activator.completions.timer.delete(handle);
        activator.pushCommand({
            cancelTimer: {
                seq: handle,
            },
        });
    };
    // activator.random is mutable, don't hardcode its reference
    Math.random = () => (0, internals_1.getActivator)().random();
}
exports.overrideGlobals = overrideGlobals;
/**
 * Initialize the isolate runtime.
 *
 * Sets required internal state and instantiates the workflow and interceptors.
 */
function initRuntime(options) {
    const info = fixPrototypes(options.info);
    info.unsafe.now = OriginalDate.now;
    const activator = new internals_1.Activator({ ...options, info });
    // There's on activator per workflow instance, set it globally on the context.
    // We do this before importing any user code so user code can statically reference @temporalio/workflow functions
    // as well as Date and Math.random.
    (0, global_attributes_1.setActivatorUntyped)(activator);
    // webpack alias to payloadConverterPath
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const customPayloadConverter = (__webpack_require__(/*! __temporal_custom_payload_converter */ "?2065").payloadConverter);
    // The `payloadConverter` export is validated in the Worker
    if (customPayloadConverter != null) {
        activator.payloadConverter = customPayloadConverter;
    }
    // webpack alias to failureConverterPath
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const customFailureConverter = (__webpack_require__(/*! __temporal_custom_failure_converter */ "?31ff").failureConverter);
    // The `failureConverter` export is validated in the Worker
    if (customFailureConverter != null) {
        activator.failureConverter = customFailureConverter;
    }
    const { importWorkflows, importInterceptors } = global.__TEMPORAL__;
    if (importWorkflows === undefined || importInterceptors === undefined) {
        throw new common_1.IllegalStateError('Workflow bundle did not register import hooks');
    }
    const interceptors = importInterceptors();
    for (const mod of interceptors) {
        const factory = mod.interceptors;
        if (factory !== undefined) {
            if (typeof factory !== 'function') {
                throw new TypeError(`Failed to initialize workflows interceptors: expected a function, but got: '${factory}'`);
            }
            const interceptors = factory();
            activator.interceptors.inbound.push(...(interceptors.inbound ?? []));
            activator.interceptors.outbound.push(...(interceptors.outbound ?? []));
            activator.interceptors.internals.push(...(interceptors.internals ?? []));
        }
    }
    const mod = importWorkflows();
    const workflowFn = mod[info.workflowType];
    const defaultWorkflowFn = mod['default'];
    if (typeof workflowFn === 'function') {
        activator.workflow = workflowFn;
    }
    else if (typeof defaultWorkflowFn === 'function') {
        activator.workflow = defaultWorkflowFn;
    }
    else {
        const details = workflowFn === undefined
            ? 'no such function is exported by the workflow bundle'
            : `expected a function, but got: '${typeof workflowFn}'`;
        throw new TypeError(`Failed to initialize workflow of type '${info.workflowType}': ${details}`);
    }
}
exports.initRuntime = initRuntime;
/**
 * Objects transfered to the VM from outside have prototypes belonging to the
 * outer context, which means that instanceof won't work inside the VM. This
 * function recursively walks over the content of an object, and recreate some
 * of these objects (notably Array, Date and Objects).
 */
function fixPrototypes(obj) {
    if (obj != null && typeof obj === 'object') {
        switch (Object.getPrototypeOf(obj)?.constructor?.name) {
            case 'Array':
                return Array.from(obj.map(fixPrototypes));
            case 'Date':
                return new Date(obj);
            default:
                return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, fixPrototypes(v)]));
        }
    }
    else
        return obj;
}
/**
 * Run a chunk of activation jobs
 * @returns a boolean indicating whether job was processed or ignored
 */
function activate(activation, batchIndex) {
    const activator = (0, internals_1.getActivator)();
    const intercept = (0, interceptors_1.composeInterceptors)(activator.interceptors.internals, 'activate', ({ activation, batchIndex }) => {
        if (batchIndex === 0) {
            if (!activation.jobs) {
                throw new TypeError('Got activation with no jobs');
            }
            if (activation.timestamp != null) {
                // timestamp will not be updated for activation that contain only queries
                activator.now = (0, time_1.tsToMs)(activation.timestamp);
            }
            // The Rust Core ensures that these activation fields are not null
            activator.info.unsafe.isReplaying = activation.isReplaying ?? false;
            activator.info.historyLength = activation.historyLength;
            // Exact truncation for multi-petabyte histories
            // historySize === 0 means WFT was generated by pre-1.20.0 server, and the history size is unknown
            activator.info.historySize = activation.historySizeBytes?.toNumber() || 0;
            activator.info.continueAsNewSuggested = activation.continueAsNewSuggested ?? false;
        }
        // Cast from the interface to the class which has the `variant` attribute.
        // This is safe because we know that activation is a proto class.
        const jobs = activation.jobs;
        for (const job of jobs) {
            if (job.variant === undefined) {
                throw new TypeError('Expected job.variant to be defined');
            }
            const variant = job[job.variant];
            if (!variant) {
                throw new TypeError(`Expected job.${job.variant} to be set`);
            }
            // The only job that can be executed on a completed workflow is a query.
            // We might get other jobs after completion for instance when a single
            // activation contains multiple jobs and the first one completes the workflow.
            if (activator.completed && job.variant !== 'queryWorkflow') {
                return;
            }
            activator[job.variant](variant /* TS can't infer this type */);
            if (shouldUnblockConditions(job)) {
                tryUnblockConditions();
            }
        }
    });
    intercept({
        activation,
        batchIndex,
    });
}
exports.activate = activate;
/**
 * Conclude a single activation.
 * Should be called after processing all activation jobs and queued microtasks.
 *
 * Activation failures are handled in the main Node.js isolate.
 */
function concludeActivation() {
    const activator = (0, internals_1.getActivator)();
    const intercept = (0, interceptors_1.composeInterceptors)(activator.interceptors.internals, 'concludeActivation', (input) => input);
    const { info } = activator;
    const { commands } = intercept({ commands: activator.getAndResetCommands() });
    return {
        runId: info.runId,
        successful: { commands },
    };
}
exports.concludeActivation = concludeActivation;
function getAndResetSinkCalls() {
    return (0, internals_1.getActivator)().getAndResetSinkCalls();
}
exports.getAndResetSinkCalls = getAndResetSinkCalls;
/**
 * Loop through all blocked conditions, evaluate and unblock if possible.
 *
 * @returns number of unblocked conditions.
 */
function tryUnblockConditions() {
    let numUnblocked = 0;
    for (;;) {
        const prevUnblocked = numUnblocked;
        for (const [seq, cond] of (0, internals_1.getActivator)().blockedConditions.entries()) {
            if (cond.fn()) {
                cond.resolve();
                numUnblocked++;
                // It is safe to delete elements during map iteration
                (0, internals_1.getActivator)().blockedConditions.delete(seq);
            }
        }
        if (prevUnblocked === numUnblocked) {
            break;
        }
    }
    return numUnblocked;
}
exports.tryUnblockConditions = tryUnblockConditions;
/**
 * Predicate used to prevent triggering conditions for non-query and non-patch jobs.
 */
function shouldUnblockConditions(job) {
    return !job.queryWorkflow && !job.notifyHasPatch;
}
exports.shouldUnblockConditions = shouldUnblockConditions;
function dispose() {
    const dispose = (0, interceptors_1.composeInterceptors)((0, internals_1.getActivator)().interceptors.internals, 'dispose', async () => {
        (0, cancellation_scope_1.disableStorage)();
    });
    dispose({});
}
exports.dispose = dispose;


/***/ }),

/***/ "./node_modules/@temporalio/workflow/lib/workflow.js":
/*!***********************************************************!*\
  !*** ./node_modules/@temporalio/workflow/lib/workflow.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.log = exports.enhancedStackTraceQuery = exports.stackTraceQuery = exports.upsertSearchAttributes = exports.setDefaultSignalHandler = exports.setHandler = exports.defineQuery = exports.defineSignal = exports.condition = exports.deprecatePatch = exports.patched = exports.uuid4 = exports.continueAsNew = exports.makeContinueAsNewFunc = exports.proxySinks = exports.inWorkflowContext = exports.workflowInfo = exports.executeChild = exports.startChild = exports.getExternalWorkflowHandle = exports.proxyLocalActivities = exports.proxyActivities = exports.NotAnActivityMethod = exports.scheduleLocalActivity = exports.scheduleActivity = exports.sleep = exports.addDefaultWorkflowOptions = void 0;
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/@temporalio/common/lib/index.js");
const versioning_intent_enum_1 = __webpack_require__(/*! @temporalio/common/lib/versioning-intent-enum */ "./node_modules/@temporalio/common/lib/versioning-intent-enum.js");
const time_1 = __webpack_require__(/*! @temporalio/common/lib/time */ "./node_modules/@temporalio/common/lib/time.js");
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "./node_modules/@temporalio/common/lib/interceptors.js");
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const interfaces_1 = __webpack_require__(/*! ./interfaces */ "./node_modules/@temporalio/workflow/lib/interfaces.js");
const internals_1 = __webpack_require__(/*! ./internals */ "./node_modules/@temporalio/workflow/lib/internals.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "./node_modules/@temporalio/workflow/lib/stack-helpers.js");
// Avoid a circular dependency
(0, cancellation_scope_1.registerSleepImplementation)(sleep);
/**
 * Adds default values to `workflowId` and `workflowIdReusePolicy` to given workflow options.
 */
function addDefaultWorkflowOptions(opts) {
    const { args, workflowId, ...rest } = opts;
    return {
        workflowId: workflowId ?? uuid4(),
        args: args ?? [],
        cancellationType: interfaces_1.ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,
        ...rest,
    };
}
exports.addDefaultWorkflowOptions = addDefaultWorkflowOptions;
/**
 * Push a startTimer command into state accumulator and register completion
 */
function timerNextHandler(input) {
    const activator = (0, internals_1.getActivator)();
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch((err) => {
                if (!activator.completions.timer.delete(input.seq)) {
                    return; // Already resolved or never scheduled
                }
                activator.pushCommand({
                    cancelTimer: {
                        seq: input.seq,
                    },
                });
                reject(err);
            }));
        }
        activator.pushCommand({
            startTimer: {
                seq: input.seq,
                startToFireTimeout: (0, time_1.msToTs)(input.durationMs),
            },
        });
        activator.completions.timer.set(input.seq, {
            resolve,
            reject,
        });
    });
}
/**
 * Asynchronous sleep.
 *
 * Schedules a timer on the Temporal service.
 *
 * @param ms sleep duration - number of milliseconds or {@link https://www.npmjs.com/package/ms | ms-formatted string}.
 * If given a negative number or 0, value will be set to 1.
 */
function sleep(ms) {
    const activator = assertInWorkflowContext('Workflow.sleep(...) may only be used from a Workflow Execution');
    const seq = activator.nextSeqs.timer++;
    const durationMs = Math.max(1, (0, time_1.msToNumber)(ms));
    const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'startTimer', timerNextHandler);
    return execute({
        durationMs,
        seq,
    });
}
exports.sleep = sleep;
function validateActivityOptions(options) {
    if (options.scheduleToCloseTimeout === undefined && options.startToCloseTimeout === undefined) {
        throw new TypeError('Required either scheduleToCloseTimeout or startToCloseTimeout');
    }
}
// Use same validation we use for normal activities
const validateLocalActivityOptions = validateActivityOptions;
/**
 * Push a scheduleActivity command into activator accumulator and register completion
 */
function scheduleActivityNextHandler({ options, args, headers, seq, activityType }) {
    const activator = (0, internals_1.getActivator)();
    validateActivityOptions(options);
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                if (!activator.completions.activity.has(seq)) {
                    return; // Already resolved or never scheduled
                }
                activator.pushCommand({
                    requestCancelActivity: {
                        seq,
                    },
                });
            }));
        }
        activator.pushCommand({
            scheduleActivity: {
                seq,
                activityId: options.activityId ?? `${seq}`,
                activityType,
                arguments: (0, common_1.toPayloads)(activator.payloadConverter, ...args),
                retryPolicy: options.retry ? (0, common_1.compileRetryPolicy)(options.retry) : undefined,
                taskQueue: options.taskQueue || activator.info?.taskQueue,
                heartbeatTimeout: (0, time_1.msOptionalToTs)(options.heartbeatTimeout),
                scheduleToCloseTimeout: (0, time_1.msOptionalToTs)(options.scheduleToCloseTimeout),
                startToCloseTimeout: (0, time_1.msOptionalToTs)(options.startToCloseTimeout),
                scheduleToStartTimeout: (0, time_1.msOptionalToTs)(options.scheduleToStartTimeout),
                headers,
                cancellationType: options.cancellationType,
                doNotEagerlyExecute: !(options.allowEagerDispatch ?? true),
                versioningIntent: (0, versioning_intent_enum_1.versioningIntentToProto)(options.versioningIntent),
            },
        });
        activator.completions.activity.set(seq, {
            resolve,
            reject,
        });
    });
}
/**
 * Push a scheduleActivity command into state accumulator and register completion
 */
async function scheduleLocalActivityNextHandler({ options, args, headers, seq, activityType, attempt, originalScheduleTime, }) {
    const activator = (0, internals_1.getActivator)();
    // Eagerly fail the local activity (which will in turn fail the workflow task.
    // Do not fail on replay where the local activities may not be registered on the replay worker.
    if (!workflowInfo().unsafe.isReplaying && !activator.registeredActivityNames.has(activityType)) {
        throw new ReferenceError(`Local activity of type '${activityType}' not registered on worker`);
    }
    validateLocalActivityOptions(options);
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                if (!activator.completions.activity.has(seq)) {
                    return; // Already resolved or never scheduled
                }
                activator.pushCommand({
                    requestCancelLocalActivity: {
                        seq,
                    },
                });
            }));
        }
        activator.pushCommand({
            scheduleLocalActivity: {
                seq,
                attempt,
                originalScheduleTime,
                // Intentionally not exposing activityId as an option
                activityId: `${seq}`,
                activityType,
                arguments: (0, common_1.toPayloads)(activator.payloadConverter, ...args),
                retryPolicy: options.retry ? (0, common_1.compileRetryPolicy)(options.retry) : undefined,
                scheduleToCloseTimeout: (0, time_1.msOptionalToTs)(options.scheduleToCloseTimeout),
                startToCloseTimeout: (0, time_1.msOptionalToTs)(options.startToCloseTimeout),
                scheduleToStartTimeout: (0, time_1.msOptionalToTs)(options.scheduleToStartTimeout),
                localRetryThreshold: (0, time_1.msOptionalToTs)(options.localRetryThreshold),
                headers,
                cancellationType: options.cancellationType,
            },
        });
        activator.completions.activity.set(seq, {
            resolve,
            reject,
        });
    });
}
/**
 * Schedule an activity and run outbound interceptors
 * @hidden
 */
function scheduleActivity(activityType, args, options) {
    const activator = assertInWorkflowContext('Workflow.scheduleActivity(...) may only be used from a Workflow Execution');
    if (options === undefined) {
        throw new TypeError('Got empty activity options');
    }
    const seq = activator.nextSeqs.activity++;
    const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'scheduleActivity', scheduleActivityNextHandler);
    return execute({
        activityType,
        headers: {},
        options,
        args,
        seq,
    });
}
exports.scheduleActivity = scheduleActivity;
/**
 * Schedule an activity and run outbound interceptors
 * @hidden
 */
async function scheduleLocalActivity(activityType, args, options) {
    const activator = assertInWorkflowContext('Workflow.scheduleLocalActivity(...) may only be used from a Workflow Execution');
    if (options === undefined) {
        throw new TypeError('Got empty activity options');
    }
    let attempt = 1;
    let originalScheduleTime = undefined;
    for (;;) {
        const seq = activator.nextSeqs.activity++;
        const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'scheduleLocalActivity', scheduleLocalActivityNextHandler);
        try {
            return (await execute({
                activityType,
                headers: {},
                options,
                args,
                seq,
                attempt,
                originalScheduleTime,
            }));
        }
        catch (err) {
            if (err instanceof internals_1.LocalActivityDoBackoff) {
                await sleep((0, time_1.tsToMs)(err.backoff.backoffDuration));
                if (typeof err.backoff.attempt !== 'number') {
                    throw new TypeError('Invalid backoff attempt type');
                }
                attempt = err.backoff.attempt;
                originalScheduleTime = err.backoff.originalScheduleTime ?? undefined;
            }
            else {
                throw err;
            }
        }
    }
}
exports.scheduleLocalActivity = scheduleLocalActivity;
function startChildWorkflowExecutionNextHandler({ options, headers, workflowType, seq, }) {
    const activator = (0, internals_1.getActivator)();
    const workflowId = options.workflowId ?? uuid4();
    const startPromise = new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                const complete = !activator.completions.childWorkflowComplete.has(seq);
                if (!complete) {
                    activator.pushCommand({
                        cancelChildWorkflowExecution: { childWorkflowSeq: seq },
                    });
                }
                // Nothing to cancel otherwise
            }));
        }
        activator.pushCommand({
            startChildWorkflowExecution: {
                seq,
                workflowId,
                workflowType,
                input: (0, common_1.toPayloads)(activator.payloadConverter, ...options.args),
                retryPolicy: options.retry ? (0, common_1.compileRetryPolicy)(options.retry) : undefined,
                taskQueue: options.taskQueue || activator.info?.taskQueue,
                workflowExecutionTimeout: (0, time_1.msOptionalToTs)(options.workflowExecutionTimeout),
                workflowRunTimeout: (0, time_1.msOptionalToTs)(options.workflowRunTimeout),
                workflowTaskTimeout: (0, time_1.msOptionalToTs)(options.workflowTaskTimeout),
                namespace: workflowInfo().namespace,
                headers,
                cancellationType: options.cancellationType,
                workflowIdReusePolicy: options.workflowIdReusePolicy,
                parentClosePolicy: options.parentClosePolicy,
                cronSchedule: options.cronSchedule,
                searchAttributes: options.searchAttributes
                    ? (0, common_1.mapToPayloads)(common_1.searchAttributePayloadConverter, options.searchAttributes)
                    : undefined,
                memo: options.memo && (0, common_1.mapToPayloads)(activator.payloadConverter, options.memo),
                versioningIntent: (0, versioning_intent_enum_1.versioningIntentToProto)(options.versioningIntent),
            },
        });
        activator.completions.childWorkflowStart.set(seq, {
            resolve,
            reject,
        });
    });
    // We construct a Promise for the completion of the child Workflow before we know
    // if the Workflow code will await it to capture the result in case it does.
    const completePromise = new Promise((resolve, reject) => {
        // Chain start Promise rejection to the complete Promise.
        (0, stack_helpers_1.untrackPromise)(startPromise.catch(reject));
        activator.completions.childWorkflowComplete.set(seq, {
            resolve,
            reject,
        });
    });
    (0, stack_helpers_1.untrackPromise)(startPromise);
    (0, stack_helpers_1.untrackPromise)(completePromise);
    // Prevent unhandled rejection because the completion might not be awaited
    (0, stack_helpers_1.untrackPromise)(completePromise.catch(() => undefined));
    const ret = new Promise((resolve) => resolve([startPromise, completePromise]));
    (0, stack_helpers_1.untrackPromise)(ret);
    return ret;
}
function signalWorkflowNextHandler({ seq, signalName, args, target, headers }) {
    const activator = (0, internals_1.getActivator)();
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                if (!activator.completions.signalWorkflow.has(seq)) {
                    return;
                }
                activator.pushCommand({ cancelSignalWorkflow: { seq } });
            }));
        }
        activator.pushCommand({
            signalExternalWorkflowExecution: {
                seq,
                args: (0, common_1.toPayloads)(activator.payloadConverter, ...args),
                headers,
                signalName,
                ...(target.type === 'external'
                    ? {
                        workflowExecution: {
                            namespace: activator.info.namespace,
                            ...target.workflowExecution,
                        },
                    }
                    : {
                        childWorkflowId: target.childWorkflowId,
                    }),
            },
        });
        activator.completions.signalWorkflow.set(seq, { resolve, reject });
    });
}
/**
 * Symbol used in the return type of proxy methods to mark that an attribute on the source type is not a method.
 *
 * @see {@link ActivityInterfaceFor}
 * @see {@link proxyActivities}
 * @see {@link proxyLocalActivities}
 */
exports.NotAnActivityMethod = Symbol.for('__TEMPORAL_NOT_AN_ACTIVITY_METHOD');
/**
 * Configure Activity functions with given {@link ActivityOptions}.
 *
 * This method may be called multiple times to setup Activities with different options.
 *
 * @return a {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy | Proxy} for
 *         which each attribute is a callable Activity function
 *
 * @example
 * ```ts
 * import { proxyActivities } from '@temporalio/workflow';
 * import * as activities from '../activities';
 *
 * // Setup Activities from module exports
 * const { httpGet, otherActivity } = proxyActivities<typeof activities>({
 *   startToCloseTimeout: '30 minutes',
 * });
 *
 * // Setup Activities from an explicit interface (e.g. when defined by another SDK)
 * interface JavaActivities {
 *   httpGetFromJava(url: string): Promise<string>
 *   someOtherJavaActivity(arg1: number, arg2: string): Promise<string>;
 * }
 *
 * const {
 *   httpGetFromJava,
 *   someOtherJavaActivity
 * } = proxyActivities<JavaActivities>({
 *   taskQueue: 'java-worker-taskQueue',
 *   startToCloseTimeout: '5m',
 * });
 *
 * export function execute(): Promise<void> {
 *   const response = await httpGet("http://example.com");
 *   // ...
 * }
 * ```
 */
function proxyActivities(options) {
    if (options === undefined) {
        throw new TypeError('options must be defined');
    }
    // Validate as early as possible for immediate user feedback
    validateActivityOptions(options);
    return new Proxy({}, {
        get(_, activityType) {
            if (typeof activityType !== 'string') {
                throw new TypeError(`Only strings are supported for Activity types, got: ${String(activityType)}`);
            }
            return function activityProxyFunction(...args) {
                return scheduleActivity(activityType, args, options);
            };
        },
    });
}
exports.proxyActivities = proxyActivities;
/**
 * Configure Local Activity functions with given {@link LocalActivityOptions}.
 *
 * This method may be called multiple times to setup Activities with different options.
 *
 * @return a {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy | Proxy}
 *         for which each attribute is a callable Activity function
 *
 * @see {@link proxyActivities} for examples
 */
function proxyLocalActivities(options) {
    if (options === undefined) {
        throw new TypeError('options must be defined');
    }
    // Validate as early as possible for immediate user feedback
    validateLocalActivityOptions(options);
    return new Proxy({}, {
        get(_, activityType) {
            if (typeof activityType !== 'string') {
                throw new TypeError(`Only strings are supported for Activity types, got: ${String(activityType)}`);
            }
            return function localActivityProxyFunction(...args) {
                return scheduleLocalActivity(activityType, args, options);
            };
        },
    });
}
exports.proxyLocalActivities = proxyLocalActivities;
// TODO: deprecate this patch after "enough" time has passed
const EXTERNAL_WF_CANCEL_PATCH = '__temporal_internal_connect_external_handle_cancel_to_scope';
// The name of this patch comes from an attempt to build a generic internal patching mechanism.
// That effort has been abandoned in favor of a newer WorkflowTaskCompletedMetadata based mechanism.
const CONDITION_0_PATCH = '__sdk_internal_patch_number:1';
/**
 * Returns a client-side handle that can be used to signal and cancel an existing Workflow execution.
 * It takes a Workflow ID and optional run ID.
 */
function getExternalWorkflowHandle(workflowId, runId) {
    const activator = assertInWorkflowContext('Workflow.getExternalWorkflowHandle(...) may only be used from a Workflow Execution. Consider using Client.workflow.getHandle(...) instead.)');
    return {
        workflowId,
        runId,
        cancel() {
            return new Promise((resolve, reject) => {
                // Connect this cancel operation to the current cancellation scope.
                // This is behavior was introduced after v0.22.0 and is incompatible
                // with histories generated with previous SDK versions and thus requires
                // patching.
                //
                // We try to delay patching as much as possible to avoid polluting
                // histories unless strictly required.
                const scope = cancellation_scope_1.CancellationScope.current();
                if (scope.cancellable) {
                    (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch((err) => {
                        if (patched(EXTERNAL_WF_CANCEL_PATCH)) {
                            reject(err);
                        }
                    }));
                }
                if (scope.consideredCancelled) {
                    if (patched(EXTERNAL_WF_CANCEL_PATCH)) {
                        return;
                    }
                }
                const seq = activator.nextSeqs.cancelWorkflow++;
                activator.pushCommand({
                    requestCancelExternalWorkflowExecution: {
                        seq,
                        workflowExecution: {
                            namespace: activator.info.namespace,
                            workflowId,
                            runId,
                        },
                    },
                });
                activator.completions.cancelWorkflow.set(seq, { resolve, reject });
            });
        },
        signal(def, ...args) {
            return (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'signalWorkflow', signalWorkflowNextHandler)({
                seq: activator.nextSeqs.signalWorkflow++,
                signalName: typeof def === 'string' ? def : def.name,
                args,
                target: {
                    type: 'external',
                    workflowExecution: { workflowId, runId },
                },
                headers: {},
            });
        },
    };
}
exports.getExternalWorkflowHandle = getExternalWorkflowHandle;
async function startChild(workflowTypeOrFunc, options) {
    const activator = assertInWorkflowContext('Workflow.startChild(...) may only be used from a Workflow Execution. Consider using Client.workflow.start(...) instead.)');
    const optionsWithDefaults = addDefaultWorkflowOptions(options ?? {});
    const workflowType = (0, common_1.extractWorkflowType)(workflowTypeOrFunc);
    const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'startChildWorkflowExecution', startChildWorkflowExecutionNextHandler);
    const [started, completed] = await execute({
        seq: activator.nextSeqs.childWorkflow++,
        options: optionsWithDefaults,
        headers: {},
        workflowType,
    });
    const firstExecutionRunId = await started;
    return {
        workflowId: optionsWithDefaults.workflowId,
        firstExecutionRunId,
        async result() {
            return (await completed);
        },
        async signal(def, ...args) {
            return (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'signalWorkflow', signalWorkflowNextHandler)({
                seq: activator.nextSeqs.signalWorkflow++,
                signalName: typeof def === 'string' ? def : def.name,
                args,
                target: {
                    type: 'child',
                    childWorkflowId: optionsWithDefaults.workflowId,
                },
                headers: {},
            });
        },
    };
}
exports.startChild = startChild;
async function executeChild(workflowTypeOrFunc, options) {
    const activator = assertInWorkflowContext('Workflow.executeChild(...) may only be used from a Workflow Execution. Consider using Client.workflow.execute(...) instead.');
    const optionsWithDefaults = addDefaultWorkflowOptions(options ?? {});
    const workflowType = (0, common_1.extractWorkflowType)(workflowTypeOrFunc);
    const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'startChildWorkflowExecution', startChildWorkflowExecutionNextHandler);
    const execPromise = execute({
        seq: activator.nextSeqs.childWorkflow++,
        options: optionsWithDefaults,
        headers: {},
        workflowType,
    });
    (0, stack_helpers_1.untrackPromise)(execPromise);
    const completedPromise = execPromise.then(([_started, completed]) => completed);
    (0, stack_helpers_1.untrackPromise)(completedPromise);
    return completedPromise;
}
exports.executeChild = executeChild;
/**
 * Get information about the current Workflow.
 *
 *  We recommend calling `workflowInfo()` whenever accessing {@link WorkflowInfo} fields. Some WorkflowInfo fields
 * change during the lifetime of an Executionlike {@link WorkflowInfo.historyLength} and
 * {@link WorkflowInfo.searchAttributes}and some may be changeable in the futurelike {@link WorkflowInfo.taskQueue}.
 *
 * ```ts
 * // GOOD
 * function myWorkflow() {
 *   doSomething(workflowInfo().searchAttributes)
 *   ...
 *   doSomethingElse(workflowInfo().searchAttributes)
 * }
 * ```
 *
 * ```ts
 * // BAD
 * function myWorkflow() {
 *   const attributes = workflowInfo().searchAttributes
 *   doSomething(attributes)
 *   ...
 *   doSomethingElse(attributes)
 * }
 */
function workflowInfo() {
    const activator = assertInWorkflowContext('Workflow.workflowInfo(...) may only be used from a Workflow Execution.');
    return activator.info;
}
exports.workflowInfo = workflowInfo;
/**
 * Returns whether or not code is executing in workflow context
 */
function inWorkflowContext() {
    return (0, internals_1.maybeGetActivator)() !== undefined;
}
exports.inWorkflowContext = inWorkflowContext;
/**
 * Get a reference to Sinks for exporting data out of the Workflow.
 *
 * These Sinks **must** be registered with the Worker in order for this
 * mechanism to work.
 *
 * @example
 * ```ts
 * import { proxySinks, Sinks } from '@temporalio/workflow';
 *
 * interface MySinks extends Sinks {
 *   logger: {
 *     info(message: string): void;
 *     error(message: string): void;
 *   };
 * }
 *
 * const { logger } = proxySinks<MyDependencies>();
 * logger.info('setting up');
 *
 * export function myWorkflow() {
 *   return {
 *     async execute() {
 *       logger.info("hey ho");
 *       logger.error("lets go");
 *     }
 *   };
 * }
 * ```
 */
function proxySinks() {
    return new Proxy({}, {
        get(_, ifaceName) {
            return new Proxy({}, {
                get(_, fnName) {
                    return (...args) => {
                        const activator = assertInWorkflowContext('Proxied sinks functions may only be used from a Workflow Execution.');
                        const info = workflowInfo();
                        activator.sinkCalls.push({
                            ifaceName: ifaceName,
                            fnName: fnName,
                            // Only available from node 17.
                            args: globalThis.structuredClone ? globalThis.structuredClone(args) : args,
                            // Clone the workflowInfo object so that any further mutations to it does not get reflected in sink
                            workflowInfo: {
                                ...info,
                                // Make sure to clone any sub-property that may get mutated during the lifespan of an activation
                                searchAttributes: { ...info.searchAttributes },
                                memo: info.memo ? { ...info.memo } : undefined,
                            },
                        });
                    };
                },
            });
        },
    });
}
exports.proxySinks = proxySinks;
/**
 * Returns a function `f` that will cause the current Workflow to ContinueAsNew when called.
 *
 * `f` takes the same arguments as the Workflow function supplied to typeparam `F`.
 *
 * Once `f` is called, Workflow Execution immediately completes.
 */
function makeContinueAsNewFunc(options) {
    const activator = assertInWorkflowContext('Workflow.continueAsNew(...) and Workflow.makeContinueAsNewFunc(...) may only be used from a Workflow Execution.');
    const info = activator.info;
    const { workflowType, taskQueue, ...rest } = options ?? {};
    const requiredOptions = {
        workflowType: workflowType ?? info.workflowType,
        taskQueue: taskQueue ?? info.taskQueue,
        ...rest,
    };
    return (...args) => {
        const fn = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'continueAsNew', async (input) => {
            const { headers, args, options } = input;
            throw new interfaces_1.ContinueAsNew({
                workflowType: options.workflowType,
                arguments: (0, common_1.toPayloads)(activator.payloadConverter, ...args),
                headers,
                taskQueue: options.taskQueue,
                memo: options.memo && (0, common_1.mapToPayloads)(activator.payloadConverter, options.memo),
                searchAttributes: options.searchAttributes
                    ? (0, common_1.mapToPayloads)(common_1.searchAttributePayloadConverter, options.searchAttributes)
                    : undefined,
                workflowRunTimeout: (0, time_1.msOptionalToTs)(options.workflowRunTimeout),
                workflowTaskTimeout: (0, time_1.msOptionalToTs)(options.workflowTaskTimeout),
                versioningIntent: (0, versioning_intent_enum_1.versioningIntentToProto)(options.versioningIntent),
            });
        });
        return fn({
            args,
            headers: {},
            options: requiredOptions,
        });
    };
}
exports.makeContinueAsNewFunc = makeContinueAsNewFunc;
/**
 * {@link https://docs.temporal.io/concepts/what-is-continue-as-new/ | Continues-As-New} the current Workflow Execution
 * with default options.
 *
 * Shorthand for `makeContinueAsNewFunc<F>()(...args)`. (See: {@link makeContinueAsNewFunc}.)
 *
 * @example
 *
 *```ts
 *import { continueAsNew } from '@temporalio/workflow';
 *
 *export async function myWorkflow(n: number): Promise<void> {
 *  // ... Workflow logic
 *  await continueAsNew<typeof myWorkflow>(n + 1);
 *}
 *```
 */
function continueAsNew(...args) {
    return makeContinueAsNewFunc()(...args);
}
exports.continueAsNew = continueAsNew;
/**
 * Generate an RFC compliant V4 uuid.
 * Uses the workflow's deterministic PRNG making it safe for use within a workflow.
 * This function is cryptographically insecure.
 * See the {@link https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid | stackoverflow discussion}.
 */
function uuid4() {
    // Return the hexadecimal text representation of number `n`, padded with zeroes to be of length `p`
    const ho = (n, p) => n.toString(16).padStart(p, '0');
    // Create a view backed by a 16-byte buffer
    const view = new DataView(new ArrayBuffer(16));
    // Fill buffer with random values
    view.setUint32(0, (Math.random() * 0x100000000) >>> 0);
    view.setUint32(4, (Math.random() * 0x100000000) >>> 0);
    view.setUint32(8, (Math.random() * 0x100000000) >>> 0);
    view.setUint32(12, (Math.random() * 0x100000000) >>> 0);
    // Patch the 6th byte to reflect a version 4 UUID
    view.setUint8(6, (view.getUint8(6) & 0xf) | 0x40);
    // Patch the 8th byte to reflect a variant 1 UUID (version 4 UUIDs are)
    view.setUint8(8, (view.getUint8(8) & 0x3f) | 0x80);
    // Compile the canonical textual form from the array data
    return `${ho(view.getUint32(0), 8)}-${ho(view.getUint16(4), 4)}-${ho(view.getUint16(6), 4)}-${ho(view.getUint16(8), 4)}-${ho(view.getUint32(10), 8)}${ho(view.getUint16(14), 4)}`;
}
exports.uuid4 = uuid4;
/**
 * Patch or upgrade workflow code by checking or stating that this workflow has a certain patch.
 *
 * See {@link https://docs.temporal.io/typescript/versioning | docs page} for info.
 *
 * If the workflow is replaying an existing history, then this function returns true if that
 * history was produced by a worker which also had a `patched` call with the same `patchId`.
 * If the history was produced by a worker *without* such a call, then it will return false.
 *
 * If the workflow is not currently replaying, then this call *always* returns true.
 *
 * Your workflow code should run the "new" code if this returns true, if it returns false, you
 * should run the "old" code. By doing this, you can maintain determinism.
 *
 * @param patchId An identifier that should be unique to this patch. It is OK to use multiple
 * calls with the same ID, which means all such calls will always return the same value.
 */
function patched(patchId) {
    return patchInternal(patchId, false);
}
exports.patched = patched;
/**
 * Indicate that a patch is being phased out.
 *
 * See {@link https://docs.temporal.io/typescript/versioning | docs page} for info.
 *
 * Workflows with this call may be deployed alongside workflows with a {@link patched} call, but
 * they must *not* be deployed while any workers still exist running old code without a
 * {@link patched} call, or any runs with histories produced by such workers exist. If either kind
 * of worker encounters a history produced by the other, their behavior is undefined.
 *
 * Once all live workflow runs have been produced by workers with this call, you can deploy workers
 * which are free of either kind of patch call for this ID. Workers with and without this call
 * may coexist, as long as they are both running the "new" code.
 *
 * @param patchId An identifier that should be unique to this patch. It is OK to use multiple
 * calls with the same ID, which means all such calls will always return the same value.
 */
function deprecatePatch(patchId) {
    patchInternal(patchId, true);
}
exports.deprecatePatch = deprecatePatch;
function patchInternal(patchId, deprecated) {
    const activator = assertInWorkflowContext('Workflow.patch(...) and Workflow.deprecatePatch may only be used from a Workflow Execution.');
    // Patch operation does not support interception at the moment, if it did,
    // this would be the place to start the interception chain
    if (activator.workflow === undefined) {
        throw new common_1.IllegalStateError('Patches cannot be used before Workflow starts');
    }
    const usePatch = !activator.info.unsafe.isReplaying || activator.knownPresentPatches.has(patchId);
    // Avoid sending commands for patches core already knows about.
    // This optimization enables development of automatic patching tools.
    if (usePatch && !activator.sentPatches.has(patchId)) {
        activator.pushCommand({
            setPatchMarker: { patchId, deprecated },
        });
        activator.sentPatches.add(patchId);
    }
    return usePatch;
}
async function condition(fn, timeout) {
    assertInWorkflowContext('Workflow.condition(...) may only be used from a Workflow Execution.');
    // Prior to 1.5.0, `condition(fn, 0)` was treated as equivalent to `condition(fn, undefined)`
    if (timeout === 0 && !patched(CONDITION_0_PATCH)) {
        return conditionInner(fn);
    }
    if (typeof timeout === 'number' || typeof timeout === 'string') {
        return cancellation_scope_1.CancellationScope.cancellable(async () => {
            try {
                return await Promise.race([sleep(timeout).then(() => false), conditionInner(fn).then(() => true)]);
            }
            finally {
                cancellation_scope_1.CancellationScope.current().cancel();
            }
        });
    }
    return conditionInner(fn);
}
exports.condition = condition;
function conditionInner(fn) {
    const activator = (0, internals_1.getActivator)();
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        const seq = activator.nextSeqs.condition++;
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch((err) => {
                activator.blockedConditions.delete(seq);
                reject(err);
            }));
        }
        // Eager evaluation
        if (fn()) {
            resolve();
            return;
        }
        activator.blockedConditions.set(seq, { fn, resolve });
    });
}
/**
 * Define a signal method for a Workflow.
 *
 * Definitions are used to register handler in the Workflow via {@link setHandler} and to signal Workflows using a {@link WorkflowHandle}, {@link ChildWorkflowHandle} or {@link ExternalWorkflowHandle}.
 * Definitions can be reused in multiple Workflows.
 */
function defineSignal(name) {
    return {
        type: 'signal',
        name,
    };
}
exports.defineSignal = defineSignal;
/**
 * Define a query method for a Workflow.
 *
 * Definitions are used to register handler in the Workflow via {@link setHandler} and to query Workflows using a {@link WorkflowHandle}.
 * Definitions can be reused in multiple Workflows.
 */
function defineQuery(name) {
    return {
        type: 'query',
        name,
    };
}
exports.defineQuery = defineQuery;
/**
 * Set a handler function for a Workflow query or signal.
 *
 * If this function is called multiple times for a given signal or query name the last handler will overwrite any previous calls.
 *
 * @param def a {@link SignalDefinition} or {@link QueryDefinition} as returned by {@link defineSignal} or {@link defineQuery} respectively.
 * @param handler a compatible handler function for the given definition or `undefined` to unset the handler.
 */
function setHandler(def, handler) {
    const activator = assertInWorkflowContext('Workflow.setHandler(...) may only be used from a Workflow Execution.');
    if (def.type === 'signal') {
        if (typeof handler === 'function') {
            activator.signalHandlers.set(def.name, handler);
            activator.dispatchBufferedSignals();
        }
        else if (handler == null) {
            activator.signalHandlers.delete(def.name);
        }
        else {
            throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
        }
    }
    else if (def.type === 'query') {
        if (typeof handler === 'function') {
            activator.queryHandlers.set(def.name, handler);
        }
        else if (handler == null) {
            activator.queryHandlers.delete(def.name);
        }
        else {
            throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
        }
    }
    else {
        throw new TypeError(`Invalid definition type: ${def.type}`);
    }
}
exports.setHandler = setHandler;
/**
 * Set a signal handler function that will handle signals calls for non-registered signal names.
 *
 * Signals are dispatched to the default signal handler in the order that they were accepted by the server.
 *
 * If this function is called multiple times for a given signal or query name the last handler will overwrite any previous calls.
 *
 * @param handler a function that will handle signals for non-registered signal names, or `undefined` to unset the handler.
 */
function setDefaultSignalHandler(handler) {
    const activator = assertInWorkflowContext('Workflow.setDefaultSignalHandler(...) may only be used from a Workflow Execution.');
    if (typeof handler === 'function') {
        activator.defaultSignalHandler = handler;
        activator.dispatchBufferedSignals();
    }
    else if (handler == null) {
        activator.defaultSignalHandler = undefined;
    }
    else {
        throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
    }
}
exports.setDefaultSignalHandler = setDefaultSignalHandler;
/**
 * Updates this Workflow's Search Attributes by merging the provided `searchAttributes` with the existing Search
 * Attributes, `workflowInfo().searchAttributes`.
 *
 * For example, this Workflow code:
 *
 * ```ts
 * upsertSearchAttributes({
 *   CustomIntField: [1],
 *   CustomBoolField: [true]
 * });
 * upsertSearchAttributes({
 *   CustomIntField: [42],
 *   CustomKeywordField: ['durable code', 'is great']
 * });
 * ```
 *
 * would result in the Workflow having these Search Attributes:
 *
 * ```ts
 * {
 *   CustomIntField: [42],
 *   CustomBoolField: [true],
 *   CustomKeywordField: ['durable code', 'is great']
 * }
 * ```
 *
 * @param searchAttributes The Record to merge. Use a value of `[]` to clear a Search Attribute.
 */
function upsertSearchAttributes(searchAttributes) {
    const activator = assertInWorkflowContext('Workflow.upsertSearchAttributes(...) may only be used from a Workflow Execution.');
    const mergedSearchAttributes = { ...activator.info.searchAttributes, ...searchAttributes };
    if (!mergedSearchAttributes) {
        throw new Error('searchAttributes must be a non-null SearchAttributes');
    }
    activator.pushCommand({
        upsertWorkflowSearchAttributes: {
            searchAttributes: (0, common_1.mapToPayloads)(common_1.searchAttributePayloadConverter, searchAttributes),
        },
    });
    activator.info.searchAttributes = mergedSearchAttributes;
}
exports.upsertSearchAttributes = upsertSearchAttributes;
exports.stackTraceQuery = defineQuery('__stack_trace');
exports.enhancedStackTraceQuery = defineQuery('__enhanced_stack_trace');
const loggerSinks = proxySinks();
/**
 * Symbol used by the SDK logger to extract a timestamp from log attributes.
 * Also defined in `worker/logger.ts` - intentionally not shared.
 */
const LogTimestamp = Symbol.for('log_timestamp');
/**
 * Default workflow logger.
 * This logger is replay-aware and will omit log messages on workflow replay.
 * The messages emitted by this logger are funnelled to the worker's `defaultSinks`, which are installed by default.
 *
 * Note that since sinks are used to power this logger, any log attributes must be transferable via the
 * {@link https://nodejs.org/api/worker_threads.html#worker_threads_port_postmessage_value_transferlist | postMessage}
 * API.
 *
 * `defaultSinks` accepts a user logger and defaults to the `Runtime`'s logger.
 *
 * See the documentation for `WorkerOptions`, `defaultSinks`, and `Runtime` for more information.
 */
exports.log = Object.fromEntries(['trace', 'debug', 'info', 'warn', 'error'].map((level) => {
    return [
        level,
        (message, attrs) => {
            const activator = assertInWorkflowContext('Workflow.log(...) may only be used from a Workflow Execution.');
            const getLogAttributes = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'getLogAttributes', (a) => a);
            return loggerSinks.defaultWorkerLogger[level](message, {
                // Inject the call time in nanosecond resolution as expected by the worker logger.
                [LogTimestamp]: activator.getTimeOfDay(),
                ...getLogAttributes({}),
                ...attrs,
            });
        },
    ];
}));
function assertInWorkflowContext(message) {
    const activator = (0, internals_1.maybeGetActivator)();
    if (activator == null)
        throw new common_1.IllegalStateError(message);
    return activator;
}


/***/ }),

/***/ "./src/worker/workflows.ts":
/*!*********************************!*\
  !*** ./src/worker/workflows.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gasPriceWorkflow: () => (/* binding */ gasPriceWorkflow)
/* harmony export */ });
/* harmony import */ var _temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @temporalio/workflow */ "./node_modules/@temporalio/workflow/lib/index.js");
/* harmony import */ var _temporalio_workflow__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__);

const { helloWorld, getGasPrice } = (0,_temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__.proxyActivities)({
    retry: {
        initialInterval: '50 milliseconds',
        maximumAttempts: 5
    },
    startToCloseTimeout: '1209600 seconds'
});
const gasPriceWorkflow = async (name)=>{
    const result = await getGasPrice();
    return result;
};


/***/ }),

/***/ "?31ff":
/*!*****************************************************!*\
  !*** __temporal_custom_failure_converter (ignored) ***!
  \*****************************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?2065":
/*!*****************************************************!*\
  !*** __temporal_custom_payload_converter (ignored) ***!
  \*****************************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/@temporalio/common/node_modules/ms/dist/index.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@temporalio/common/node_modules/ms/dist/index.cjs ***!
  \************************************************************************/
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Helpers.
const s = 1000;
const m = s * 60;
const h = m * 60;
const d = h * 24;
const w = d * 7;
const y = d * 365.25;
function ms(value, options) {
    try {
        if (typeof value === 'string' && value.length > 0) {
            return parse(value);
        }
        else if (typeof value === 'number' && isFinite(value)) {
            return options?.long ? fmtLong(value) : fmtShort(value);
        }
        throw new Error('Value is not a string or number.');
    }
    catch (error) {
        const message = isError(error)
            ? `${error.message}. value=${JSON.stringify(value)}`
            : 'An unknown error has occured.';
        throw new Error(message);
    }
}
/**
 * Parse the given `str` and return milliseconds.
 */
function parse(str) {
    str = String(str);
    if (str.length > 100) {
        throw new Error('Value exceeds the maximum length of 100 characters.');
    }
    const match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return NaN;
    }
    const n = parseFloat(match[1]);
    const type = (match[2] || 'ms').toLowerCase();
    switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            // This should never occur.
            throw new Error(`The unit ${type} was matched, but no matching case exists.`);
    }
}
exports["default"] = ms;
/**
 * Short format for `ms`.
 */
function fmtShort(ms) {
    const msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return `${Math.round(ms / d)}d`;
    }
    if (msAbs >= h) {
        return `${Math.round(ms / h)}h`;
    }
    if (msAbs >= m) {
        return `${Math.round(ms / m)}m`;
    }
    if (msAbs >= s) {
        return `${Math.round(ms / s)}s`;
    }
    return `${ms}ms`;
}
/**
 * Long format for `ms`.
 */
function fmtLong(ms) {
    const msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return `${ms} ms`;
}
/**
 * Pluralization helper.
 */
function plural(ms, msAbs, n, name) {
    const isPlural = msAbs >= n * 1.5;
    return `${Math.round(ms / n)} ${name}${isPlural ? 's' : ''}`;
}
/**
 * A type guard for errors.
 */
function isError(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
module.exports = exports.default;
module.exports["default"] = exports.default;


/***/ }),

/***/ "./node_modules/long/umd/index.js":
/*!****************************************!*\
  !*** ./node_modules/long/umd/index.js ***!
  \****************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// GENERATED FILE. DO NOT EDIT.
var Long = (function(exports) {
  "use strict";
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  
  /**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  // WebAssembly optimizations to do native i64 multiplication and divide
  var wasm = null;
  
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch (e) {// no wasm support :(
  }
  /**
   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
   *  See the from* functions below for more convenient ways of constructing Longs.
   * @exports Long
   * @class A Long class for representing a 64 bit two's-complement integer value.
   * @param {number} low The low (signed) 32 bits of the long
   * @param {number} high The high (signed) 32 bits of the long
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @constructor
   */
  
  
  function Long(low, high, unsigned) {
    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;
    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
  
    this.high = high | 0;
    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
  
    this.unsigned = !!unsigned;
  } // The internal representation of a long is the two given signed, 32-bit values.
  // We use 32-bit pieces because these are the size of integers on which
  // Javascript performs bit-operations.  For operations like addition and
  // multiplication, we split each number into 16 bit pieces, which can easily be
  // multiplied within Javascript's floating-point representation without overflow
  // or change in sign.
  //
  // In the algorithms below, we frequently reduce the negative case to the
  // positive case by negating the input(s) and then post-processing the result.
  // Note that we must ALWAYS check specially whether those values are MIN_VALUE
  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
  // a positive number, it overflows back into a negative).  Not handling this
  // case would often result in infinite recursion.
  //
  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
  // methods on which they depend.
  
  /**
   * An indicator used to reliably determine if an object is a Long or not.
   * @type {boolean}
   * @const
   * @private
   */
  
  
  Long.prototype.__isLong__;
  Object.defineProperty(Long.prototype, "__isLong__", {
    value: true
  });
  /**
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   * @inner
   */
  
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  /**
   * @function
   * @param {*} value number
   * @returns {number}
   * @inner
   */
  
  
  function ctz32(value) {
    var c = Math.clz32(value & -value);
    return value ? 31 - c : c;
  }
  /**
   * Tests if the specified object is a Long.
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   */
  
  
  Long.isLong = isLong;
  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @inner
   */
  
  var INT_CACHE = {};
  /**
   * A cache of the Long representations of small unsigned integer values.
   * @type {!Object}
   * @inner
   */
  
  var UINT_CACHE = {};
  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
  
    if (unsigned) {
      value >>>= 0;
  
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj) return cachedObj;
      }
  
      obj = fromBits(value, 0, true);
      if (cache) UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
  
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj) return cachedObj;
      }
  
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache) INT_CACHE[value] = obj;
      return obj;
    }
  }
  /**
   * Returns a Long representing the given 32 bit integer value.
   * @function
   * @param {number} value The 32 bit integer in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  
  
  Long.fromInt = fromInt;
  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  
  function fromNumber(value, unsigned) {
    if (isNaN(value)) return unsigned ? UZERO : ZERO;
  
    if (unsigned) {
      if (value < 0) return UZERO;
      if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
    }
  
    if (value < 0) return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  /**
   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
   * @function
   * @param {number} value The number in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  
  
  Long.fromNumber = fromNumber;
  /**
   * @param {number} lowBits
   * @param {number} highBits
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }
  /**
   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
   *  assumed to use 32 bits.
   * @function
   * @param {number} lowBits The low 32 bits
   * @param {number} highBits The high 32 bits
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  
  
  Long.fromBits = fromBits;
  /**
   * @function
   * @param {number} base
   * @param {number} exponent
   * @returns {number}
   * @inner
   */
  
  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)
  
  /**
   * @param {string} str
   * @param {(boolean|number)=} unsigned
   * @param {number=} radix
   * @returns {!Long}
   * @inner
   */
  
  function fromString(str, unsigned, radix) {
    if (str.length === 0) throw Error('empty string');
  
    if (typeof unsigned === 'number') {
      // For goog.math.long compatibility
      radix = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
  
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError('radix');
    var p;
    if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    } // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
  
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
  
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i),
          value = parseInt(str.substring(i, i + size), radix);
  
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
  
    result.unsigned = unsigned;
    return result;
  }
  /**
   * Returns a Long representation of the given string, written using the specified radix.
   * @function
   * @param {string} str The textual representation of the Long
   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
   * @returns {!Long} The corresponding Long value
   */
  
  
  Long.fromString = fromString;
  /**
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  
  function fromValue(val, unsigned) {
    if (typeof val === 'number') return fromNumber(val, unsigned);
    if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:
  
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
  }
  /**
   * Converts the specified value to a Long using the appropriate from* function for its type.
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long}
   */
  
  
  Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
  // no runtime penalty for these.
  
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_16_DBL = 1 << 16;
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_24_DBL = 1 << 24;
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  /**
   * @type {number}
   * @const
   * @inner
   */
  
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  /**
   * @type {!Long}
   * @const
   * @inner
   */
  
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  /**
   * @type {!Long}
   * @inner
   */
  
  var ZERO = fromInt(0);
  /**
   * Signed zero.
   * @type {!Long}
   */
  
  Long.ZERO = ZERO;
  /**
   * @type {!Long}
   * @inner
   */
  
  var UZERO = fromInt(0, true);
  /**
   * Unsigned zero.
   * @type {!Long}
   */
  
  Long.UZERO = UZERO;
  /**
   * @type {!Long}
   * @inner
   */
  
  var ONE = fromInt(1);
  /**
   * Signed one.
   * @type {!Long}
   */
  
  Long.ONE = ONE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var UONE = fromInt(1, true);
  /**
   * Unsigned one.
   * @type {!Long}
   */
  
  Long.UONE = UONE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var NEG_ONE = fromInt(-1);
  /**
   * Signed negative one.
   * @type {!Long}
   */
  
  Long.NEG_ONE = NEG_ONE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
  /**
   * Maximum signed value.
   * @type {!Long}
   */
  
  Long.MAX_VALUE = MAX_VALUE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
  /**
   * Maximum unsigned value.
   * @type {!Long}
   */
  
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  /**
   * @type {!Long}
   * @inner
   */
  
  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);
  /**
   * Minimum signed value.
   * @type {!Long}
   */
  
  Long.MIN_VALUE = MIN_VALUE;
  /**
   * @alias Long.prototype
   * @inner
   */
  
  var LongPrototype = Long.prototype;
  /**
   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
   * @this {!Long}
   * @returns {number}
   */
  
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  /**
   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
   * @this {!Long}
   * @returns {number}
   */
  
  
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  /**
   * Converts the Long to a string written in the specified radix.
   * @this {!Long}
   * @param {number=} radix Radix (2-36), defaults to 10
   * @returns {string}
   * @override
   * @throws {RangeError} If `radix` is out of range
   */
  
  
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError('radix');
    if (this.isZero()) return '0';
  
    if (this.isNegative()) {
      // Unsigned Longs are never negative
      if (this.eq(MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = fromNumber(radix),
            div = this.div(radixLong),
            rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else return '-' + this.neg().toString(radix);
    } // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
  
  
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
  
    while (true) {
      var remDiv = rem.div(radixToPower),
          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
          digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero()) return digits + result;else {
        while (digits.length < 6) digits = '0' + digits;
  
        result = '' + digits + result;
      }
    }
  };
  /**
   * Gets the high 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed high bits
   */
  
  
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  /**
   * Gets the high 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned high bits
   */
  
  
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  /**
   * Gets the low 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed low bits
   */
  
  
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  /**
   * Gets the low 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned low bits
   */
  
  
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  /**
   * Gets the number of bits needed to represent the absolute value of this Long.
   * @this {!Long}
   * @returns {number}
   */
  
  
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
  
    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
  
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  /**
   * Tests if this Long's value equals zero.
   * @this {!Long}
   * @returns {boolean}
   */
  
  
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  /**
   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
   * @returns {boolean}
   */
  
  
  LongPrototype.eqz = LongPrototype.isZero;
  /**
   * Tests if this Long's value is negative.
   * @this {!Long}
   * @returns {boolean}
   */
  
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  /**
   * Tests if this Long's value is positive or zero.
   * @this {!Long}
   * @returns {boolean}
   */
  
  
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  /**
   * Tests if this Long's value is odd.
   * @this {!Long}
   * @returns {boolean}
   */
  
  
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  /**
   * Tests if this Long's value is even.
   * @this {!Long}
   * @returns {boolean}
   */
  
  
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  /**
   * Tests if this Long's value equals the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.equals = function equals(other) {
    if (!isLong(other)) other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
    return this.high === other.high && this.low === other.low;
  };
  /**
   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.eq = LongPrototype.equals;
  /**
   * Tests if this Long's value differs from the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(
    /* validates */
    other);
  };
  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.neq = LongPrototype.notEquals;
  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.ne = LongPrototype.notEquals;
  /**
   * Tests if this Long's value is less than the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(
    /* validates */
    other) < 0;
  };
  /**
   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.lt = LongPrototype.lessThan;
  /**
   * Tests if this Long's value is less than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(
    /* validates */
    other) <= 0;
  };
  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  /**
   * Tests if this Long's value is greater than the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(
    /* validates */
    other) > 0;
  };
  /**
   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.gt = LongPrototype.greaterThan;
  /**
   * Tests if this Long's value is greater than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(
    /* validates */
    other) >= 0;
  };
  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  /**
   * Compares this Long's value with the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  
  LongPrototype.compare = function compare(other) {
    if (!isLong(other)) other = fromValue(other);
    if (this.eq(other)) return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) return -1;
    if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same
  
    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned
  
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  /**
   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  
  
  LongPrototype.comp = LongPrototype.compare;
  /**
   * Negates this Long's value.
   * @this {!Long}
   * @returns {!Long} Negated Long
   */
  
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
    return this.not().add(ONE);
  };
  /**
   * Negates this Long's value. This is an alias of {@link Long#negate}.
   * @function
   * @returns {!Long} Negated Long
   */
  
  
  LongPrototype.neg = LongPrototype.negate;
  /**
   * Returns the sum of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} addend Addend
   * @returns {!Long} Sum
   */
  
  LongPrototype.add = function add(addend) {
    if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
  
    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;
    var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  /**
   * Returns the difference of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  
  
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  /**
   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
   * @function
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  
  
  LongPrototype.sub = LongPrototype.subtract;
  /**
   * Returns the product of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero()) return this;
    if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present
  
    if (wasm) {
      var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
  
    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
  
    if (this.isNegative()) {
      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication
  
  
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.
  
    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;
    var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  /**
   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
   * @function
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  
  
  LongPrototype.mul = LongPrototype.multiply;
  /**
   * Returns this Long divided by the specified. The result is signed if this Long is signed or
   *  unsigned if this Long is unsigned.
   * @this {!Long}
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor)) divisor = fromValue(divisor);
    if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present
  
    if (wasm) {
      // guard against signed division overflow: the largest
      // negative number / -1 would be 1 larger than the largest
      // positive number, due to two's complement.
      if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {
        // be consistent with non-wasm code path
        return this;
      }
  
      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
  
    if (this.isZero()) return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
  
    if (!this.unsigned) {
      // This section is only relevant for signed longs and is derived from the
      // closure library as a whole.
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
        else if (divisor.eq(MIN_VALUE)) return ONE;else {
          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
  
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
  
      if (this.isNegative()) {
        if (divisor.isNegative()) return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
  
      res = ZERO;
    } else {
      // The algorithm below has not been made for unsigned longs. It's therefore
      // required to take special care of the MSB prior to running it.
      if (!divisor.unsigned) divisor = divisor.toUnsigned();
      if (divisor.gt(this)) return UZERO;
      if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
        return UONE;
      res = UZERO;
    } // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
  
  
    rem = this;
  
    while (rem.gte(divisor)) {
      // Approximate the result of division. This may be a little greater or
      // smaller than the actual value.
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
      // the smallest non-fractional digit, whichever is larger.
  
      var log2 = Math.ceil(Math.log(approx) / Math.LN2),
          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
          // Decrease the approximation until it is smaller than the remainder.  Note
      // that if it is too large, the product overflows and is negative.
      approxRes = fromNumber(approx),
          approxRem = approxRes.mul(divisor);
  
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      } // We know the answer can't be zero... and actually, zero would cause
      // infinite recursion since we would make no progress.
  
  
      if (approxRes.isZero()) approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
  
    return res;
  };
  /**
   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  
  
  LongPrototype.div = LongPrototype.divide;
  /**
   * Returns this Long modulo the specified.
   * @this {!Long}
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present
  
    if (wasm) {
      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
  
    return this.sub(this.div(divisor).mul(divisor));
  };
  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  
  
  LongPrototype.mod = LongPrototype.modulo;
  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  
  LongPrototype.rem = LongPrototype.modulo;
  /**
   * Returns the bitwise NOT of this Long.
   * @this {!Long}
   * @returns {!Long}
   */
  
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  /**
   * Returns count leading zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */
  
  
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };
  /**
   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */
  
  
  LongPrototype.clz = LongPrototype.countLeadingZeros;
  /**
   * Returns count trailing zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */
  
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };
  /**
   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */
  
  
  LongPrototype.ctz = LongPrototype.countTrailingZeros;
  /**
   * Returns the bitwise AND of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  
  LongPrototype.and = function and(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  /**
   * Returns the bitwise OR of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  
  
  LongPrototype.or = function or(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  /**
   * Returns the bitwise XOR of this Long and the given one.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  
  
  LongPrototype.xor = function xor(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  /**
   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  
  LongPrototype.shl = LongPrototype.shiftLeft;
  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  
  LongPrototype.shr = LongPrototype.shiftRight;
  /**
   * Returns this Long with bits logically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
  };
  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  /**
   * Returns this Long with bits rotated to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  
  LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
    }
  
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
  };
  /**
   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  
  
  LongPrototype.rotl = LongPrototype.rotateLeft;
  /**
   * Returns this Long with bits rotated to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  
  LongPrototype.rotateRight = function rotateRight(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
    }
  
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
  };
  /**
   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
  
  
  LongPrototype.rotr = LongPrototype.rotateRight;
  /**
   * Converts this Long to signed.
   * @this {!Long}
   * @returns {!Long} Signed long
   */
  
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned) return this;
    return fromBits(this.low, this.high, false);
  };
  /**
   * Converts this Long to unsigned.
   * @this {!Long}
   * @returns {!Long} Unsigned long
   */
  
  
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned) return this;
    return fromBits(this.low, this.high, true);
  };
  /**
   * Converts this Long to its byte representation.
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @this {!Long}
   * @returns {!Array.<number>} Byte representation
   */
  
  
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  /**
   * Converts this Long to its little endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Little endian byte representation
   */
  
  
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
  };
  /**
   * Converts this Long to its big endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Big endian byte representation
   */
  
  
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
  };
  /**
   * Creates a Long from its byte representation.
   * @param {!Array.<number>} bytes Byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @returns {Long} The corresponding Long value
   */
  
  
  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
  };
  /**
   * Creates a Long from its little endian byte representation.
   * @param {!Array.<number>} bytes Little endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
  
  
  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
  };
  /**
   * Creates a Long from its big endian byte representation.
   * @param {!Array.<number>} bytes Big endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
  
  
  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
  };
  
  var _default = Long;
  exports.default = _default;
  return "default" in exports ? exports.default : exports;
})({});
if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return Long; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
else {}


/***/ }),

/***/ "./node_modules/@temporalio/workflow/package.json":
/*!********************************************************!*\
  !*** ./node_modules/@temporalio/workflow/package.json ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@temporalio/workflow","version":"1.8.6","description":"Temporal.io SDK Workflow sub-package","keywords":["temporal","workflow","isolate"],"bugs":{"url":"https://github.com/temporalio/sdk-typescript/issues"},"repository":{"type":"git","url":"git+https://github.com/temporalio/sdk-typescript.git","directory":"packages/workflow"},"homepage":"https://github.com/temporalio/sdk-typescript/tree/main/packages/workflow","license":"MIT","author":"Temporal Technologies Inc. <sdk@temporal.io>","main":"lib/index.js","types":"lib/index.d.ts","scripts":{},"dependencies":{"@temporalio/common":"1.8.6","@temporalio/proto":"1.8.6"},"devDependencies":{"source-map":"^0.7.4"},"publishConfig":{"access":"public"},"files":["src","lib"],"gitHead":"1e95cf92ec5e6efffb7aedb064ea46be05df0c14"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = globalThis.__webpack_module_cache__;
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;
/*!***********************************************************!*\
  !*** ./src/worker/workflows-autogenerated-entrypoint.cjs ***!
  \***********************************************************/

const api = __webpack_require__(/*! @temporalio/workflow/lib/worker-interface.js */ "./node_modules/@temporalio/workflow/lib/worker-interface.js");

api.overrideGlobals();

exports.api = api;

exports.importWorkflows = function importWorkflows() {
  return __webpack_require__(/* webpackMode: "eager" */ /*! ./src/worker/workflows.ts */ "./src/worker/workflows.ts");
}

exports.importInterceptors = function importInterceptors() {
  return [
    __webpack_require__(/* webpackMode: "eager" */ /*! ./node_modules/@temporalio/worker/lib/workflow-log-interceptor.js */ "./node_modules/@temporalio/worker/lib/workflow-log-interceptor.js")
  ];
}

})();

__TEMPORAL__ = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2Zsb3ctYnVuZGxlLTA2NjEyOGE5ZDc5MWI3NDAyOGQwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBRUEsMEhBQThDO0FBSTlDLDBFQUEwRTtBQUMxRSxpRUFBaUU7QUFDakUsSUFBWSx3QkFJWDtBQUpELFdBQVksd0JBQXdCO0lBQ2xDLG1GQUFjO0lBQ2QscUhBQStCO0lBQy9CLDZFQUFXO0FBQ2IsQ0FBQyxFQUpXLHdCQUF3QixHQUF4QixnQ0FBd0IsS0FBeEIsZ0NBQXdCLFFBSW5DO0FBRUQsK0JBQVksR0FBZ0YsQ0FBQztBQUM3RiwrQkFBWSxHQUFnRixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUNmN0YsbUpBQWdGO0FBRWhGLG1KQUFnRjtBQTREaEY7Ozs7R0FJRztBQUNVLCtCQUF1QixHQUFxQixJQUFJLDJDQUF1QixFQUFFLENBQUM7QUFFdkY7O0dBRUc7QUFDVSw0QkFBb0IsR0FBd0I7SUFDdkQsZ0JBQWdCLEVBQUUsMkNBQXVCO0lBQ3pDLGdCQUFnQixFQUFFLCtCQUF1QjtJQUN6QyxhQUFhLEVBQUUsRUFBRTtDQUNsQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUM1RUYsNEdBYW9CO0FBQ3BCLDJIQUEwQztBQUMxQyxtSkFBMkc7QUFFM0c7O0dBRUc7QUFDSCxNQUFNLHFCQUFxQixHQUFHO0lBQzVCLHlCQUF5QjtJQUN6Qix1RkFBdUY7SUFDdkYsMEJBQTBCO0lBQzFCLGtHQUFrRztJQUNsRyx1Q0FBdUM7SUFDdkMsMkRBQTJEO0NBQzVELENBQUM7QUFFRjs7R0FFRztBQUNILFNBQWdCLGdCQUFnQixDQUFDLEtBQWM7SUFDN0MsTUFBTSxLQUFLLEdBQUcsQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNDLE1BQU0sR0FBRyxHQUFHLEtBQUssRUFBVSxDQUFDO0lBQzVCLFFBQVEsRUFBRSxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtRQUNsQyxLQUFLLE1BQU0sT0FBTyxJQUFJ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QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FB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dUJBQXVCO0FBQ3ZCLFNBQVMsbUJBQU8sNEJBQTRCLDREQUFvRjtBQUNoSTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQSxJQUFJLG1CQUFPLDRCQUE0Qiw0SUFBNEg7QUFDbks7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9hY3Rpdml0eS1vcHRpb25zLnRzIiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9jb252ZXJ0ZXIvZGF0YS1jb252ZXJ0ZXIudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2NvbnZlcnRlci9mYWlsdXJlLWNvbnZlcnRlci50cyIsIi9Vc2Vycy94cC9Eb2N1bWVudHMvYWlycG9ydC9kZW1vcy9ldGhlcnMtZGVtb3MvZXRoZXJzLWRlbW8vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvY29udmVydGVyL3BheWxvYWQtY29kZWMudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2NvbnZlcnRlci9wYXlsb2FkLWNvbnZlcnRlci50cyIsIi9Vc2Vycy94cC9Eb2N1bWVudHMvYWlycG9ydC9kZW1vcy9ldGhlcnMtZGVtb3MvZXRoZXJzLWRlbW8vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvY29udmVydGVyL3R5cGVzLnRzIiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9kZXByZWNhdGVkLXRpbWUudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2VuY29kaW5nLnRzIiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9lcnJvcnMudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2ZhaWx1cmUudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2luZGV4LnRzIiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9pbnRlcmNlcHRvcnMudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2ludGVyZmFjZXMudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2xvZ2dlci50cyIsIi9Vc2Vycy94cC9Eb2N1bWVudHMvYWlycG9ydC9kZW1vcy9ldGhlcnMtZGVtb3MvZXRoZXJzLWRlbW8vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvcmV0cnktcG9saWN5LnRzIiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy90aW1lLnRzIiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy90eXBlLWhlbHBlcnMudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3ZlcnNpb25pbmctaW50ZW50LWVudW0udHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3ZlcnNpb25pbmctaW50ZW50LnRzIiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy93b3JrZmxvdy1oYW5kbGUudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3dvcmtmbG93LW9wdGlvbnMudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZXIvc3JjL3dvcmtmbG93LWxvZy1pbnRlcmNlcHRvci50cyIsIi9Vc2Vycy94cC9Eb2N1bWVudHMvYWlycG9ydC9kZW1vcy9ldGhlcnMtZGVtb3MvZXRoZXJzLWRlbW8vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9hbGVhLnRzIiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvc3JjL2NhbmNlbGxhdGlvbi1zY29wZS50cyIsIi9Vc2Vycy94cC9Eb2N1bWVudHMvYWlycG9ydC9kZW1vcy9ldGhlcnMtZGVtb3MvZXRoZXJzLWRlbW8vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9lcnJvcnMudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvZ2xvYmFsLWF0dHJpYnV0ZXMudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvaW5kZXgudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvaW50ZXJjZXB0b3JzLnRzIiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvc3JjL2ludGVyZmFjZXMudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvaW50ZXJuYWxzLnRzIiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvc3JjL3BrZy50cyIsIi9Vc2Vycy94cC9Eb2N1bWVudHMvYWlycG9ydC9kZW1vcy9ldGhlcnMtZGVtb3MvZXRoZXJzLWRlbW8vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9zdGFjay1oZWxwZXJzLnRzIiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvc3JjL3RyaWdnZXIudHMiLCIvVXNlcnMveHAvRG9jdW1lbnRzL2FpcnBvcnQvZGVtb3MvZXRoZXJzLWRlbW9zL2V0aGVycy1kZW1vL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvd29ya2VyLWludGVyZmFjZS50cyIsIi9Vc2Vycy94cC9Eb2N1bWVudHMvYWlycG9ydC9kZW1vcy9ldGhlcnMtZGVtb3MvZXRoZXJzLWRlbW8vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy93b3JrZmxvdy50cyIsIi9Vc2Vycy94cC9Eb2N1bWVudHMvYWlycG9ydC9kZW1vcy9ldGhlcnMtZGVtb3MvZXRoZXJzLWRlbW8vc3JjL3dvcmtlci93b3JrZmxvd3MudHMiLCJpZ25vcmVkfC9Vc2Vycy94cC9Eb2N1bWVudHMvYWlycG9ydC9kZW1vcy9ldGhlcnMtZGVtb3MvZXRoZXJzLWRlbW8vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L2xpYnxfX3RlbXBvcmFsX2N1c3RvbV9mYWlsdXJlX2NvbnZlcnRlciIsImlnbm9yZWR8L1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGlifF9fdGVtcG9yYWxfY3VzdG9tX3BheWxvYWRfY29udmVydGVyIiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL25vZGVfbW9kdWxlcy9tcy9kaXN0L2luZGV4LmNqcyIsIi9Vc2Vycy94cC9Eb2N1bWVudHMvYWlycG9ydC9kZW1vcy9ldGhlcnMtZGVtb3MvZXRoZXJzLWRlbW8vbm9kZV9tb2R1bGVzL2xvbmcvdW1kL2luZGV4LmpzIiwid2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0IiwiL1VzZXJzL3hwL0RvY3VtZW50cy9haXJwb3J0L2RlbW9zL2V0aGVycy1kZW1vcy9ldGhlcnMtZGVtby9zcmMvd29ya2VyL3dvcmtmbG93cy1hdXRvZ2VuZXJhdGVkLWVudHJ5cG9pbnQuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgY29yZXNkayB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcbmltcG9ydCB7IFJldHJ5UG9saWN5IH0gZnJvbSAnLi9yZXRyeS1wb2xpY3knO1xuaW1wb3J0IHsgY2hlY2tFeHRlbmRzIH0gZnJvbSAnLi90eXBlLWhlbHBlcnMnO1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuL3RpbWUnO1xuaW1wb3J0IHsgVmVyc2lvbmluZ0ludGVudCB9IGZyb20gJy4vdmVyc2lvbmluZy1pbnRlbnQnO1xuXG4vLyBBdm9pZCBpbXBvcnRpbmcgdGhlIHByb3RvIGltcGxlbWVudGF0aW9uIHRvIHJlZHVjZSB3b3JrZmxvdyBidW5kbGUgc2l6ZVxuLy8gQ29waWVkIGZyb20gY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5BY3Rpdml0eUNhbmNlbGxhdGlvblR5cGVcbmV4cG9ydCBlbnVtIEFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZSB7XG4gIFRSWV9DQU5DRUwgPSAwLFxuICBXQUlUX0NBTkNFTExBVElPTl9DT01QTEVURUQgPSAxLFxuICBBQkFORE9OID0gMixcbn1cblxuY2hlY2tFeHRlbmRzPGNvcmVzZGsud29ya2Zsb3dfY29tbWFuZHMuQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlLCBBY3Rpdml0eUNhbmNlbGxhdGlvblR5cGU+KCk7XG5jaGVja0V4dGVuZHM8QWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlLCBjb3Jlc2RrLndvcmtmbG93X2NvbW1hbmRzLkFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZT4oKTtcblxuLyoqXG4gKiBPcHRpb25zIGZvciByZW1vdGUgYWN0aXZpdHkgaW52b2NhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGl2aXR5T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIHRvIHVzZSBmb3IgdHJhY2tpbmcgdGhlIGFjdGl2aXR5IGluIFdvcmtmbG93IGhpc3RvcnkuXG4gICAqIFRoZSBgYWN0aXZpdHlJZGAgY2FuIGJlIGFjY2Vzc2VkIGJ5IHRoZSBhY3Rpdml0eSBmdW5jdGlvbi5cbiAgICogRG9lcyBub3QgbmVlZCB0byBiZSB1bmlxdWUuXG4gICAqXG4gICAqIEBkZWZhdWx0IGFuIGluY3JlbWVudGFsIHNlcXVlbmNlIG51bWJlclxuICAgKi9cbiAgYWN0aXZpdHlJZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGFzayBxdWV1ZSBuYW1lLlxuICAgKlxuICAgKiBAZGVmYXVsdCBjdXJyZW50IHdvcmtlciB0YXNrIHF1ZXVlXG4gICAqL1xuICB0YXNrUXVldWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEhlYXJ0YmVhdCBpbnRlcnZhbC4gQWN0aXZpdHkgbXVzdCBoZWFydGJlYXQgYmVmb3JlIHRoaXMgaW50ZXJ2YWwgcGFzc2VzIGFmdGVyIGEgbGFzdCBoZWFydGJlYXQgb3IgYWN0aXZpdHkgc3RhcnQuXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgaGVhcnRiZWF0VGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBSZXRyeVBvbGljeSB0aGF0IGRlZmluZSBob3cgYWN0aXZpdHkgaXMgcmV0cmllZCBpbiBjYXNlIG9mIGZhaWx1cmUuIElmIHRoaXMgaXMgbm90IHNldCwgdGhlbiB0aGUgc2VydmVyLWRlZmluZWQgZGVmYXVsdCBhY3Rpdml0eSByZXRyeSBwb2xpY3kgd2lsbCBiZSB1c2VkLiBUbyBlbnN1cmUgemVybyByZXRyaWVzLCBzZXQgbWF4aW11bSBhdHRlbXB0cyB0byAxLlxuICAgKi9cbiAgcmV0cnk/OiBSZXRyeVBvbGljeTtcblxuICAvKipcbiAgICogTWF4aW11bSB0aW1lIG9mIGEgc2luZ2xlIEFjdGl2aXR5IGV4ZWN1dGlvbiBhdHRlbXB0LiBOb3RlIHRoYXQgdGhlIFRlbXBvcmFsIFNlcnZlciBkb2Vzbid0IGRldGVjdCBXb3JrZXIgcHJvY2Vzc1xuICAgKiBmYWlsdXJlcyBkaXJlY3RseS4gSXQgcmVsaWVzIG9uIHRoaXMgdGltZW91dCB0byBkZXRlY3QgdGhhdCBhbiBBY3Rpdml0eSB0aGF0IGRpZG4ndCBjb21wbGV0ZSBvbiB0aW1lLiBTbyB0aGlzXG4gICAqIHRpbWVvdXQgc2hvdWxkIGJlIGFzIHNob3J0IGFzIHRoZSBsb25nZXN0IHBvc3NpYmxlIGV4ZWN1dGlvbiBvZiB0aGUgQWN0aXZpdHkgYm9keS4gUG90ZW50aWFsbHkgbG9uZyBydW5uaW5nXG4gICAqIEFjdGl2aXRpZXMgbXVzdCBzcGVjaWZ5IHtAbGluayBoZWFydGJlYXRUaW1lb3V0fSBhbmQgY2FsbCB7QGxpbmsgYWN0aXZpdHkuQ29udGV4dC5oZWFydGJlYXR9IHBlcmlvZGljYWxseSBmb3JcbiAgICogdGltZWx5IGZhaWx1cmUgZGV0ZWN0aW9uLlxuICAgKlxuICAgKiBFaXRoZXIgdGhpcyBvcHRpb24gb3Ige0BsaW5rIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXR9IGlzIHJlcXVpcmVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgc2NoZWR1bGVUb0Nsb3NlVGltZW91dGAgb3IgdW5saW1pdGVkXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgc3RhcnRUb0Nsb3NlVGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBUaW1lIHRoYXQgdGhlIEFjdGl2aXR5IFRhc2sgY2FuIHN0YXkgaW4gdGhlIFRhc2sgUXVldWUgYmVmb3JlIGl0IGlzIHBpY2tlZCB1cCBieSBhIFdvcmtlci4gRG8gbm90IHNwZWNpZnkgdGhpcyB0aW1lb3V0IHVubGVzcyB1c2luZyBob3N0IHNwZWNpZmljIFRhc2sgUXVldWVzIGZvciBBY3Rpdml0eSBUYXNrcyBhcmUgYmVpbmcgdXNlZCBmb3Igcm91dGluZy5cbiAgICogYHNjaGVkdWxlVG9TdGFydFRpbWVvdXRgIGlzIGFsd2F5cyBub24tcmV0cnlhYmxlLiBSZXRyeWluZyBhZnRlciB0aGlzIHRpbWVvdXQgZG9lc24ndCBtYWtlIHNlbnNlIGFzIGl0IHdvdWxkIGp1c3QgcHV0IHRoZSBBY3Rpdml0eSBUYXNrIGJhY2sgaW50byB0aGUgc2FtZSBUYXNrIFF1ZXVlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgc2NoZWR1bGVUb0Nsb3NlVGltZW91dGAgb3IgdW5saW1pdGVkXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgc2NoZWR1bGVUb1N0YXJ0VGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBUb3RhbCB0aW1lIHRoYXQgYSB3b3JrZmxvdyBpcyB3aWxsaW5nIHRvIHdhaXQgZm9yIEFjdGl2aXR5IHRvIGNvbXBsZXRlLlxuICAgKiBgc2NoZWR1bGVUb0Nsb3NlVGltZW91dGAgbGltaXRzIHRoZSB0b3RhbCB0aW1lIG9mIGFuIEFjdGl2aXR5J3MgZXhlY3V0aW9uIGluY2x1ZGluZyByZXRyaWVzICh1c2Uge0BsaW5rIHN0YXJ0VG9DbG9zZVRpbWVvdXR9IHRvIGxpbWl0IHRoZSB0aW1lIG9mIGEgc2luZ2xlIGF0dGVtcHQpLlxuICAgKlxuICAgKiBFaXRoZXIgdGhpcyBvcHRpb24gb3Ige0BsaW5rIHN0YXJ0VG9DbG9zZVRpbWVvdXR9IGlzIHJlcXVpcmVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCB1bmxpbWl0ZWRcbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqL1xuICBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0PzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hhdCB0aGUgU0RLIGRvZXMgd2hlbiB0aGUgQWN0aXZpdHkgaXMgY2FuY2VsbGVkLlxuICAgKiAtIGBUUllfQ0FOQ0VMYCAtIEluaXRpYXRlIGEgY2FuY2VsbGF0aW9uIHJlcXVlc3QgYW5kIGltbWVkaWF0ZWx5IHJlcG9ydCBjYW5jZWxsYXRpb24gdG8gdGhlIHdvcmtmbG93LlxuICAgKiAtIGBXQUlUX0NBTkNFTExBVElPTl9DT01QTEVURURgIC0gV2FpdCBmb3IgYWN0aXZpdHkgY2FuY2VsbGF0aW9uIGNvbXBsZXRpb24uIE5vdGUgdGhhdCBhY3Rpdml0eSBtdXN0IGhlYXJ0YmVhdCB0byByZWNlaXZlIGFcbiAgICogICBjYW5jZWxsYXRpb24gbm90aWZpY2F0aW9uLiBUaGlzIGNhbiBibG9jayB0aGUgY2FuY2VsbGF0aW9uIGZvciBhIGxvbmcgdGltZSBpZiBhY3Rpdml0eSBkb2Vzbid0XG4gICAqICAgaGVhcnRiZWF0IG9yIGNob29zZXMgdG8gaWdub3JlIHRoZSBjYW5jZWxsYXRpb24gcmVxdWVzdC5cbiAgICogLSBgQUJBTkRPTmAgLSBEbyBub3QgcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgdGhlIGFjdGl2aXR5IGFuZCBpbW1lZGlhdGVseSByZXBvcnQgY2FuY2VsbGF0aW9uIHRvIHRoZSB3b3JrZmxvdy5cbiAgICovXG4gIGNhbmNlbGxhdGlvblR5cGU/OiBBY3Rpdml0eUNhbmNlbGxhdGlvblR5cGU7XG5cbiAgLyoqXG4gICAqIEVhZ2VyIGRpc3BhdGNoIGlzIGFuIG9wdGltaXphdGlvbiB0aGF0IGltcHJvdmVzIHRoZSB0aHJvdWdocHV0IGFuZCBsb2FkIG9uIHRoZSBzZXJ2ZXIgZm9yIHNjaGVkdWxpbmcgQWN0aXZpdGllcy5cbiAgICogV2hlbiB1c2VkLCB0aGUgc2VydmVyIHdpbGwgaGFuZCBvdXQgQWN0aXZpdHkgdGFza3MgYmFjayB0byB0aGUgV29ya2VyIHdoZW4gaXQgY29tcGxldGVzIGEgV29ya2Zsb3cgdGFzay5cbiAgICogSXQgaXMgYXZhaWxhYmxlIGZyb20gc2VydmVyIHZlcnNpb24gMS4xNyBiZWhpbmQgdGhlIGBzeXN0ZW0uZW5hYmxlQWN0aXZpdHlFYWdlckV4ZWN1dGlvbmAgZmVhdHVyZSBmbGFnLlxuICAgKlxuICAgKiBFYWdlciBkaXNwYXRjaCB3aWxsIG9ubHkgYmUgdXNlZCBpZiBgYWxsb3dFYWdlckRpc3BhdGNoYCBpcyBlbmFibGVkICh0aGUgZGVmYXVsdCkgYW5kIHtAbGluayB0YXNrUXVldWV9IGlzIGVpdGhlclxuICAgKiBvbWl0dGVkIG9yIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50IFdvcmtmbG93LlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBhbGxvd0VhZ2VyRGlzcGF0Y2g/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGVuIHVzaW5nIHRoZSBXb3JrZXIgVmVyc2lvbmluZyBmZWF0dXJlLCBzcGVjaWZpZXMgd2hldGhlciB0aGlzIEFjdGl2aXR5IHNob3VsZCBydW4gb24gYVxuICAgKiB3b3JrZXIgd2l0aCBhIGNvbXBhdGlibGUgQnVpbGQgSWQgb3Igbm90LiBTZWUge0BsaW5rIFZlcnNpb25pbmdJbnRlbnR9LlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICB2ZXJzaW9uaW5nSW50ZW50PzogVmVyc2lvbmluZ0ludGVudDtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBsb2NhbCBhY3Rpdml0eSBpbnZvY2F0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxBY3Rpdml0eU9wdGlvbnMge1xuICAvKipcbiAgICogUmV0cnlQb2xpY3kgdGhhdCBkZWZpbmVzIGhvdyBhbiBhY3Rpdml0eSBpcyByZXRyaWVkIGluIGNhc2Ugb2YgZmFpbHVyZS4gSWYgdGhpcyBpcyBub3Qgc2V0LCB0aGVuIHRoZSBTREstZGVmaW5lZCBkZWZhdWx0IGFjdGl2aXR5IHJldHJ5IHBvbGljeSB3aWxsIGJlIHVzZWQuXG4gICAqIE5vdGUgdGhhdCBsb2NhbCBhY3Rpdml0aWVzIGFyZSBhbHdheXMgZXhlY3V0ZWQgYXQgbGVhc3Qgb25jZSwgZXZlbiBpZiBtYXhpbXVtIGF0dGVtcHRzIGlzIHNldCB0byAxIGR1ZSB0byBXb3JrZmxvdyB0YXNrIHJldHJpZXMuXG4gICAqL1xuICByZXRyeT86IFJldHJ5UG9saWN5O1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIHRpbWUgdGhlIGxvY2FsIGFjdGl2aXR5IGlzIGFsbG93ZWQgdG8gZXhlY3V0ZSBhZnRlciB0aGUgdGFzayBpcyBkaXNwYXRjaGVkLiBUaGlzXG4gICAqIHRpbWVvdXQgaXMgYWx3YXlzIHJldHJ5YWJsZS5cbiAgICpcbiAgICogRWl0aGVyIHRoaXMgb3B0aW9uIG9yIHtAbGluayBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0fSBpcyByZXF1aXJlZC5cbiAgICogSWYgc2V0LCB0aGlzIG11c3QgYmUgPD0ge0BsaW5rIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXR9LCBvdGhlcndpc2UsIGl0IHdpbGwgYmUgY2xhbXBlZCBkb3duLlxuICAgKlxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHN0YXJ0VG9DbG9zZVRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogTGltaXRzIHRpbWUgdGhlIGxvY2FsIGFjdGl2aXR5IGNhbiBpZGxlIGludGVybmFsbHkgYmVmb3JlIGJlaW5nIGV4ZWN1dGVkLiBUaGF0IGNhbiBoYXBwZW4gaWZcbiAgICogdGhlIHdvcmtlciBpcyBjdXJyZW50bHkgYXQgbWF4IGNvbmN1cnJlbnQgbG9jYWwgYWN0aXZpdHkgZXhlY3V0aW9ucy4gVGhpcyB0aW1lb3V0IGlzIGFsd2F5c1xuICAgKiBub24gcmV0cnlhYmxlIGFzIGFsbCBhIHJldHJ5IHdvdWxkIGFjaGlldmUgaXMgdG8gcHV0IGl0IGJhY2sgaW50byB0aGUgc2FtZSBxdWV1ZS4gRGVmYXVsdHNcbiAgICogdG8ge0BsaW5rIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXR9IGlmIG5vdCBzcGVjaWZpZWQgYW5kIHRoYXQgaXMgc2V0LiBNdXN0IGJlIDw9XG4gICAqIHtAbGluayBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0fSB3aGVuIHNldCwgb3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGNsYW1wZWQgZG93bi5cbiAgICpcbiAgICogQGRlZmF1bHQgdW5saW1pdGVkXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgc2NoZWR1bGVUb1N0YXJ0VGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaG93IGxvbmcgdGhlIGNhbGxlciBpcyB3aWxsaW5nIHRvIHdhaXQgZm9yIGxvY2FsIGFjdGl2aXR5IGNvbXBsZXRpb24uIExpbWl0cyBob3dcbiAgICogbG9uZyByZXRyaWVzIHdpbGwgYmUgYXR0ZW1wdGVkLlxuICAgKlxuICAgKiBFaXRoZXIgdGhpcyBvcHRpb24gb3Ige0BsaW5rIHN0YXJ0VG9DbG9zZVRpbWVvdXR9IGlzIHJlcXVpcmVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCB1bmxpbWl0ZWRcbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqL1xuICBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0PzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqIElmIHRoZSBhY3Rpdml0eSBpcyByZXRyeWluZyBhbmQgYmFja29mZiB3b3VsZCBleGNlZWQgdGhpcyB2YWx1ZSwgYSBzZXJ2ZXIgc2lkZSB0aW1lciB3aWxsIGJlIHNjaGVkdWxlZCBmb3IgdGhlIG5leHQgYXR0ZW1wdC5cbiAgICogT3RoZXJ3aXNlLCBiYWNrb2ZmIHdpbGwgaGFwcGVuIGludGVybmFsbHkgaW4gdGhlIFNESy5cbiAgICpcbiAgICogQGRlZmF1bHQgMSBtaW51dGVcbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqKi9cbiAgbG9jYWxSZXRyeVRocmVzaG9sZD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoYXQgdGhlIFNESyBkb2VzIHdoZW4gdGhlIEFjdGl2aXR5IGlzIGNhbmNlbGxlZC5cbiAgICogLSBgVFJZX0NBTkNFTGAgLSBJbml0aWF0ZSBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0IGFuZCBpbW1lZGlhdGVseSByZXBvcnQgY2FuY2VsbGF0aW9uIHRvIHRoZSB3b3JrZmxvdy5cbiAgICogLSBgV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEYCAtIFdhaXQgZm9yIGFjdGl2aXR5IGNhbmNlbGxhdGlvbiBjb21wbGV0aW9uLiBOb3RlIHRoYXQgYWN0aXZpdHkgbXVzdCBoZWFydGJlYXQgdG8gcmVjZWl2ZSBhXG4gICAqICAgY2FuY2VsbGF0aW9uIG5vdGlmaWNhdGlvbi4gVGhpcyBjYW4gYmxvY2sgdGhlIGNhbmNlbGxhdGlvbiBmb3IgYSBsb25nIHRpbWUgaWYgYWN0aXZpdHkgZG9lc24ndFxuICAgKiAgIGhlYXJ0YmVhdCBvciBjaG9vc2VzIHRvIGlnbm9yZSB0aGUgY2FuY2VsbGF0aW9uIHJlcXVlc3QuXG4gICAqIC0gYEFCQU5ET05gIC0gRG8gbm90IHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIHRoZSBhY3Rpdml0eSBhbmQgaW1tZWRpYXRlbHkgcmVwb3J0IGNhbmNlbGxhdGlvbiB0byB0aGUgd29ya2Zsb3cuXG4gICAqL1xuICBjYW5jZWxsYXRpb25UeXBlPzogY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5BY3Rpdml0eUNhbmNlbGxhdGlvblR5cGU7XG59XG4iLCJpbXBvcnQgeyBEZWZhdWx0RmFpbHVyZUNvbnZlcnRlciwgRmFpbHVyZUNvbnZlcnRlciB9IGZyb20gJy4vZmFpbHVyZS1jb252ZXJ0ZXInO1xuaW1wb3J0IHsgUGF5bG9hZENvZGVjIH0gZnJvbSAnLi9wYXlsb2FkLWNvZGVjJztcbmltcG9ydCB7IGRlZmF1bHRQYXlsb2FkQ29udmVydGVyLCBQYXlsb2FkQ29udmVydGVyIH0gZnJvbSAnLi9wYXlsb2FkLWNvbnZlcnRlcic7XG5cbi8qKlxuICogV2hlbiB5b3VyIGRhdGEgKGFyZ3VtZW50cyBhbmQgcmV0dXJuIHZhbHVlcykgaXMgc2VudCBvdmVyIHRoZSB3aXJlIGFuZCBzdG9yZWQgYnkgVGVtcG9yYWwgU2VydmVyLCBpdCBpcyBlbmNvZGVkIGluXG4gKiBiaW5hcnkgaW4gYSB7QGxpbmsgUGF5bG9hZH0gUHJvdG9idWYgbWVzc2FnZS5cbiAqXG4gKiBUaGUgZGVmYXVsdCBgRGF0YUNvbnZlcnRlcmAgc3VwcG9ydHMgYHVuZGVmaW5lZGAsIGBVaW50OEFycmF5YCwgYW5kIEpTT04gc2VyaWFsaXphYmxlcyAoc28gaWZcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9KU09OL3N0cmluZ2lmeSNkZXNjcmlwdGlvbiB8IGBKU09OLnN0cmluZ2lmeSh5b3VyQXJnT3JSZXR2YWwpYH1cbiAqIHdvcmtzLCB0aGUgZGVmYXVsdCBkYXRhIGNvbnZlcnRlciB3aWxsIHdvcmspLiBQcm90b2J1ZnMgYXJlIHN1cHBvcnRlZCB2aWFcbiAqIHtAbGluayBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vdHlwZXNjcmlwdC9kYXRhLWNvbnZlcnRlcnMjcHJvdG9idWZzIHwgdGhpcyBBUEl9LlxuICpcbiAqIFVzZSBhIGN1c3RvbSBgRGF0YUNvbnZlcnRlcmAgdG8gY29udHJvbCB0aGUgY29udGVudHMgb2YgeW91ciB7QGxpbmsgUGF5bG9hZH1zLiBDb21tb24gcmVhc29ucyBmb3IgdXNpbmcgYSBjdXN0b21cbiAqIGBEYXRhQ29udmVydGVyYCBhcmU6XG4gKiAtIENvbnZlcnRpbmcgdmFsdWVzIHRoYXQgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGRlZmF1bHQgYERhdGFDb252ZXJ0ZXJgIChmb3IgZXhhbXBsZSwgYEpTT04uc3RyaW5naWZ5KClgIGRvZXNuJ3RcbiAqICAgaGFuZGxlIGBCaWdJbnRgcywgc28gaWYgeW91IHdhbnQgdG8gcmV0dXJuIGB7IHRvdGFsOiAxMDAwbiB9YCBmcm9tIGEgV29ya2Zsb3csIFNpZ25hbCwgb3IgQWN0aXZpdHksIHlvdSBuZWVkIHlvdXJcbiAqICAgb3duIGBEYXRhQ29udmVydGVyYCkuXG4gKiAtIEVuY3J5cHRpbmcgdmFsdWVzIHRoYXQgbWF5IGNvbnRhaW4gcHJpdmF0ZSBpbmZvcm1hdGlvbiB0aGF0IHlvdSBkb24ndCB3YW50IHN0b3JlZCBpbiBwbGFpbnRleHQgaW4gVGVtcG9yYWwgU2VydmVyJ3NcbiAqICAgZGF0YWJhc2UuXG4gKiAtIENvbXByZXNzaW5nIHZhbHVlcyB0byByZWR1Y2UgZGlzayBvciBuZXR3b3JrIHVzYWdlLlxuICpcbiAqIFRvIHVzZSB5b3VyIGN1c3RvbSBgRGF0YUNvbnZlcnRlcmAsIHByb3ZpZGUgaXQgdG8gdGhlIHtAbGluayBXb3JrZmxvd0NsaWVudH0sIHtAbGluayBXb3JrZXJ9LCBhbmRcbiAqIHtAbGluayBidW5kbGVXb3JrZmxvd0NvZGV9IChpZiB5b3UgdXNlIGl0KTpcbiAqIC0gYG5ldyBXb3JrZmxvd0NsaWVudCh7IC4uLiwgZGF0YUNvbnZlcnRlciB9KWBcbiAqIC0gYFdvcmtlci5jcmVhdGUoeyAuLi4sIGRhdGFDb252ZXJ0ZXIgfSlgXG4gKiAtIGBidW5kbGVXb3JrZmxvd0NvZGUoeyAuLi4sIHBheWxvYWRDb252ZXJ0ZXJQYXRoIH0pYFxuICovXG5leHBvcnQgaW50ZXJmYWNlIERhdGFDb252ZXJ0ZXIge1xuICAvKipcbiAgICogUGF0aCBvZiBhIGZpbGUgdGhhdCBoYXMgYSBgcGF5bG9hZENvbnZlcnRlcmAgbmFtZWQgZXhwb3J0LlxuICAgKiBgcGF5bG9hZENvbnZlcnRlcmAgc2hvdWxkIGJlIGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHMge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJ9LlxuICAgKiBJZiBubyBwYXRoIGlzIHByb3ZpZGVkLCB7QGxpbmsgZGVmYXVsdFBheWxvYWRDb252ZXJ0ZXJ9IGlzIHVzZWQuXG4gICAqL1xuICBwYXlsb2FkQ29udmVydGVyUGF0aD86IHN0cmluZztcblxuICAvKipcbiAgICogUGF0aCBvZiBhIGZpbGUgdGhhdCBoYXMgYSBgZmFpbHVyZUNvbnZlcnRlcmAgbmFtZWQgZXhwb3J0LlxuICAgKiBgZmFpbHVyZUNvbnZlcnRlcmAgc2hvdWxkIGJlIGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHMge0BsaW5rIEZhaWx1cmVDb252ZXJ0ZXJ9LlxuICAgKiBJZiBubyBwYXRoIGlzIHByb3ZpZGVkLCB7QGxpbmsgZGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXJ9IGlzIHVzZWQuXG4gICAqL1xuICBmYWlsdXJlQ29udmVydGVyUGF0aD86IHN0cmluZztcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2Yge0BsaW5rIFBheWxvYWRDb2RlY30gaW5zdGFuY2VzLlxuICAgKlxuICAgKiBQYXlsb2FkcyBhcmUgZW5jb2RlZCBpbiB0aGUgb3JkZXIgb2YgdGhlIGFycmF5IGFuZCBkZWNvZGVkIGluIHRoZSBvcHBvc2l0ZSBvcmRlci4gRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIGFcbiAgICogY29tcHJlc3Npb24gY29kZWMgYW5kIGFuIGVuY3J5cHRpb24gY29kZWMsIHRoZW4geW91IHdhbnQgZGF0YSB0byBiZSBlbmNvZGVkIHdpdGggdGhlIGNvbXByZXNzaW9uIGNvZGVjIGZpcnN0LCBzb1xuICAgKiB5b3UnZCBkbyBgcGF5bG9hZENvZGVjczogW2NvbXByZXNzaW9uQ29kZWMsIGVuY3J5cHRpb25Db2RlY11gLlxuICAgKi9cbiAgcGF5bG9hZENvZGVjcz86IFBheWxvYWRDb2RlY1tdO1xufVxuXG4vKipcbiAqIEEge0BsaW5rIERhdGFDb252ZXJ0ZXJ9IHRoYXQgaGFzIGJlZW4gbG9hZGVkIHZpYSB7QGxpbmsgbG9hZERhdGFDb252ZXJ0ZXJ9LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlZERhdGFDb252ZXJ0ZXIge1xuICBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyO1xuICBmYWlsdXJlQ29udmVydGVyOiBGYWlsdXJlQ29udmVydGVyO1xuICBwYXlsb2FkQ29kZWNzOiBQYXlsb2FkQ29kZWNbXTtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCB7QGxpbmsgRmFpbHVyZUNvbnZlcnRlcn0gdXNlZCBieSB0aGUgU0RLLlxuICpcbiAqIEVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMgYXJlIHNlcml6YWxpemVkIGFzIHBsYWluIHRleHQuXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0RmFpbHVyZUNvbnZlcnRlcjogRmFpbHVyZUNvbnZlcnRlciA9IG5ldyBEZWZhdWx0RmFpbHVyZUNvbnZlcnRlcigpO1xuXG4vKipcbiAqIEEgXCJsb2FkZWRcIiBkYXRhIGNvbnZlcnRlciB0aGF0IHVzZXMgdGhlIGRlZmF1bHQgc2V0IG9mIGZhaWx1cmUgYW5kIHBheWxvYWQgY29udmVydGVycy5cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHREYXRhQ29udmVydGVyOiBMb2FkZWREYXRhQ29udmVydGVyID0ge1xuICBwYXlsb2FkQ29udmVydGVyOiBkZWZhdWx0UGF5bG9hZENvbnZlcnRlcixcbiAgZmFpbHVyZUNvbnZlcnRlcjogZGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXIsXG4gIHBheWxvYWRDb2RlY3M6IFtdLFxufTtcbiIsImltcG9ydCB7XG4gIEFjdGl2aXR5RmFpbHVyZSxcbiAgQXBwbGljYXRpb25GYWlsdXJlLFxuICBDYW5jZWxsZWRGYWlsdXJlLFxuICBDaGlsZFdvcmtmbG93RmFpbHVyZSxcbiAgRkFJTFVSRV9TT1VSQ0UsXG4gIFByb3RvRmFpbHVyZSxcbiAgUmV0cnlTdGF0ZSxcbiAgU2VydmVyRmFpbHVyZSxcbiAgVGVtcG9yYWxGYWlsdXJlLFxuICBUZXJtaW5hdGVkRmFpbHVyZSxcbiAgVGltZW91dEZhaWx1cmUsXG4gIFRpbWVvdXRUeXBlLFxufSBmcm9tICcuLi9mYWlsdXJlJztcbmltcG9ydCB7IGlzRXJyb3IgfSBmcm9tICcuLi90eXBlLWhlbHBlcnMnO1xuaW1wb3J0IHsgYXJyYXlGcm9tUGF5bG9hZHMsIGZyb21QYXlsb2Fkc0F0SW5kZXgsIFBheWxvYWRDb252ZXJ0ZXIsIHRvUGF5bG9hZHMgfSBmcm9tICcuL3BheWxvYWQtY29udmVydGVyJztcblxuLyoqXG4gKiBTdGFjayB0cmFjZXMgd2lsbCBiZSBjdXRvZmYgd2hlbiBvbiBvZiB0aGVzZSBwYXR0ZXJucyBpcyBtYXRjaGVkXG4gKi9cbmNvbnN0IENVVE9GRl9TVEFDS19QQVRURVJOUyA9IFtcbiAgLyoqIEFjdGl2aXR5IGV4ZWN1dGlvbiAqL1xuICAvXFxzK2F0IEFjdGl2aXR5XFwuZXhlY3V0ZSBcXCguKltcXFxcL113b3JrZXJbXFxcXC9dKD86c3JjfGxpYilbXFxcXC9dYWN0aXZpdHlcXC5banRdczpcXGQrOlxcZCtcXCkvLFxuICAvKiogV29ya2Zsb3cgYWN0aXZhdGlvbiAqL1xuICAvXFxzK2F0IEFjdGl2YXRvclxcLlxcUytOZXh0SGFuZGxlciBcXCguKltcXFxcL113b3JrZmxvd1tcXFxcL10oPzpzcmN8bGliKVtcXFxcL11pbnRlcm5hbHNcXC5banRdczpcXGQrOlxcZCtcXCkvLFxuICAvKiogV29ya2Zsb3cgcnVuIGFueXRoaW5nIGluIGNvbnRleHQgKi9cbiAgL1xccythdCBTY3JpcHRcXC5ydW5JbkNvbnRleHQgXFwoKD86bm9kZTp2bXx2bVxcLmpzKTpcXGQrOlxcZCtcXCkvLFxuXTtcblxuLyoqXG4gKiBDdXRzIG91dCB0aGUgZnJhbWV3b3JrIHBhcnQgb2YgYSBzdGFjayB0cmFjZSwgbGVhdmluZyBvbmx5IHVzZXIgY29kZSBlbnRyaWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdXRvZmZTdGFja1RyYWNlKHN0YWNrPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgbGluZXMgPSAoc3RhY2sgPz8gJycpLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGNvbnN0IGFjYyA9IEFycmF5PHN0cmluZz4oKTtcbiAgbGluZUxvb3A6IGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBDVVRPRkZfU1RBQ0tfUEFUVEVSTlMpIHtcbiAgICAgIGlmIChwYXR0ZXJuLnRlc3QobGluZSkpIGJyZWFrIGxpbmVMb29wO1xuICAgIH1cbiAgICBhY2MucHVzaChsaW5lKTtcbiAgfVxuICByZXR1cm4gYWNjLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIEEgYEZhaWx1cmVDb252ZXJ0ZXJgIGlzIHJlc3BvbnNpYmxlIGZvciBjb252ZXJ0aW5nIGZyb20gcHJvdG8gYEZhaWx1cmVgIGluc3RhbmNlcyB0byBKUyBgRXJyb3JzYCBhbmQgYmFjay5cbiAqXG4gKiBXZSByZWNvbW1lbmRlZCB1c2luZyB0aGUge0BsaW5rIERlZmF1bHRGYWlsdXJlQ29udmVydGVyfSBpbnN0ZWFkIG9mIGN1c3RvbWl6aW5nIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGluIG9yZGVyXG4gKiB0byBtYWludGFpbiBjcm9zcy1sYW5ndWFnZSBGYWlsdXJlIHNlcmlhbGl6YXRpb24gY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGYWlsdXJlQ29udmVydGVyIHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgY2F1Z2h0IGVycm9yIHRvIGEgRmFpbHVyZSBwcm90byBtZXNzYWdlLlxuICAgKi9cbiAgZXJyb3JUb0ZhaWx1cmUoZXJyOiB1bmtub3duLCBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyKTogUHJvdG9GYWlsdXJlO1xuICAvKipcbiAgICogQ29udmVydHMgYSBGYWlsdXJlIHByb3RvIG1lc3NhZ2UgdG8gYSBKUyBFcnJvciBvYmplY3QuXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBlcnJvciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGBUZW1wb3JhbEZhaWx1cmVgLlxuICAgKi9cbiAgZmFpbHVyZVRvRXJyb3IoZXJyOiBQcm90b0ZhaWx1cmUsIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIpOiBUZW1wb3JhbEZhaWx1cmU7XG59XG5cbi8qKlxuICogVGhlIFwic2hhcGVcIiBvZiB0aGUgYXR0cmlidXRlcyBzZXQgYXMgdGhlIHtAbGluayBQcm90b0ZhaWx1cmUuZW5jb2RlZEF0dHJpYnV0ZXN9IHBheWxvYWQgaW4gY2FzZVxuICoge0BsaW5rIERlZmF1bHRFbmNvZGVkRmFpbHVyZUF0dHJpYnV0ZXMuZW5jb2RlQ29tbW9uQXR0cmlidXRlc30gaXMgc2V0IHRvIGB0cnVlYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0RW5jb2RlZEZhaWx1cmVBdHRyaWJ1dGVzIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBzdGFja190cmFjZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHRoZSB7QGxpbmsgRGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXJ9IGNvbnN0cnVjdG9yLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRGYWlsdXJlQ29udmVydGVyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuY29kZSBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzIChmb3IgZW5jcnlwdGluZyB0aGVzZSBhdHRyaWJ1dGVzIHVzZSBhIHtAbGluayBQYXlsb2FkQ29kZWN9KS5cbiAgICovXG4gIGVuY29kZUNvbW1vbkF0dHJpYnV0ZXM6IGJvb2xlYW47XG59XG5cbi8qKlxuICogRGVmYXVsdCwgY3Jvc3MtbGFuZ3VhZ2UtY29tcGF0aWJsZSBGYWlsdXJlIGNvbnZlcnRlci5cbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCB3aWxsIGxlYXZlIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMgYXMgcGxhaW4gdGV4dC4gSW4gb3JkZXIgdG8gZW5jcnlwdCB0aGVtLCBzZXRcbiAqIGBlbmNvZGVDb21tb25BdHRyaWJ1dGVzYCB0byBgdHJ1ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9wdGlvbnMgYW5kIHVzZSBhIHtAbGluayBQYXlsb2FkQ29kZWN9IHRoYXQgY2FuIGVuY3J5cHQgL1xuICogZGVjcnlwdCBQYXlsb2FkcyBpbiB5b3VyIHtAbGluayBXb3JrZXJPcHRpb25zLmRhdGFDb252ZXJ0ZXIgfCBXb3JrZXJ9IGFuZFxuICoge0BsaW5rIENsaWVudE9wdGlvbnMuZGF0YUNvbnZlcnRlciB8IENsaWVudCBvcHRpb25zfS5cbiAqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRGYWlsdXJlQ29udmVydGVyIGltcGxlbWVudHMgRmFpbHVyZUNvbnZlcnRlciB7XG4gIHB1YmxpYyByZWFkb25seSBvcHRpb25zOiBEZWZhdWx0RmFpbHVyZUNvbnZlcnRlck9wdGlvbnM7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IFBhcnRpYWw8RGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXJPcHRpb25zPikge1xuICAgIGNvbnN0IHsgZW5jb2RlQ29tbW9uQXR0cmlidXRlcyB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBlbmNvZGVDb21tb25BdHRyaWJ1dGVzOiBlbmNvZGVDb21tb25BdHRyaWJ1dGVzID8/IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBGYWlsdXJlIHByb3RvIG1lc3NhZ2UgdG8gYSBKUyBFcnJvciBvYmplY3QuXG4gICAqXG4gICAqIERvZXMgbm90IHNldCBjb21tb24gcHJvcGVydGllcywgdGhhdCBpcyBkb25lIGluIHtAbGluayBmYWlsdXJlVG9FcnJvcn0uXG4gICAqL1xuICBmYWlsdXJlVG9FcnJvcklubmVyKGZhaWx1cmU6IFByb3RvRmFpbHVyZSwgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcik6IFRlbXBvcmFsRmFpbHVyZSB7XG4gICAgaWYgKGZhaWx1cmUuYXBwbGljYXRpb25GYWlsdXJlSW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBBcHBsaWNhdGlvbkZhaWx1cmUoXG4gICAgICAgIGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsXG4gICAgICAgIGZhaWx1cmUuYXBwbGljYXRpb25GYWlsdXJlSW5mby50eXBlLFxuICAgICAgICBCb29sZWFuKGZhaWx1cmUuYXBwbGljYXRpb25GYWlsdXJlSW5mby5ub25SZXRyeWFibGUpLFxuICAgICAgICBhcnJheUZyb21QYXlsb2FkcyhwYXlsb2FkQ29udmVydGVyLCBmYWlsdXJlLmFwcGxpY2F0aW9uRmFpbHVyZUluZm8uZGV0YWlscz8ucGF5bG9hZHMpLFxuICAgICAgICB0aGlzLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGZhaWx1cmUuc2VydmVyRmFpbHVyZUluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgU2VydmVyRmFpbHVyZShcbiAgICAgICAgZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgQm9vbGVhbihmYWlsdXJlLnNlcnZlckZhaWx1cmVJbmZvLm5vblJldHJ5YWJsZSksXG4gICAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmFpbHVyZS50aW1lb3V0RmFpbHVyZUluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgVGltZW91dEZhaWx1cmUoXG4gICAgICAgIGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsXG4gICAgICAgIGZyb21QYXlsb2Fkc0F0SW5kZXgocGF5bG9hZENvbnZlcnRlciwgMCwgZmFpbHVyZS50aW1lb3V0RmFpbHVyZUluZm8ubGFzdEhlYXJ0YmVhdERldGFpbHM/LnBheWxvYWRzKSxcbiAgICAgICAgZmFpbHVyZS50aW1lb3V0RmFpbHVyZUluZm8udGltZW91dFR5cGUgPz8gVGltZW91dFR5cGUuVElNRU9VVF9UWVBFX1VOU1BFQ0lGSUVEXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmFpbHVyZS50ZXJtaW5hdGVkRmFpbHVyZUluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgVGVybWluYXRlZEZhaWx1cmUoXG4gICAgICAgIGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsXG4gICAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmFpbHVyZS5jYW5jZWxlZEZhaWx1cmVJbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IENhbmNlbGxlZEZhaWx1cmUoXG4gICAgICAgIGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsXG4gICAgICAgIGFycmF5RnJvbVBheWxvYWRzKHBheWxvYWRDb252ZXJ0ZXIsIGZhaWx1cmUuY2FuY2VsZWRGYWlsdXJlSW5mby5kZXRhaWxzPy5wYXlsb2FkcyksXG4gICAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmFpbHVyZS5yZXNldFdvcmtmbG93RmFpbHVyZUluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgQXBwbGljYXRpb25GYWlsdXJlKFxuICAgICAgICBmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLFxuICAgICAgICAnUmVzZXRXb3JrZmxvdycsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBhcnJheUZyb21QYXlsb2FkcyhwYXlsb2FkQ29udmVydGVyLCBmYWlsdXJlLnJlc2V0V29ya2Zsb3dGYWlsdXJlSW5mby5sYXN0SGVhcnRiZWF0RGV0YWlscz8ucGF5bG9hZHMpLFxuICAgICAgICB0aGlzLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGZhaWx1cmUuY2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWx1cmVJbmZvKSB7XG4gICAgICBjb25zdCB7IG5hbWVzcGFjZSwgd29ya2Zsb3dUeXBlLCB3b3JrZmxvd0V4ZWN1dGlvbiwgcmV0cnlTdGF0ZSB9ID0gZmFpbHVyZS5jaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbHVyZUluZm87XG4gICAgICBpZiAoISh3b3JrZmxvd1R5cGU/Lm5hbWUgJiYgd29ya2Zsb3dFeGVjdXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgYXR0cmlidXRlcyBvbiBjaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbHVyZUluZm8nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2hpbGRXb3JrZmxvd0ZhaWx1cmUoXG4gICAgICAgIG5hbWVzcGFjZSA/PyB1bmRlZmluZWQsXG4gICAgICAgIHdvcmtmbG93RXhlY3V0aW9uLFxuICAgICAgICB3b3JrZmxvd1R5cGUubmFtZSxcbiAgICAgICAgcmV0cnlTdGF0ZSA/PyBSZXRyeVN0YXRlLlJFVFJZX1NUQVRFX1VOU1BFQ0lGSUVELFxuICAgICAgICB0aGlzLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGZhaWx1cmUuYWN0aXZpdHlGYWlsdXJlSW5mbykge1xuICAgICAgaWYgKCFmYWlsdXJlLmFjdGl2aXR5RmFpbHVyZUluZm8uYWN0aXZpdHlUeXBlPy5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgYWN0aXZpdHlUeXBlPy5uYW1lIG9uIGFjdGl2aXR5RmFpbHVyZUluZm8nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQWN0aXZpdHlGYWlsdXJlKFxuICAgICAgICBmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLFxuICAgICAgICBmYWlsdXJlLmFjdGl2aXR5RmFpbHVyZUluZm8uYWN0aXZpdHlUeXBlLm5hbWUsXG4gICAgICAgIGZhaWx1cmUuYWN0aXZpdHlGYWlsdXJlSW5mby5hY3Rpdml0eUlkID8/IHVuZGVmaW5lZCxcbiAgICAgICAgZmFpbHVyZS5hY3Rpdml0eUZhaWx1cmVJbmZvLnJldHJ5U3RhdGUgPz8gUmV0cnlTdGF0ZS5SRVRSWV9TVEFURV9VTlNQRUNJRklFRCxcbiAgICAgICAgZmFpbHVyZS5hY3Rpdml0eUZhaWx1cmVJbmZvLmlkZW50aXR5ID8/IHVuZGVmaW5lZCxcbiAgICAgICAgdGhpcy5vcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoZmFpbHVyZS5jYXVzZSwgcGF5bG9hZENvbnZlcnRlcilcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVtcG9yYWxGYWlsdXJlKFxuICAgICAgZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCxcbiAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpXG4gICAgKTtcbiAgfVxuXG4gIGZhaWx1cmVUb0Vycm9yKGZhaWx1cmU6IFByb3RvRmFpbHVyZSwgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcik6IFRlbXBvcmFsRmFpbHVyZSB7XG4gICAgaWYgKGZhaWx1cmUuZW5jb2RlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gcGF5bG9hZENvbnZlcnRlci5mcm9tUGF5bG9hZDxEZWZhdWx0RW5jb2RlZEZhaWx1cmVBdHRyaWJ1dGVzPihmYWlsdXJlLmVuY29kZWRBdHRyaWJ1dGVzKTtcbiAgICAgIC8vIERvbid0IGFwcGx5IGVuY29kZWRBdHRyaWJ1dGVzIHVubGVzcyB0aGV5IGNvbmZvcm0gdG8gYW4gZXhwZWN0ZWQgc2NoZW1hXG4gICAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnb2JqZWN0JyAmJiBhdHRycyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIHN0YWNrX3RyYWNlIH0gPSBhdHRycztcbiAgICAgICAgLy8gQXZvaWQgbXV0YXRpbmcgdGhlIGFyZ3VtZW50XG4gICAgICAgIGZhaWx1cmUgPSB7IC4uLmZhaWx1cmUgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGZhaWx1cmUubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzdGFja190cmFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBmYWlsdXJlLnN0YWNrVHJhY2UgPSBzdGFja190cmFjZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlcnIgPSB0aGlzLmZhaWx1cmVUb0Vycm9ySW5uZXIoZmFpbHVyZSwgcGF5bG9hZENvbnZlcnRlcik7XG4gICAgZXJyLnN0YWNrID0gZmFpbHVyZS5zdGFja1RyYWNlID8/ICcnO1xuICAgIGVyci5mYWlsdXJlID0gZmFpbHVyZTtcbiAgICByZXR1cm4gZXJyO1xuICB9XG5cbiAgZXJyb3JUb0ZhaWx1cmUoZXJyOiB1bmtub3duLCBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyKTogUHJvdG9GYWlsdXJlIHtcbiAgICBjb25zdCBmYWlsdXJlID0gdGhpcy5lcnJvclRvRmFpbHVyZUlubmVyKGVyciwgcGF5bG9hZENvbnZlcnRlcik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbmNvZGVDb21tb25BdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2UsIHN0YWNrVHJhY2UgfSA9IGZhaWx1cmU7XG4gICAgICBmYWlsdXJlLm1lc3NhZ2UgPSAnRW5jb2RlZCBmYWlsdXJlJztcbiAgICAgIGZhaWx1cmUuc3RhY2tUcmFjZSA9ICcnO1xuICAgICAgZmFpbHVyZS5lbmNvZGVkQXR0cmlidXRlcyA9IHBheWxvYWRDb252ZXJ0ZXIudG9QYXlsb2FkKHsgbWVzc2FnZSwgc3RhY2tfdHJhY2U6IHN0YWNrVHJhY2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBmYWlsdXJlO1xuICB9XG5cbiAgZXJyb3JUb0ZhaWx1cmVJbm5lcihlcnI6IHVua25vd24sIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIpOiBQcm90b0ZhaWx1cmUge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUZW1wb3JhbEZhaWx1cmUpIHtcbiAgICAgIGlmIChlcnIuZmFpbHVyZSkgcmV0dXJuIGVyci5mYWlsdXJlO1xuICAgICAgY29uc3QgYmFzZSA9IHtcbiAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrVHJhY2U6IGN1dG9mZlN0YWNrVHJhY2UoZXJyLnN0YWNrKSxcbiAgICAgICAgY2F1c2U6IHRoaXMub3B0aW9uYWxFcnJvclRvT3B0aW9uYWxGYWlsdXJlKGVyci5jYXVzZSwgcGF5bG9hZENvbnZlcnRlciksXG4gICAgICAgIHNvdXJjZTogRkFJTFVSRV9TT1VSQ0UsXG4gICAgICB9O1xuXG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQWN0aXZpdHlGYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICBhY3Rpdml0eUZhaWx1cmVJbmZvOiB7XG4gICAgICAgICAgICAuLi5lcnIsXG4gICAgICAgICAgICBhY3Rpdml0eVR5cGU6IHsgbmFtZTogZXJyLmFjdGl2aXR5VHlwZSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ2hpbGRXb3JrZmxvd0ZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgIGNoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsdXJlSW5mbzoge1xuICAgICAgICAgICAgLi4uZXJyLFxuICAgICAgICAgICAgd29ya2Zsb3dFeGVjdXRpb246IGVyci5leGVjdXRpb24sXG4gICAgICAgICAgICB3b3JrZmxvd1R5cGU6IHsgbmFtZTogZXJyLndvcmtmbG93VHlwZSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQXBwbGljYXRpb25GYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICBhcHBsaWNhdGlvbkZhaWx1cmVJbmZvOiB7XG4gICAgICAgICAgICB0eXBlOiBlcnIudHlwZSxcbiAgICAgICAgICAgIG5vblJldHJ5YWJsZTogZXJyLm5vblJldHJ5YWJsZSxcbiAgICAgICAgICAgIGRldGFpbHM6XG4gICAgICAgICAgICAgIGVyci5kZXRhaWxzICYmIGVyci5kZXRhaWxzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8geyBwYXlsb2FkczogdG9QYXlsb2FkcyhwYXlsb2FkQ29udmVydGVyLCAuLi5lcnIuZGV0YWlscykgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ2FuY2VsbGVkRmFpbHVyZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmJhc2UsXG4gICAgICAgICAgY2FuY2VsZWRGYWlsdXJlSW5mbzoge1xuICAgICAgICAgICAgZGV0YWlsczpcbiAgICAgICAgICAgICAgZXJyLmRldGFpbHMgJiYgZXJyLmRldGFpbHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyB7IHBheWxvYWRzOiB0b1BheWxvYWRzKHBheWxvYWRDb252ZXJ0ZXIsIC4uLmVyci5kZXRhaWxzKSB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUaW1lb3V0RmFpbHVyZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmJhc2UsXG4gICAgICAgICAgdGltZW91dEZhaWx1cmVJbmZvOiB7XG4gICAgICAgICAgICB0aW1lb3V0VHlwZTogZXJyLnRpbWVvdXRUeXBlLFxuICAgICAgICAgICAgbGFzdEhlYXJ0YmVhdERldGFpbHM6IGVyci5sYXN0SGVhcnRiZWF0RGV0YWlsc1xuICAgICAgICAgICAgICA/IHsgcGF5bG9hZHM6IHRvUGF5bG9hZHMocGF5bG9hZENvbnZlcnRlciwgZXJyLmxhc3RIZWFydGJlYXREZXRhaWxzKSB9XG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU2VydmVyRmFpbHVyZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmJhc2UsXG4gICAgICAgICAgc2VydmVyRmFpbHVyZUluZm86IHsgbm9uUmV0cnlhYmxlOiBlcnIubm9uUmV0cnlhYmxlIH0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVGVybWluYXRlZEZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgIHRlcm1pbmF0ZWRGYWlsdXJlSW5mbzoge30sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBKdXN0IGEgVGVtcG9yYWxGYWlsdXJlXG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlID0ge1xuICAgICAgc291cmNlOiBGQUlMVVJFX1NPVVJDRSxcbiAgICB9O1xuXG4gICAgaWYgKGlzRXJyb3IoZXJyKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgbWVzc2FnZTogU3RyaW5nKGVyci5tZXNzYWdlKSA/PyAnJyxcbiAgICAgICAgc3RhY2tUcmFjZTogY3V0b2ZmU3RhY2tUcmFjZShlcnIuc3RhY2spLFxuICAgICAgICBjYXVzZTogdGhpcy5vcHRpb25hbEVycm9yVG9PcHRpb25hbEZhaWx1cmUoKGVyciBhcyBhbnkpLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgcmVjb21tZW5kYXRpb24gPSBgIFtBIG5vbi1FcnJvciB2YWx1ZSB3YXMgdGhyb3duIGZyb20geW91ciBjb2RlLiBXZSByZWNvbW1lbmQgdGhyb3dpbmcgRXJyb3Igb2JqZWN0cyBzbyB0aGF0IHdlIGNhbiBwcm92aWRlIGEgc3RhY2sgdHJhY2VdYDtcblxuICAgIGlmICh0eXBlb2YgZXJyID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHsgLi4uYmFzZSwgbWVzc2FnZTogZXJyICsgcmVjb21tZW5kYXRpb24gfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdvYmplY3QnKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGVycik7XG4gICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBTdHJpbmcoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLmJhc2UsIG1lc3NhZ2U6IG1lc3NhZ2UgKyByZWNvbW1lbmRhdGlvbiB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IC4uLmJhc2UsIG1lc3NhZ2U6IFN0cmluZyhlcnIpICsgcmVjb21tZW5kYXRpb24gfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIEZhaWx1cmUgcHJvdG8gbWVzc2FnZSB0byBhIEpTIEVycm9yIG9iamVjdCBpZiBkZWZpbmVkIG9yIHJldHVybnMgdW5kZWZpbmVkLlxuICAgKi9cbiAgb3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKFxuICAgIGZhaWx1cmU6IFByb3RvRmFpbHVyZSB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlclxuICApOiBUZW1wb3JhbEZhaWx1cmUgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBmYWlsdXJlID8gdGhpcy5mYWlsdXJlVG9FcnJvcihmYWlsdXJlLCBwYXlsb2FkQ29udmVydGVyKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBlcnJvciB0byBhIEZhaWx1cmUgcHJvdG8gbWVzc2FnZSBpZiBkZWZpbmVkIG9yIHJldHVybnMgdW5kZWZpbmVkXG4gICAqL1xuICBvcHRpb25hbEVycm9yVG9PcHRpb25hbEZhaWx1cmUoZXJyOiB1bmtub3duLCBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyKTogUHJvdG9GYWlsdXJlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZXJyID8gdGhpcy5lcnJvclRvRmFpbHVyZShlcnIsIHBheWxvYWRDb252ZXJ0ZXIpIDogdW5kZWZpbmVkO1xuICB9XG59XG4iLCJpbXBvcnQgeyBQYXlsb2FkIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5cbi8qKlxuICogYFBheWxvYWRDb2RlY2AgaXMgYW4gb3B0aW9uYWwgc3RlcCB0aGF0IGhhcHBlbnMgYmV0d2VlbiB0aGUgd2lyZSBhbmQgdGhlIHtAbGluayBQYXlsb2FkQ29udmVydGVyfTpcbiAqXG4gKiBUZW1wb3JhbCBTZXJ2ZXIgPC0tPiBXaXJlIDwtLT4gYFBheWxvYWRDb2RlY2AgPC0tPiBgUGF5bG9hZENvbnZlcnRlcmAgPC0tPiBVc2VyIGNvZGVcbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyB0byB0cmFuc2Zvcm0gYW4gYXJyYXkgb2Yge0BsaW5rIFBheWxvYWR9cyB0by9mcm9tIHRoZSBmb3JtYXQgc2VudCBvdmVyIHRoZSB3aXJlIGFuZCBzdG9yZWQgYnkgVGVtcG9yYWwgU2VydmVyLlxuICogQ29tbW9uIHRyYW5zZm9ybWF0aW9ucyBhcmUgZW5jcnlwdGlvbiBhbmQgY29tcHJlc3Npb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bG9hZENvZGVjIHtcbiAgLyoqXG4gICAqIEVuY29kZSBhbiBhcnJheSBvZiB7QGxpbmsgUGF5bG9hZH1zIGZvciBzZW5kaW5nIG92ZXIgdGhlIHdpcmUuXG4gICAqIEBwYXJhbSBwYXlsb2FkcyBNYXkgaGF2ZSBsZW5ndGggMC5cbiAgICovXG4gIGVuY29kZShwYXlsb2FkczogUGF5bG9hZFtdKTogUHJvbWlzZTxQYXlsb2FkW10+O1xuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXJyYXkgb2Yge0BsaW5rIFBheWxvYWR9cyByZWNlaXZlZCBmcm9tIHRoZSB3aXJlLlxuICAgKi9cbiAgZGVjb2RlKHBheWxvYWRzOiBQYXlsb2FkW10pOiBQcm9taXNlPFBheWxvYWRbXT47XG59XG4iLCJpbXBvcnQgeyBkZWNvZGUsIGVuY29kZSB9IGZyb20gJy4uL2VuY29kaW5nJztcbmltcG9ydCB7IFBheWxvYWRDb252ZXJ0ZXJFcnJvciwgVmFsdWVFcnJvciB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBQYXlsb2FkIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBlbmNvZGluZ0tleXMsIGVuY29kaW5nVHlwZXMsIE1FVEFEQVRBX0VOQ09ESU5HX0tFWSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIFVzZWQgYnkgdGhlIGZyYW1ld29yayB0byBzZXJpYWxpemUvZGVzZXJpYWxpemUgZGF0YSBsaWtlIHBhcmFtZXRlcnMgYW5kIHJldHVybiB2YWx1ZXMuXG4gKlxuICogVGhpcyBpcyBjYWxsZWQgaW5zaWRlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL3R5cGVzY3JpcHQvZGV0ZXJtaW5pc20gfCBXb3JrZmxvdyBpc29sYXRlfS5cbiAqIFRvIHdyaXRlIGFzeW5jIGNvZGUgb3IgdXNlIE5vZGUgQVBJcyAob3IgdXNlIHBhY2thZ2VzIHRoYXQgdXNlIE5vZGUgQVBJcyksIHVzZSBhIHtAbGluayBQYXlsb2FkQ29kZWN9LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBheWxvYWRDb252ZXJ0ZXIge1xuICAvKipcbiAgICogQ29udmVydHMgYSB2YWx1ZSB0byBhIHtAbGluayBQYXlsb2FkfS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LiBFeGFtcGxlIHZhbHVlcyBpbmNsdWRlIHRoZSBXb3JrZmxvdyBhcmdzIHNlbnQgZnJvbSB0aGUgQ2xpZW50IGFuZCB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IGEgV29ya2Zsb3cgb3IgQWN0aXZpdHkuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgUGF5bG9hZH0uXG4gICAqXG4gICAqIFNob3VsZCB0aHJvdyB7QGxpbmsgVmFsdWVFcnJvcn0gaWYgdW5hYmxlIHRvIGNvbnZlcnQuXG4gICAqL1xuICB0b1BheWxvYWQ8VD4odmFsdWU6IFQpOiBQYXlsb2FkO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHtAbGluayBQYXlsb2FkfSBiYWNrIHRvIGEgdmFsdWUuXG4gICAqL1xuICBmcm9tUGF5bG9hZDxUPihwYXlsb2FkOiBQYXlsb2FkKTogVDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGNvbnZlcnNpb24gb2YgYSBsaXN0IG9mIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gY29udmVydGVyXG4gKiBAcGFyYW0gdmFsdWVzIEpTIHZhbHVlcyB0byBjb252ZXJ0IHRvIFBheWxvYWRzXG4gKiBAcmV0dXJuIGxpc3Qgb2Yge0BsaW5rIFBheWxvYWR9c1xuICogQHRocm93cyB7QGxpbmsgVmFsdWVFcnJvcn0gaWYgY29udmVyc2lvbiBvZiB0aGUgdmFsdWUgcGFzc2VkIGFzIHBhcmFtZXRlciBmYWlsZWQgZm9yIGFueVxuICogICAgIHJlYXNvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUGF5bG9hZHMoY29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyLCAuLi52YWx1ZXM6IHVua25vd25bXSk6IFBheWxvYWRbXSB8IHVuZGVmaW5lZCB7XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gY29udmVydGVyLnRvUGF5bG9hZCh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFJ1biB7QGxpbmsgUGF5bG9hZENvbnZlcnRlci50b1BheWxvYWR9IG9uIGVhY2ggdmFsdWUgaW4gdGhlIG1hcC5cbiAqXG4gKiBAdGhyb3dzIHtAbGluayBWYWx1ZUVycm9yfSBpZiBjb252ZXJzaW9uIG9mIGFueSB2YWx1ZSBpbiB0aGUgbWFwIGZhaWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1BheWxvYWRzPEsgZXh0ZW5kcyBzdHJpbmc+KGNvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlciwgbWFwOiBSZWNvcmQ8SywgYW55Pik6IFJlY29yZDxLLCBQYXlsb2FkPiB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMobWFwKS5tYXAoKFtrLCB2XSk6IFtLLCBQYXlsb2FkXSA9PiBbayBhcyBLLCBjb252ZXJ0ZXIudG9QYXlsb2FkKHYpXSlcbiAgKSBhcyBSZWNvcmQ8SywgUGF5bG9hZD47XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBjb252ZXJzaW9uIG9mIGFuIGFycmF5IG9mIHZhbHVlcyBvZiBkaWZmZXJlbnQgdHlwZXMuIFVzZWZ1bCBmb3IgZGVzZXJpYWxpemluZ1xuICogYXJndW1lbnRzIG9mIGZ1bmN0aW9uIGludm9jYXRpb25zLlxuICpcbiAqIEBwYXJhbSBjb252ZXJ0ZXJcbiAqIEBwYXJhbSBpbmRleCBpbmRleCBvZiB0aGUgdmFsdWUgaW4gdGhlIHBheWxvYWRzXG4gKiBAcGFyYW0gcGF5bG9hZHMgc2VyaWFsaXplZCB2YWx1ZSB0byBjb252ZXJ0IHRvIEpTIHZhbHVlcy5cbiAqIEByZXR1cm4gY29udmVydGVkIEpTIHZhbHVlXG4gKiBAdGhyb3dzIHtAbGluayBQYXlsb2FkQ29udmVydGVyRXJyb3J9IGlmIGNvbnZlcnNpb24gb2YgdGhlIGRhdGEgcGFzc2VkIGFzIHBhcmFtZXRlciBmYWlsZWQgZm9yIGFueVxuICogICAgIHJlYXNvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21QYXlsb2Fkc0F0SW5kZXg8VD4oY29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyLCBpbmRleDogbnVtYmVyLCBwYXlsb2Fkcz86IFBheWxvYWRbXSB8IG51bGwpOiBUIHtcbiAgLy8gVG8gbWFrZSBhZGRpbmcgYXJndW1lbnRzIGEgYmFja3dhcmRzIGNvbXBhdGlibGUgY2hhbmdlXG4gIGlmIChwYXlsb2FkcyA9PT0gdW5kZWZpbmVkIHx8IHBheWxvYWRzID09PSBudWxsIHx8IGluZGV4ID49IHBheWxvYWRzLmxlbmd0aCkge1xuICAgIHJldHVybiB1bmRlZmluZWQgYXMgYW55O1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZXIuZnJvbVBheWxvYWQocGF5bG9hZHNbaW5kZXhdKTtcbn1cblxuLyoqXG4gKiBSdW4ge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXIuZnJvbVBheWxvYWR9IG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlGcm9tUGF5bG9hZHMoY29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyLCBwYXlsb2Fkcz86IFBheWxvYWRbXSB8IG51bGwpOiB1bmtub3duW10ge1xuICBpZiAoIXBheWxvYWRzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBwYXlsb2Fkcy5tYXAoKHBheWxvYWQ6IFBheWxvYWQpID0+IGNvbnZlcnRlci5mcm9tUGF5bG9hZChwYXlsb2FkKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBGcm9tUGF5bG9hZHM8SyBleHRlbmRzIHN0cmluZz4oXG4gIGNvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcixcbiAgbWFwPzogUmVjb3JkPEssIFBheWxvYWQ+IHwgbnVsbCB8IHVuZGVmaW5lZFxuKTogUmVjb3JkPEssIHVua25vd24+IHwgdW5kZWZpbmVkIHwgbnVsbCB7XG4gIGlmIChtYXAgPT0gbnVsbCkgcmV0dXJuIG1hcDtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhtYXApLm1hcCgoW2ssIHBheWxvYWRdKTogW0ssIHVua25vd25dID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY29udmVydGVyLmZyb21QYXlsb2FkKHBheWxvYWQgYXMgUGF5bG9hZCk7XG4gICAgICByZXR1cm4gW2sgYXMgSywgdmFsdWVdO1xuICAgIH0pXG4gICkgYXMgUmVjb3JkPEssIHVua25vd24+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2Rpbmcge1xuICAvKipcbiAgICogQ29udmVydHMgYSB2YWx1ZSB0byBhIHtAbGluayBQYXlsb2FkfS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LiBFeGFtcGxlIHZhbHVlcyBpbmNsdWRlIHRoZSBXb3JrZmxvdyBhcmdzIHNlbnQgZnJvbSB0aGUgQ2xpZW50IGFuZCB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IGEgV29ya2Zsb3cgb3IgQWN0aXZpdHkuXG4gICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgUGF5bG9hZH0sIG9yIGB1bmRlZmluZWRgIGlmIHVuYWJsZSB0byBjb252ZXJ0LlxuICAgKi9cbiAgdG9QYXlsb2FkPFQ+KHZhbHVlOiBUKTogUGF5bG9hZCB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQ29udmVydHMgYSB7QGxpbmsgUGF5bG9hZH0gYmFjayB0byBhIHZhbHVlLlxuICAgKi9cbiAgZnJvbVBheWxvYWQ8VD4ocGF5bG9hZDogUGF5bG9hZCk6IFQ7XG5cbiAgcmVhZG9ubHkgZW5jb2RpbmdUeXBlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVHJpZXMgdG8gY29udmVydCB2YWx1ZXMgdG8ge0BsaW5rIFBheWxvYWR9cyB1c2luZyB0aGUge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2Rpbmd9cyBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IsIGluIHRoZSBvcmRlciBwcm92aWRlZC5cbiAqXG4gKiBDb252ZXJ0cyBQYXlsb2FkcyB0byB2YWx1ZXMgYmFzZWQgb24gdGhlIGBQYXlsb2FkLm1ldGFkYXRhLmVuY29kaW5nYCBmaWVsZCwgd2hpY2ggbWF0Y2hlcyB0aGUge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2RpbmcuZW5jb2RpbmdUeXBlfVxuICogb2YgdGhlIGNvbnZlcnRlciB0aGF0IGNyZWF0ZWQgdGhlIFBheWxvYWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21wb3NpdGVQYXlsb2FkQ29udmVydGVyIGltcGxlbWVudHMgUGF5bG9hZENvbnZlcnRlciB7XG4gIHJlYWRvbmx5IGNvbnZlcnRlcnM6IFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2RpbmdbXTtcbiAgcmVhZG9ubHkgY29udmVydGVyQnlFbmNvZGluZzogTWFwPHN0cmluZywgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZz4gPSBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IoLi4uY29udmVydGVyczogUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZ1tdKSB7XG4gICAgaWYgKGNvbnZlcnRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgUGF5bG9hZENvbnZlcnRlckVycm9yKCdNdXN0IHByb3ZpZGUgYXQgbGVhc3Qgb25lIFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2RpbmcnKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnZlcnRlcnMgPSBjb252ZXJ0ZXJzO1xuICAgIGZvciAoY29uc3QgY29udmVydGVyIG9mIGNvbnZlcnRlcnMpIHtcbiAgICAgIHRoaXMuY29udmVydGVyQnlFbmNvZGluZy5zZXQoY29udmVydGVyLmVuY29kaW5nVHlwZSwgY29udmVydGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpZXMgdG8gcnVuIGAudG9QYXlsb2FkKHZhbHVlKWAgb24gZWFjaCBjb252ZXJ0ZXIgaW4gdGhlIG9yZGVyIHByb3ZpZGVkIGF0IGNvbnN0cnVjdGlvbi5cbiAgICogUmV0dXJucyB0aGUgZmlyc3Qgc3VjY2Vzc2Z1bCByZXN1bHQsIHRocm93cyB7QGxpbmsgVmFsdWVFcnJvcn0gaWYgdGhlcmUgaXMgbm8gY29udmVydGVyIHRoYXQgY2FuIGhhbmRsZSB0aGUgdmFsdWUuXG4gICAqL1xuICBwdWJsaWMgdG9QYXlsb2FkPFQ+KHZhbHVlOiBUKTogUGF5bG9hZCB7XG4gICAgZm9yIChjb25zdCBjb252ZXJ0ZXIgb2YgdGhpcy5jb252ZXJ0ZXJzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjb252ZXJ0ZXIudG9QYXlsb2FkKHZhbHVlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBVbmFibGUgdG8gY29udmVydCAke3ZhbHVlfSB0byBwYXlsb2FkYCk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIHtAbGluayBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nLmZyb21QYXlsb2FkfSBiYXNlZCBvbiB0aGUgYGVuY29kaW5nYCBtZXRhZGF0YSBvZiB0aGUge0BsaW5rIFBheWxvYWR9LlxuICAgKi9cbiAgcHVibGljIGZyb21QYXlsb2FkPFQ+KHBheWxvYWQ6IFBheWxvYWQpOiBUIHtcbiAgICBpZiAocGF5bG9hZC5tZXRhZGF0YSA9PT0gdW5kZWZpbmVkIHx8IHBheWxvYWQubWV0YWRhdGEgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdNaXNzaW5nIHBheWxvYWQgbWV0YWRhdGEnKTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RpbmcgPSBkZWNvZGUocGF5bG9hZC5tZXRhZGF0YVtNRVRBREFUQV9FTkNPRElOR19LRVldKTtcbiAgICBjb25zdCBjb252ZXJ0ZXIgPSB0aGlzLmNvbnZlcnRlckJ5RW5jb2RpbmcuZ2V0KGVuY29kaW5nKTtcbiAgICBpZiAoY29udmVydGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBVbmtub3duIGVuY29kaW5nOiAke2VuY29kaW5nfWApO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVyLmZyb21QYXlsb2FkKHBheWxvYWQpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYmV0d2VlbiBKUyB1bmRlZmluZWQgYW5kIE5VTEwgUGF5bG9hZFxuICovXG5leHBvcnQgY2xhc3MgVW5kZWZpbmVkUGF5bG9hZENvbnZlcnRlciBpbXBsZW1lbnRzIFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2Rpbmcge1xuICBwdWJsaWMgZW5jb2RpbmdUeXBlID0gZW5jb2RpbmdUeXBlcy5NRVRBREFUQV9FTkNPRElOR19OVUxMO1xuXG4gIHB1YmxpYyB0b1BheWxvYWQodmFsdWU6IHVua25vd24pOiBQYXlsb2FkIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgW01FVEFEQVRBX0VOQ09ESU5HX0tFWV06IGVuY29kaW5nS2V5cy5NRVRBREFUQV9FTkNPRElOR19OVUxMLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGZyb21QYXlsb2FkPFQ+KF9jb250ZW50OiBQYXlsb2FkKTogVCB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCBhcyBhbnk7IC8vIEp1c3QgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYmV0d2VlbiBiaW5hcnkgZGF0YSB0eXBlcyBhbmQgUkFXIFBheWxvYWRcbiAqL1xuZXhwb3J0IGNsYXNzIEJpbmFyeVBheWxvYWRDb252ZXJ0ZXIgaW1wbGVtZW50cyBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nIHtcbiAgcHVibGljIGVuY29kaW5nVHlwZSA9IGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfUkFXO1xuXG4gIHB1YmxpYyB0b1BheWxvYWQodmFsdWU6IHVua25vd24pOiBQYXlsb2FkIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBbTUVUQURBVEFfRU5DT0RJTkdfS0VZXTogZW5jb2RpbmdLZXlzLk1FVEFEQVRBX0VOQ09ESU5HX1JBVyxcbiAgICAgIH0sXG4gICAgICBkYXRhOiB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGZyb21QYXlsb2FkPFQ+KGNvbnRlbnQ6IFBheWxvYWQpOiBUIHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gV3JhcCB3aXRoIFVpbnQ4QXJyYXkgZnJvbSB0aGlzIGNvbnRleHQgdG8gZW5zdXJlIGBpbnN0YW5jZW9mYCB3b3Jrc1xuICAgICAgKFxuICAgICAgICBjb250ZW50LmRhdGEgPyBuZXcgVWludDhBcnJheShjb250ZW50LmRhdGEuYnVmZmVyLCBjb250ZW50LmRhdGEuYnl0ZU9mZnNldCwgY29udGVudC5kYXRhLmxlbmd0aCkgOiBjb250ZW50LmRhdGFcbiAgICAgICkgYXMgYW55XG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGJldHdlZW4gbm9uLXVuZGVmaW5lZCB2YWx1ZXMgYW5kIHNlcmlhbGl6ZWQgSlNPTiBQYXlsb2FkXG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uUGF5bG9hZENvbnZlcnRlciBpbXBsZW1lbnRzIFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2Rpbmcge1xuICBwdWJsaWMgZW5jb2RpbmdUeXBlID0gZW5jb2RpbmdUeXBlcy5NRVRBREFUQV9FTkNPRElOR19KU09OO1xuXG4gIHB1YmxpYyB0b1BheWxvYWQodmFsdWU6IHVua25vd24pOiBQYXlsb2FkIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIFtNRVRBREFUQV9FTkNPRElOR19LRVldOiBlbmNvZGluZ0tleXMuTUVUQURBVEFfRU5DT0RJTkdfSlNPTixcbiAgICAgIH0sXG4gICAgICBkYXRhOiBlbmNvZGUoanNvbiksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBmcm9tUGF5bG9hZDxUPihjb250ZW50OiBQYXlsb2FkKTogVCB7XG4gICAgaWYgKGNvbnRlbnQuZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGNvbnRlbnQuZGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ0dvdCBwYXlsb2FkIHdpdGggbm8gZGF0YScpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGUoY29udGVudC5kYXRhKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBTZWFyY2ggQXR0cmlidXRlIHZhbHVlcyB1c2luZyBKc29uUGF5bG9hZENvbnZlcnRlclxuICovXG5leHBvcnQgY2xhc3MgU2VhcmNoQXR0cmlidXRlUGF5bG9hZENvbnZlcnRlciBpbXBsZW1lbnRzIFBheWxvYWRDb252ZXJ0ZXIge1xuICBqc29uQ29udmVydGVyID0gbmV3IEpzb25QYXlsb2FkQ29udmVydGVyKCk7XG4gIHZhbGlkTm9uRGF0ZVR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcblxuICBwdWJsaWMgdG9QYXlsb2FkKHZhbHVlczogdW5rbm93bik6IFBheWxvYWQge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgU2VhcmNoQXR0cmlidXRlIHZhbHVlIG11c3QgYmUgYW4gYXJyYXlgKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZpcnN0VmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICBjb25zdCBmaXJzdFR5cGUgPSB0eXBlb2YgZmlyc3RWYWx1ZTtcbiAgICAgIGlmIChmaXJzdFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2lkeCwgdmFsdWVdIG9mIHZhbHVlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgYFNlYXJjaEF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBhcnJheXMgb2Ygc3RyaW5ncywgbnVtYmVycywgYm9vbGVhbnMsIG9yIERhdGVzLiBUaGUgdmFsdWUgJHt2YWx1ZX0gYXQgaW5kZXggJHtpZHh9IGlzIG9mIHR5cGUgJHt0eXBlb2YgdmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZE5vbkRhdGVUeXBlcy5pbmNsdWRlcyhmaXJzdFR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYFNlYXJjaEF0dHJpYnV0ZSBhcnJheSB2YWx1ZXMgbXVzdCBiZTogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGVgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2lkeCwgdmFsdWVdIG9mIHZhbHVlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBmaXJzdFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICBgQWxsIFNlYXJjaEF0dHJpYnV0ZSBhcnJheSB2YWx1ZXMgbXVzdCBiZSBvZiB0aGUgc2FtZSB0eXBlLiBUaGUgZmlyc3QgdmFsdWUgJHtmaXJzdFZhbHVlfSBvZiB0eXBlICR7Zmlyc3RUeXBlfSBkb2Vzbid0IG1hdGNoIHZhbHVlICR7dmFsdWV9IG9mIHR5cGUgJHt0eXBlb2YgdmFsdWV9IGF0IGluZGV4ICR7aWR4fWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSlNPTi5zdHJpbmdpZnkgdGFrZXMgY2FyZSBvZiBjb252ZXJ0aW5nIERhdGVzIHRvIElTTyBzdHJpbmdzXG4gICAgY29uc3QgcmV0ID0gdGhpcy5qc29uQ29udmVydGVyLnRvUGF5bG9hZCh2YWx1ZXMpO1xuICAgIGlmIChyZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHNlYXJjaCBhdHRyaWJ1dGVzIHRvIHBheWxvYWRzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogRGF0ZXRpbWUgU2VhcmNoIEF0dHJpYnV0ZSB2YWx1ZXMgYXJlIGNvbnZlcnRlZCB0byBgRGF0ZWBzXG4gICAqL1xuICBwdWJsaWMgZnJvbVBheWxvYWQ8VD4ocGF5bG9hZDogUGF5bG9hZCk6IFQge1xuICAgIGlmIChwYXlsb2FkLm1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgcGF5bG9hZC5tZXRhZGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ01pc3NpbmcgcGF5bG9hZCBtZXRhZGF0YScpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5qc29uQ29udmVydGVyLmZyb21QYXlsb2FkKHBheWxvYWQpO1xuICAgIGxldCBhcnJheVdyYXBwZWRWYWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuXG4gICAgY29uc3Qgc2VhcmNoQXR0cmlidXRlVHlwZSA9IGRlY29kZShwYXlsb2FkLm1ldGFkYXRhLnR5cGUpO1xuICAgIGlmIChzZWFyY2hBdHRyaWJ1dGVUeXBlID09PSAnRGF0ZXRpbWUnKSB7XG4gICAgICBhcnJheVdyYXBwZWRWYWx1ZSA9IGFycmF5V3JhcHBlZFZhbHVlLm1hcCgoZGF0ZVN0cmluZykgPT4gbmV3IERhdGUoZGF0ZVN0cmluZykpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlXcmFwcGVkVmFsdWUgYXMgdW5rbm93biBhcyBUO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWFyY2hBdHRyaWJ1dGVQYXlsb2FkQ29udmVydGVyID0gbmV3IFNlYXJjaEF0dHJpYnV0ZVBheWxvYWRDb252ZXJ0ZXIoKTtcblxuZXhwb3J0IGNsYXNzIERlZmF1bHRQYXlsb2FkQ29udmVydGVyIGV4dGVuZHMgQ29tcG9zaXRlUGF5bG9hZENvbnZlcnRlciB7XG4gIC8vIE1hdGNoIHRoZSBvcmRlciB1c2VkIGluIG90aGVyIFNES3MsIGJ1dCBleGNsdWRlIFByb3RvYnVmIGNvbnZlcnRlcnMgc28gdGhhdCB0aGUgY29kZSwgaW5jbHVkaW5nXG4gIC8vIGBwcm90bzMtanNvbi1zZXJpYWxpemVyYCwgZG9lc24ndCB0YWtlIHNwYWNlIGluIFdvcmtmbG93IGJ1bmRsZXMgdGhhdCBkb24ndCB1c2UgUHJvdG9idWZzLiBUbyB1c2UgUHJvdG9idWZzLCB1c2VcbiAgLy8ge0BsaW5rIERlZmF1bHRQYXlsb2FkQ29udmVydGVyV2l0aFByb3RvYnVmc30uXG4gIC8vXG4gIC8vIEdvIFNESzpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RlbXBvcmFsaW8vc2RrLWdvL2Jsb2IvNWU1NjQ1ZjBjNTUwZGNmNzE3YzA5NWFlMzJjNzZhNzA4N2QyZTk4NS9jb252ZXJ0ZXIvZGVmYXVsdF9kYXRhX2NvbnZlcnRlci5nbyNMMjhcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIobmV3IFVuZGVmaW5lZFBheWxvYWRDb252ZXJ0ZXIoKSwgbmV3IEJpbmFyeVBheWxvYWRDb252ZXJ0ZXIoKSwgbmV3IEpzb25QYXlsb2FkQ29udmVydGVyKCkpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJ9IHVzZWQgYnkgdGhlIFNESy4gU3VwcG9ydHMgYFVpbnQ4QXJyYXlgIGFuZCBKU09OIHNlcmlhbGl6YWJsZXMgKHNvIGlmXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9zdHJpbmdpZnkjZGVzY3JpcHRpb24gfCBgSlNPTi5zdHJpbmdpZnkoeW91ckFyZ09yUmV0dmFsKWB9XG4gKiB3b3JrcywgdGhlIGRlZmF1bHQgcGF5bG9hZCBjb252ZXJ0ZXIgd2lsbCB3b3JrKS5cbiAqXG4gKiBUbyBhbHNvIHN1cHBvcnQgUHJvdG9idWZzLCBjcmVhdGUgYSBjdXN0b20gcGF5bG9hZCBjb252ZXJ0ZXIgd2l0aCB7QGxpbmsgRGVmYXVsdFBheWxvYWRDb252ZXJ0ZXJ9OlxuICpcbiAqIGBjb25zdCBteUNvbnZlcnRlciA9IG5ldyBEZWZhdWx0UGF5bG9hZENvbnZlcnRlcih7IHByb3RvYnVmUm9vdCB9KWBcbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRQYXlsb2FkQ29udmVydGVyID0gbmV3IERlZmF1bHRQYXlsb2FkQ29udmVydGVyKCk7XG4iLCJpbXBvcnQgeyBlbmNvZGUgfSBmcm9tICcuLi9lbmNvZGluZyc7XG5cbmV4cG9ydCBjb25zdCBNRVRBREFUQV9FTkNPRElOR19LRVkgPSAnZW5jb2RpbmcnO1xuZXhwb3J0IGNvbnN0IGVuY29kaW5nVHlwZXMgPSB7XG4gIE1FVEFEQVRBX0VOQ09ESU5HX05VTEw6ICdiaW5hcnkvbnVsbCcsXG4gIE1FVEFEQVRBX0VOQ09ESU5HX1JBVzogJ2JpbmFyeS9wbGFpbicsXG4gIE1FVEFEQVRBX0VOQ09ESU5HX0pTT046ICdqc29uL3BsYWluJyxcbiAgTUVUQURBVEFfRU5DT0RJTkdfUFJPVE9CVUZfSlNPTjogJ2pzb24vcHJvdG9idWYnLFxuICBNRVRBREFUQV9FTkNPRElOR19QUk9UT0JVRjogJ2JpbmFyeS9wcm90b2J1ZicsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgRW5jb2RpbmdUeXBlID0gKHR5cGVvZiBlbmNvZGluZ1R5cGVzKVtrZXlvZiB0eXBlb2YgZW5jb2RpbmdUeXBlc107XG5cbmV4cG9ydCBjb25zdCBlbmNvZGluZ0tleXMgPSB7XG4gIE1FVEFEQVRBX0VOQ09ESU5HX05VTEw6IGVuY29kZShlbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX05VTEwpLFxuICBNRVRBREFUQV9FTkNPRElOR19SQVc6IGVuY29kZShlbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX1JBVyksXG4gIE1FVEFEQVRBX0VOQ09ESU5HX0pTT046IGVuY29kZShlbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX0pTT04pLFxuICBNRVRBREFUQV9FTkNPRElOR19QUk9UT0JVRl9KU09OOiBlbmNvZGUoZW5jb2RpbmdUeXBlcy5NRVRBREFUQV9FTkNPRElOR19QUk9UT0JVRl9KU09OKSxcbiAgTUVUQURBVEFfRU5DT0RJTkdfUFJPVE9CVUY6IGVuY29kZShlbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGKSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBNRVRBREFUQV9NRVNTQUdFX1RZUEVfS0VZID0gJ21lc3NhZ2VUeXBlJztcbiIsImltcG9ydCAqIGFzIHRpbWUgZnJvbSAnLi90aW1lJztcbmltcG9ydCB7IHR5cGUgVGltZXN0YW1wLCBEdXJhdGlvbiB9IGZyb20gJy4vdGltZSc7XG5cbi8qKlxuICogTG9zc3kgY29udmVyc2lvbiBmdW5jdGlvbiBmcm9tIFRpbWVzdGFtcCB0byBudW1iZXIgZHVlIHRvIHBvc3NpYmxlIG92ZXJmbG93LlxuICogSWYgdHMgaXMgbnVsbCBvciB1bmRlZmluZWQgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsVHNUb01zKHRzOiBUaW1lc3RhbXAgfCBudWxsIHwgdW5kZWZpbmVkKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHRpbWUub3B0aW9uYWxUc1RvTXModHMpO1xufVxuXG4vKipcbiAqIExvc3N5IGNvbnZlcnNpb24gZnVuY3Rpb24gZnJvbSBUaW1lc3RhbXAgdG8gbnVtYmVyIGR1ZSB0byBwb3NzaWJsZSBvdmVyZmxvd1xuICpcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHNUb01zKHRzOiBUaW1lc3RhbXAgfCBudWxsIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgcmV0dXJuIHRpbWUudHNUb01zKHRzKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXNOdW1iZXJUb1RzKG1pbGxpczogbnVtYmVyKTogVGltZXN0YW1wIHtcbiAgcmV0dXJuIHRpbWUubXNOdW1iZXJUb1RzKG1pbGxpcyk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1zVG9UcyhzdHI6IER1cmF0aW9uKTogVGltZXN0YW1wIHtcbiAgcmV0dXJuIHRpbWUubXNUb1RzKHN0cik7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1zT3B0aW9uYWxUb1RzKHN0cjogRHVyYXRpb24gfCB1bmRlZmluZWQpOiBUaW1lc3RhbXAgfCB1bmRlZmluZWQge1xuICByZXR1cm4gdGltZS5tc09wdGlvbmFsVG9UcyhzdHIpO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtc09wdGlvbmFsVG9OdW1iZXIodmFsOiBEdXJhdGlvbiB8IHVuZGVmaW5lZCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB0aW1lLm1zT3B0aW9uYWxUb051bWJlcih2YWwpO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtc1RvTnVtYmVyKHZhbDogRHVyYXRpb24pOiBudW1iZXIge1xuICByZXR1cm4gdGltZS5tc1RvTnVtYmVyKHZhbCk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRzVG9EYXRlKHRzOiBUaW1lc3RhbXApOiBEYXRlIHtcbiAgcmV0dXJuIHRpbWUudHNUb0RhdGUodHMpO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25hbFRzVG9EYXRlKHRzOiBUaW1lc3RhbXAgfCBudWxsIHwgdW5kZWZpbmVkKTogRGF0ZSB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB0aW1lLm9wdGlvbmFsVHNUb0RhdGUodHMpO1xufVxuIiwiLy8gUGFzdGVkIHdpdGggbW9kaWZpY2F0aW9ucyBmcm9tOiBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYW5vbnljby9GYXN0ZXN0U21hbGxlc3RUZXh0RW5jb2RlckRlY29kZXIvbWFzdGVyL0VuY29kZXJEZWNvZGVyVG9nZXRoZXIuc3JjLmpzXG4vKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IDAgKi9cblxuY29uc3QgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbmNvbnN0IGVuY29kZXJSZWdleHAgPSAvW1xceDgwLVxcdUQ3ZmZcXHVEQzAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0/L2c7XG5jb25zdCB0bXBCdWZmZXJVMTYgPSBuZXcgVWludDE2QXJyYXkoMzIpO1xuXG5leHBvcnQgY2xhc3MgVGV4dERlY29kZXIge1xuICBkZWNvZGUoaW5wdXRBcnJheU9yQnVmZmVyOiBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIgfCBTaGFyZWRBcnJheUJ1ZmZlcik6IHN0cmluZyB7XG4gICAgY29uc3QgaW5wdXRBczggPSBpbnB1dEFycmF5T3JCdWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gaW5wdXRBcnJheU9yQnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoaW5wdXRBcnJheU9yQnVmZmVyKTtcblxuICAgIGxldCByZXN1bHRpbmdTdHJpbmcgPSAnJyxcbiAgICAgIHRtcFN0ciA9ICcnLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbmV4dEVuZCA9IDAsXG4gICAgICBjcDAgPSAwLFxuICAgICAgY29kZVBvaW50ID0gMCxcbiAgICAgIG1pbkJpdHMgPSAwLFxuICAgICAgY3AxID0gMCxcbiAgICAgIHBvcyA9IDAsXG4gICAgICB0bXAgPSAtMTtcbiAgICBjb25zdCBsZW4gPSBpbnB1dEFzOC5sZW5ndGggfCAwO1xuICAgIGNvbnN0IGxlbk1pbnVzMzIgPSAobGVuIC0gMzIpIHwgMDtcbiAgICAvLyBOb3RlIHRoYXQgdG1wIHJlcHJlc2VudHMgdGhlIDJuZCBoYWxmIG9mIGEgc3Vycm9nYXRlIHBhaXIgaW5jYXNlIGEgc3Vycm9nYXRlIGdldHMgZGl2aWRlZCBiZXR3ZWVuIGJsb2Nrc1xuICAgIGZvciAoOyBpbmRleCA8IGxlbjsgKSB7XG4gICAgICBuZXh0RW5kID0gaW5kZXggPD0gbGVuTWludXMzMiA/IDMyIDogKGxlbiAtIGluZGV4KSB8IDA7XG4gICAgICBmb3IgKDsgcG9zIDwgbmV4dEVuZDsgaW5kZXggPSAoaW5kZXggKyAxKSB8IDAsIHBvcyA9IChwb3MgKyAxKSB8IDApIHtcbiAgICAgICAgY3AwID0gaW5wdXRBczhbaW5kZXhdICYgMHhmZjtcbiAgICAgICAgc3dpdGNoIChjcDAgPj4gNCkge1xuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBjcDEgPSBpbnB1dEFzOFsoaW5kZXggPSAoaW5kZXggKyAxKSB8IDApXSAmIDB4ZmY7XG4gICAgICAgICAgICBpZiAoY3AxID4+IDYgIT09IDBiMTAgfHwgMGIxMTExMDExMSA8IGNwMCkge1xuICAgICAgICAgICAgICBpbmRleCA9IChpbmRleCAtIDEpIHwgMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSAoKGNwMCAmIDBiMTExKSA8PCA2KSB8IChjcDEgJiAwYjAwMTExMTExKTtcbiAgICAgICAgICAgIG1pbkJpdHMgPSA1OyAvLyAyMCBlbnN1cmVzIGl0IG5ldmVyIHBhc3NlcyAtPiBhbGwgaW52YWxpZCByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIGNwMCA9IDB4MTAwOyAvLyAga2VlcCB0cmFjayBvZiB0aCBiaXQgc2l6ZVxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBjcDEgPSBpbnB1dEFzOFsoaW5kZXggPSAoaW5kZXggKyAxKSB8IDApXSAmIDB4ZmY7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPDw9IDY7XG4gICAgICAgICAgICBjb2RlUG9pbnQgfD0gKChjcDAgJiAwYjExMTEpIDw8IDYpIHwgKGNwMSAmIDBiMDAxMTExMTEpO1xuICAgICAgICAgICAgbWluQml0cyA9IGNwMSA+PiA2ID09PSAwYjEwID8gKG1pbkJpdHMgKyA0KSB8IDAgOiAyNDsgLy8gMjQgZW5zdXJlcyBpdCBuZXZlciBwYXNzZXMgLT4gYWxsIGludmFsaWQgcmVwbGFjZW1lbnRzXG4gICAgICAgICAgICBjcDAgPSAoY3AwICsgMHgxMDApICYgMHgzMDA7IC8vIGtlZXAgdHJhY2sgb2YgdGggYml0IHNpemVcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBjcDEgPSBpbnB1dEFzOFsoaW5kZXggPSAoaW5kZXggKyAxKSB8IDApXSAmIDB4ZmY7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPDw9IDY7XG4gICAgICAgICAgICBjb2RlUG9pbnQgfD0gKChjcDAgJiAwYjExMTExKSA8PCA2KSB8IChjcDEgJiAwYjAwMTExMTExKTtcbiAgICAgICAgICAgIG1pbkJpdHMgPSAobWluQml0cyArIDcpIHwgMDtcblxuICAgICAgICAgICAgLy8gTm93LCBwcm9jZXNzIHRoZSBjb2RlIHBvaW50XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsZW4gJiYgY3AxID4+IDYgPT09IDBiMTAgJiYgY29kZVBvaW50ID4+IG1pbkJpdHMgJiYgY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY3AwID0gY29kZVBvaW50O1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAoY29kZVBvaW50IC0gMHgxMDAwMCkgfCAwO1xuICAgICAgICAgICAgICBpZiAoMCA8PSBjb2RlUG9pbnQgLyoweGZmZmYgPCBjb2RlUG9pbnQqLykge1xuICAgICAgICAgICAgICAgIC8vIEJNUCBjb2RlIHBvaW50XG4gICAgICAgICAgICAgICAgLy9uZXh0RW5kID0gbmV4dEVuZCAtIDF8MDtcblxuICAgICAgICAgICAgICAgIHRtcCA9ICgoY29kZVBvaW50ID4+IDEwKSArIDB4ZDgwMCkgfCAwOyAvLyBoaWdoU3Vycm9nYXRlXG4gICAgICAgICAgICAgICAgY3AwID0gKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApIHwgMDsgLy8gbG93U3Vycm9nYXRlICh3aWxsIGJlIGluc2VydGVkIGxhdGVyIGluIHRoZSBzd2l0Y2gtc3RhdGVtZW50KVxuXG4gICAgICAgICAgICAgICAgaWYgKHBvcyA8IDMxKSB7XG4gICAgICAgICAgICAgICAgICAvLyBub3RpY2UgMzEgaW5zdGVhZCBvZiAzMlxuICAgICAgICAgICAgICAgICAgdG1wQnVmZmVyVTE2W3Bvc10gPSB0bXA7XG4gICAgICAgICAgICAgICAgICBwb3MgPSAocG9zICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgICAgdG1wID0gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVsc2UsIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dEFzOCBhbmQgbGV0IHRtcDAgYmUgZmlsbGVkIGluIGxhdGVyIG9uXG4gICAgICAgICAgICAgICAgICAvLyBOT1RFIHRoYXQgY3AxIGlzIGJlaW5nIHVzZWQgYXMgYSB0ZW1wb3JhcnkgdmFyaWFibGUgZm9yIHRoZSBzd2FwcGluZyBvZiB0bXAgd2l0aCBjcDBcbiAgICAgICAgICAgICAgICAgIGNwMSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgIHRtcCA9IGNwMDtcbiAgICAgICAgICAgICAgICAgIGNwMCA9IGNwMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBuZXh0RW5kID0gKG5leHRFbmQgKyAxKSB8IDA7IC8vIGJlY2F1c2Ugd2UgYXJlIGFkdmFuY2luZyBpIHdpdGhvdXQgYWR2YW5jaW5nIHBvc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaW52YWxpZCBjb2RlIHBvaW50IG1lYW5zIHJlcGxhY2luZyB0aGUgd2hvbGUgdGhpbmcgd2l0aCBudWxsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgY3AwID4+PSA4O1xuICAgICAgICAgICAgICBpbmRleCA9IChpbmRleCAtIGNwMCAtIDEpIHwgMDsgLy8gcmVzZXQgaW5kZXggIGJhY2sgdG8gd2hhdCBpdCB3YXMgYmVmb3JlXG4gICAgICAgICAgICAgIGNwMCA9IDB4ZmZmZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluYWxseSwgcmVzZXQgdGhlIHZhcmlhYmxlcyBmb3IgdGhlIG5leHQgZ28tYXJvdW5kXG4gICAgICAgICAgICBtaW5CaXRzID0gMDtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IDA7XG4gICAgICAgICAgICBuZXh0RW5kID0gaW5kZXggPD0gbGVuTWludXMzMiA/IDMyIDogKGxlbiAtIGluZGV4KSB8IDA7XG4gICAgICAgICAgLypjYXNlIDExOlxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjb2RlUG9pbnQgPyBjb2RlUG9pbnQgPSAwIDogY3AwID0gMHhmZmZkOyAvLyBmaWxsIHdpdGggaW52YWxpZCByZXBsYWNlbWVudCBjaGFyYWN0ZXJcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICBjYXNlIDY6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgdG1wQnVmZmVyVTE2W3Bvc10gPSBjcDA7XG4gICAgICAgICAgY29udGludWU7Ki9cbiAgICAgICAgICBkZWZhdWx0OiAvLyBmaWxsIHdpdGggaW52YWxpZCByZXBsYWNlbWVudCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHRtcEJ1ZmZlclUxNltwb3NdID0gY3AwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgIH1cbiAgICAgICAgdG1wQnVmZmVyVTE2W3Bvc10gPSAweGZmZmQ7IC8vIGZpbGwgd2l0aCBpbnZhbGlkIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuICAgICAgfVxuICAgICAgdG1wU3RyICs9IGZyb21DaGFyQ29kZShcbiAgICAgICAgdG1wQnVmZmVyVTE2WzBdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyXSxcbiAgICAgICAgdG1wQnVmZmVyVTE2WzNdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbNF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNls1XSxcbiAgICAgICAgdG1wQnVmZmVyVTE2WzZdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbN10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNls4XSxcbiAgICAgICAgdG1wQnVmZmVyVTE2WzldLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMTBdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMTFdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMTJdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMTNdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMTRdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMTVdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMTZdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMTddLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMThdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMTldLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMjBdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMjFdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMjJdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMjNdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMjRdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMjVdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMjZdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMjddLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMjhdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMjldLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMzBdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbMzFdXG4gICAgICApO1xuICAgICAgaWYgKHBvcyA8IDMyKSB0bXBTdHIgPSB0bXBTdHIuc2xpY2UoMCwgKHBvcyAtIDMyKSB8IDApOyAvLy0oMzItcG9zKSk7XG4gICAgICBpZiAoaW5kZXggPCBsZW4pIHtcbiAgICAgICAgLy9mcm9tQ2hhckNvZGUuYXBwbHkoMCwgdG1wQnVmZmVyVTE2IDogVWludDhBcnJheSA/ICB0bXBCdWZmZXJVMTYuc3ViYXJyYXkoMCxwb3MpIDogdG1wQnVmZmVyVTE2LnNsaWNlKDAscG9zKSk7XG4gICAgICAgIHRtcEJ1ZmZlclUxNlswXSA9IHRtcDtcbiAgICAgICAgcG9zID0gfnRtcCA+Pj4gMzE7IC8vdG1wICE9PSAtMSA/IDEgOiAwO1xuICAgICAgICB0bXAgPSAtMTtcblxuICAgICAgICBpZiAodG1wU3RyLmxlbmd0aCA8IHJlc3VsdGluZ1N0cmluZy5sZW5ndGgpIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICh0bXAgIT09IC0xKSB7XG4gICAgICAgIHRtcFN0ciArPSBmcm9tQ2hhckNvZGUodG1wKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0aW5nU3RyaW5nICs9IHRtcFN0cjtcbiAgICAgIHRtcFN0ciA9ICcnO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdTdHJpbmc7XG4gIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGVuY29kZXJSZXBsYWNlcihub25Bc2NpaUNoYXJzOiBzdHJpbmcpIHtcbiAgLy8gbWFrZSB0aGUgVVRGIHN0cmluZyBpbnRvIGEgYmluYXJ5IFVURi04IGVuY29kZWQgc3RyaW5nXG4gIGxldCBwb2ludCA9IG5vbkFzY2lpQ2hhcnMuY2hhckNvZGVBdCgwKSB8IDA7XG4gIGlmICgweGQ4MDAgPD0gcG9pbnQpIHtcbiAgICBpZiAocG9pbnQgPD0gMHhkYmZmKSB7XG4gICAgICBjb25zdCBuZXh0Y29kZSA9IG5vbkFzY2lpQ2hhcnMuY2hhckNvZGVBdCgxKSB8IDA7IC8vIGRlZmF1bHRzIHRvIDAgd2hlbiBOYU4sIGNhdXNpbmcgbnVsbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJcblxuICAgICAgaWYgKDB4ZGMwMCA8PSBuZXh0Y29kZSAmJiBuZXh0Y29kZSA8PSAweGRmZmYpIHtcbiAgICAgICAgLy9wb2ludCA9ICgocG9pbnQgLSAweEQ4MDApPDwxMCkgKyBuZXh0Y29kZSAtIDB4REMwMCArIDB4MTAwMDB8MDtcbiAgICAgICAgcG9pbnQgPSAoKHBvaW50IDw8IDEwKSArIG5leHRjb2RlIC0gMHgzNWZkYzAwKSB8IDA7XG4gICAgICAgIGlmIChwb2ludCA+IDB4ZmZmZilcbiAgICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgKDB4MWUgLyowYjExMTEwKi8gPDwgMykgfCAocG9pbnQgPj4gMTgpLFxuICAgICAgICAgICAgKDB4MiAvKjBiMTAqLyA8PCA2KSB8ICgocG9pbnQgPj4gMTIpICYgMHgzZikgLyowYjAwMTExMTExKi8sXG4gICAgICAgICAgICAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiA2KSAmIDB4M2YpIC8qMGIwMDExMTExMSovLFxuICAgICAgICAgICAgKDB4MiAvKjBiMTAqLyA8PCA2KSB8IChwb2ludCAmIDB4M2YpIC8qMGIwMDExMTExMSovXG4gICAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBwb2ludCA9IDY1NTMzIC8qMGIxMTExMTExMTExMTExMTAxKi87IC8vcmV0dXJuICdcXHhFRlxceEJGXFx4QkQnOy8vZnJvbUNoYXJDb2RlKDB4ZWYsIDB4YmYsIDB4YmQpO1xuICAgIH0gZWxzZSBpZiAocG9pbnQgPD0gMHhkZmZmKSB7XG4gICAgICBwb2ludCA9IDY1NTMzIC8qMGIxMTExMTExMTExMTExMTAxKi87IC8vcmV0dXJuICdcXHhFRlxceEJGXFx4QkQnOy8vZnJvbUNoYXJDb2RlKDB4ZWYsIDB4YmYsIDB4YmQpO1xuICAgIH1cbiAgfVxuICAvKmlmIChwb2ludCA8PSAweDAwN2YpIHJldHVybiBub25Bc2NpaUNoYXJzO1xuICBlbHNlICovIGlmIChwb2ludCA8PSAweDA3ZmYpIHtcbiAgICByZXR1cm4gZnJvbUNoYXJDb2RlKCgweDYgPDwgNSkgfCAocG9pbnQgPj4gNiksICgweDIgPDwgNikgfCAocG9pbnQgJiAweDNmKSk7XG4gIH0gZWxzZVxuICAgIHJldHVybiBmcm9tQ2hhckNvZGUoXG4gICAgICAoMHhlIC8qMGIxMTEwKi8gPDwgNCkgfCAocG9pbnQgPj4gMTIpLFxuICAgICAgKDB4MiAvKjBiMTAqLyA8PCA2KSB8ICgocG9pbnQgPj4gNikgJiAweDNmKSAvKjBiMDAxMTExMTEqLyxcbiAgICAgICgweDIgLyowYjEwKi8gPDwgNikgfCAocG9pbnQgJiAweDNmKSAvKjBiMDAxMTExMTEqL1xuICAgICk7XG59XG5cbmV4cG9ydCBjbGFzcyBUZXh0RW5jb2RlciB7XG4gIHB1YmxpYyBlbmNvZGUoaW5wdXRTdHJpbmc6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICAgIC8vIDB4YzAgPT4gMGIxMTAwMDAwMDsgMHhmZiA9PiAwYjExMTExMTExOyAweGMwLTB4ZmYgPT4gMGIxMXh4eHh4eFxuICAgIC8vIDB4ODAgPT4gMGIxMDAwMDAwMDsgMHhiZiA9PiAwYjEwMTExMTExOyAweDgwLTB4YmYgPT4gMGIxMHh4eHh4eFxuICAgIGNvbnN0IGVuY29kZWRTdHJpbmcgPSBpbnB1dFN0cmluZyA9PT0gdm9pZCAwID8gJycgOiAnJyArIGlucHV0U3RyaW5nLFxuICAgICAgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGggfCAwO1xuICAgIGxldCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgoKGxlbiA8PCAxKSArIDgpIHwgMCk7XG4gICAgbGV0IHRtcFJlc3VsdDogVWludDhBcnJheTtcbiAgICBsZXQgaSA9IDAsXG4gICAgICBwb3MgPSAwLFxuICAgICAgcG9pbnQgPSAwLFxuICAgICAgbmV4dGNvZGUgPSAwO1xuICAgIGxldCB1cGdyYWRlZGVkQXJyYXlTaXplID0gIVVpbnQ4QXJyYXk7IC8vIG5vcm1hbCBhcnJheXMgYXJlIGF1dG8tZXhwYW5kaW5nXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSA9IChpICsgMSkgfCAwLCBwb3MgPSAocG9zICsgMSkgfCAwKSB7XG4gICAgICBwb2ludCA9IGVuY29kZWRTdHJpbmcuY2hhckNvZGVBdChpKSB8IDA7XG4gICAgICBpZiAocG9pbnQgPD0gMHgwMDdmKSB7XG4gICAgICAgIHJlc3VsdFtwb3NdID0gcG9pbnQ7XG4gICAgICB9IGVsc2UgaWYgKHBvaW50IDw9IDB4MDdmZikge1xuICAgICAgICByZXN1bHRbcG9zXSA9ICgweDYgPDwgNSkgfCAocG9pbnQgPj4gNik7XG4gICAgICAgIHJlc3VsdFsocG9zID0gKHBvcyArIDEpIHwgMCldID0gKDB4MiA8PCA2KSB8IChwb2ludCAmIDB4M2YpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkZW5DaGVjazoge1xuICAgICAgICAgIGlmICgweGQ4MDAgPD0gcG9pbnQpIHtcbiAgICAgICAgICAgIGlmIChwb2ludCA8PSAweGRiZmYpIHtcbiAgICAgICAgICAgICAgbmV4dGNvZGUgPSBlbmNvZGVkU3RyaW5nLmNoYXJDb2RlQXQoKGkgPSAoaSArIDEpIHwgMCkpIHwgMDsgLy8gZGVmYXVsdHMgdG8gMCB3aGVuIE5hTiwgY2F1c2luZyBudWxsIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuXG4gICAgICAgICAgICAgIGlmICgweGRjMDAgPD0gbmV4dGNvZGUgJiYgbmV4dGNvZGUgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgICAgLy9wb2ludCA9ICgocG9pbnQgLSAweEQ4MDApPDwxMCkgKyBuZXh0Y29kZSAtIDB4REMwMCArIDB4MTAwMDB8MDtcbiAgICAgICAgICAgICAgICBwb2ludCA9ICgocG9pbnQgPDwgMTApICsgbmV4dGNvZGUgLSAweDM1ZmRjMDApIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnQgPiAweGZmZmYpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFtwb3NdID0gKDB4MWUgLyowYjExMTEwKi8gPDwgMykgfCAocG9pbnQgPj4gMTgpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiAxMikgJiAweDNmKSAvKjBiMDAxMTExMTEqLztcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFsocG9zID0gKHBvcyArIDEpIHwgMCldID0gKDB4MiAvKjBiMTAqLyA8PCA2KSB8ICgocG9pbnQgPj4gNikgJiAweDNmKSAvKjBiMDAxMTExMTEqLztcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFsocG9zID0gKHBvcyArIDEpIHwgMCldID0gKDB4MiAvKjBiMTAqLyA8PCA2KSB8IChwb2ludCAmIDB4M2YpIC8qMGIwMDExMTExMSovO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrIHdpZGVuQ2hlY2s7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG9pbnQgPSA2NTUzMyAvKjBiMTExMTExMTExMTExMTEwMSovOyAvL3JldHVybiAnXFx4RUZcXHhCRlxceEJEJzsvL2Zyb21DaGFyQ29kZSgweGVmLCAweGJmLCAweGJkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnQgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgIHBvaW50ID0gNjU1MzMgLyowYjExMTExMTExMTExMTExMDEqLzsgLy9yZXR1cm4gJ1xceEVGXFx4QkZcXHhCRCc7Ly9mcm9tQ2hhckNvZGUoMHhlZiwgMHhiZiwgMHhiZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdXBncmFkZWRlZEFycmF5U2l6ZSAmJiBpIDw8IDEgPCBwb3MgJiYgaSA8PCAxIDwgKChwb3MgLSA3KSB8IDApKSB7XG4gICAgICAgICAgICB1cGdyYWRlZGVkQXJyYXlTaXplID0gdHJ1ZTtcbiAgICAgICAgICAgIHRtcFJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbiAqIDMpO1xuICAgICAgICAgICAgdG1wUmVzdWx0LnNldChyZXN1bHQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gdG1wUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcG9zXSA9ICgweGUgLyowYjExMTAqLyA8PCA0KSB8IChwb2ludCA+PiAxMik7XG4gICAgICAgIHJlc3VsdFsocG9zID0gKHBvcyArIDEpIHwgMCldID0gKDB4MiAvKjBiMTAqLyA8PCA2KSB8ICgocG9pbnQgPj4gNikgJiAweDNmKSAvKjBiMDAxMTExMTEqLztcbiAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKHBvaW50ICYgMHgzZikgLyowYjAwMTExMTExKi87XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBVaW50OEFycmF5ID8gcmVzdWx0LnN1YmFycmF5KDAsIHBvcykgOiByZXN1bHQuc2xpY2UoMCwgcG9zKTtcbiAgfVxuXG4gIHB1YmxpYyBlbmNvZGVJbnRvKGlucHV0U3RyaW5nOiBzdHJpbmcsIHU4QXJyOiBVaW50OEFycmF5KTogeyB3cml0dGVuOiBudW1iZXI7IHJlYWQ6IG51bWJlciB9IHtcbiAgICBjb25zdCBlbmNvZGVkU3RyaW5nID0gaW5wdXRTdHJpbmcgPT09IHZvaWQgMCA/ICcnIDogKCcnICsgaW5wdXRTdHJpbmcpLnJlcGxhY2UoZW5jb2RlclJlZ2V4cCwgZW5jb2RlclJlcGxhY2VyKTtcbiAgICBsZXQgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGggfCAwLFxuICAgICAgaSA9IDAsXG4gICAgICBjaGFyID0gMCxcbiAgICAgIHJlYWQgPSAwO1xuICAgIGNvbnN0IHU4QXJyTGVuID0gdThBcnIubGVuZ3RoIHwgMDtcbiAgICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0U3RyaW5nLmxlbmd0aCB8IDA7XG4gICAgaWYgKHU4QXJyTGVuIDwgbGVuKSBsZW4gPSB1OEFyckxlbjtcbiAgICBwdXRDaGFyczoge1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkgPSAoaSArIDEpIHwgMCkge1xuICAgICAgICBjaGFyID0gZW5jb2RlZFN0cmluZy5jaGFyQ29kZUF0KGkpIHwgMDtcbiAgICAgICAgc3dpdGNoIChjaGFyID4+IDQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmVhZCA9IChyZWFkICsgMSkgfCAwO1xuICAgICAgICAgIC8vIGV4dGVuc2lvbiBwb2ludHM6XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBpZiAoKChpICsgMSkgfCAwKSA8IHU4QXJyTGVuKSB7XG4gICAgICAgICAgICAgIHJlYWQgPSAocmVhZCArIDEpIHwgMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIGlmICgoKGkgKyAyKSB8IDApIDwgdThBcnJMZW4pIHtcbiAgICAgICAgICAgICAgLy9pZiAoIShjaGFyID09PSAweEVGICYmIGVuY29kZWRTdHJpbmcuc3Vic3RyKGkrMXwwLDIpID09PSBcIlxceEJGXFx4QkRcIikpXG4gICAgICAgICAgICAgIHJlYWQgPSAocmVhZCArIDEpIHwgMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGlmICgoKGkgKyAzKSB8IDApIDwgdThBcnJMZW4pIHtcbiAgICAgICAgICAgICAgcmVhZCA9IChyZWFkICsgMSkgfCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWsgcHV0Q2hhcnM7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWFkID0gcmVhZCArICgoY2hhciA+PiA2KSAhPT0gMikgfDA7XG4gICAgICAgIHU4QXJyW2ldID0gY2hhcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgd3JpdHRlbjogaSwgcmVhZDogaW5wdXRMZW5ndGggPCByZWFkID8gaW5wdXRMZW5ndGggOiByZWFkIH07XG4gIH1cbn1cblxuLyoqXG4gKiBFbmNvZGUgYSBVVEYtOCBzdHJpbmcgaW50byBhIFVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShzOiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIFRleHRFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUocyk7XG59XG5cbi8qKlxuICogRGVjb2RlIGEgVWludDhBcnJheSBpbnRvIGEgVVRGLTggc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoYTogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIHJldHVybiBUZXh0RGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlKGEpO1xufVxuIiwiaW1wb3J0IHsgVGVtcG9yYWxGYWlsdXJlIH0gZnJvbSAnLi9mYWlsdXJlJztcbmltcG9ydCB7IFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yIH0gZnJvbSAnLi90eXBlLWhlbHBlcnMnO1xuXG4vKipcbiAqIFRocm93biBmcm9tIGNvZGUgdGhhdCByZWNlaXZlcyBhIHZhbHVlIHRoYXQgaXMgdW5leHBlY3RlZCBvciB0aGF0IGl0J3MgdW5hYmxlIHRvIGhhbmRsZS5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdWYWx1ZUVycm9yJylcbmV4cG9ydCBjbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsIHB1YmxpYyByZWFkb25seSBjYXVzZT86IHVua25vd24pIHtcbiAgICBzdXBlcihtZXNzYWdlID8/IHVuZGVmaW5lZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIFBheWxvYWQgQ29udmVydGVyIGlzIG1pc2NvbmZpZ3VyZWQuXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignUGF5bG9hZENvbnZlcnRlckVycm9yJylcbmV4cG9ydCBjbGFzcyBQYXlsb2FkQ29udmVydGVyRXJyb3IgZXh0ZW5kcyBWYWx1ZUVycm9yIHt9XG5cbi8qKlxuICogVXNlZCBpbiBkaWZmZXJlbnQgcGFydHMgb2YgdGhlIFNESyB0byBub3RlIHRoYXQgc29tZXRoaW5nIHVuZXhwZWN0ZWQgaGFzIGhhcHBlbmVkLlxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ0lsbGVnYWxTdGF0ZUVycm9yJylcbmV4cG9ydCBjbGFzcyBJbGxlZ2FsU3RhdGVFcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbi8qKlxuICogVGhpcyBleGNlcHRpb24gaXMgdGhyb3duIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gKiAgLSBXb3JrZmxvdyB3aXRoIHRoZSBzYW1lIFdvcmtmbG93IElkIGlzIGN1cnJlbnRseSBydW5uaW5nXG4gKiAgLSBUaGVyZSBpcyBhIGNsb3NlZCBXb3JrZmxvdyB3aXRoIHRoZSBzYW1lIFdvcmtmbG93IElkIGFuZCB0aGUge0BsaW5rIFdvcmtmbG93T3B0aW9ucy53b3JrZmxvd0lkUmV1c2VQb2xpY3l9XG4gKiAgICBpcyBgV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX1JFSkVDVF9EVVBMSUNBVEVgXG4gKiAgLSBUaGVyZSBpcyBjbG9zZWQgV29ya2Zsb3cgaW4gdGhlIGBDb21wbGV0ZWRgIHN0YXRlIHdpdGggdGhlIHNhbWUgV29ya2Zsb3cgSWQgYW5kIHRoZSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93SWRSZXVzZVBvbGljeX1cbiAqICAgIGlzIGBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfQUxMT1dfRFVQTElDQVRFX0ZBSUxFRF9PTkxZYFxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1dvcmtmbG93RXhlY3V0aW9uQWxyZWFkeVN0YXJ0ZWRFcnJvcicpXG5leHBvcnQgY2xhc3MgV29ya2Zsb3dFeGVjdXRpb25BbHJlYWR5U3RhcnRlZEVycm9yIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwdWJsaWMgcmVhZG9ubHkgd29ya2Zsb3dJZDogc3RyaW5nLCBwdWJsaWMgcmVhZG9ubHkgd29ya2Zsb3dUeXBlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGEgV29ya2Zsb3cgd2l0aCB0aGUgZ2l2ZW4gSWQgaXMgbm90IGtub3duIHRvIFRlbXBvcmFsIFNlcnZlci5cbiAqIEl0IGNvdWxkIGJlIGJlY2F1c2U6XG4gKiAtIElkIHBhc3NlZCBpcyBpbmNvcnJlY3RcbiAqIC0gV29ya2Zsb3cgaXMgY2xvc2VkIChmb3Igc29tZSBjYWxscywgZS5nLiBgdGVybWluYXRlYClcbiAqIC0gV29ya2Zsb3cgd2FzIGRlbGV0ZWQgZnJvbSB0aGUgU2VydmVyIGFmdGVyIHJlYWNoaW5nIGl0cyByZXRlbnRpb24gbGltaXRcbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdXb3JrZmxvd05vdEZvdW5kRXJyb3InKVxuZXhwb3J0IGNsYXNzIFdvcmtmbG93Tm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwdWJsaWMgcmVhZG9ubHkgd29ya2Zsb3dJZDogc3RyaW5nLCBwdWJsaWMgcmVhZG9ubHkgcnVuSWQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHNwZWNpZmllZCBuYW1lc3BhY2UgaXMgbm90IGtub3duIHRvIFRlbXBvcmFsIFNlcnZlci5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdOYW1lc3BhY2VOb3RGb3VuZEVycm9yJylcbmV4cG9ydCBjbGFzcyBOYW1lc3BhY2VOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgbmFtZXNwYWNlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihgTmFtZXNwYWNlIG5vdCBmb3VuZDogJyR7bmFtZXNwYWNlfSdgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyB0ZW1wb3JhbCB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcbmltcG9ydCB7IGNoZWNrRXh0ZW5kcywgZXJyb3JNZXNzYWdlLCBpc1JlY29yZCwgU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IgfSBmcm9tICcuL3R5cGUtaGVscGVycyc7XG5cbmV4cG9ydCBjb25zdCBGQUlMVVJFX1NPVVJDRSA9ICdUeXBlU2NyaXB0U0RLJztcbmV4cG9ydCB0eXBlIFByb3RvRmFpbHVyZSA9IHRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLklGYWlsdXJlO1xuXG4vLyBBdm9pZCBpbXBvcnRpbmcgdGhlIHByb3RvIGltcGxlbWVudGF0aW9uIHRvIHJlZHVjZSB3b3JrZmxvdyBidW5kbGUgc2l6ZVxuLy8gQ29waWVkIGZyb20gdGVtcG9yYWwuYXBpLmVudW1zLnYxLlRpbWVvdXRUeXBlXG5leHBvcnQgZW51bSBUaW1lb3V0VHlwZSB7XG4gIFRJTUVPVVRfVFlQRV9VTlNQRUNJRklFRCA9IDAsXG4gIFRJTUVPVVRfVFlQRV9TVEFSVF9UT19DTE9TRSA9IDEsXG4gIFRJTUVPVVRfVFlQRV9TQ0hFRFVMRV9UT19TVEFSVCA9IDIsXG4gIFRJTUVPVVRfVFlQRV9TQ0hFRFVMRV9UT19DTE9TRSA9IDMsXG4gIFRJTUVPVVRfVFlQRV9IRUFSVEJFQVQgPSA0LFxufVxuXG5jaGVja0V4dGVuZHM8dGVtcG9yYWwuYXBpLmVudW1zLnYxLlRpbWVvdXRUeXBlLCBUaW1lb3V0VHlwZT4oKTtcbmNoZWNrRXh0ZW5kczxUaW1lb3V0VHlwZSwgdGVtcG9yYWwuYXBpLmVudW1zLnYxLlRpbWVvdXRUeXBlPigpO1xuXG4vLyBBdm9pZCBpbXBvcnRpbmcgdGhlIHByb3RvIGltcGxlbWVudGF0aW9uIHRvIHJlZHVjZSB3b3JrZmxvdyBidW5kbGUgc2l6ZVxuLy8gQ29waWVkIGZyb20gdGVtcG9yYWwuYXBpLmVudW1zLnYxLlJldHJ5U3RhdGVcbmV4cG9ydCBlbnVtIFJldHJ5U3RhdGUge1xuICBSRVRSWV9TVEFURV9VTlNQRUNJRklFRCA9IDAsXG4gIFJFVFJZX1NUQVRFX0lOX1BST0dSRVNTID0gMSxcbiAgUkVUUllfU1RBVEVfTk9OX1JFVFJZQUJMRV9GQUlMVVJFID0gMixcbiAgUkVUUllfU1RBVEVfVElNRU9VVCA9IDMsXG4gIFJFVFJZX1NUQVRFX01BWElNVU1fQVRURU1QVFNfUkVBQ0hFRCA9IDQsXG4gIFJFVFJZX1NUQVRFX1JFVFJZX1BPTElDWV9OT1RfU0VUID0gNSxcbiAgUkVUUllfU1RBVEVfSU5URVJOQUxfU0VSVkVSX0VSUk9SID0gNixcbiAgUkVUUllfU1RBVEVfQ0FOQ0VMX1JFUVVFU1RFRCA9IDcsXG59XG5cbmNoZWNrRXh0ZW5kczx0ZW1wb3JhbC5hcGkuZW51bXMudjEuUmV0cnlTdGF0ZSwgUmV0cnlTdGF0ZT4oKTtcbmNoZWNrRXh0ZW5kczxSZXRyeVN0YXRlLCB0ZW1wb3JhbC5hcGkuZW51bXMudjEuUmV0cnlTdGF0ZT4oKTtcblxuZXhwb3J0IHR5cGUgV29ya2Zsb3dFeGVjdXRpb24gPSB0ZW1wb3JhbC5hcGkuY29tbW9uLnYxLklXb3JrZmxvd0V4ZWN1dGlvbjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGZhaWx1cmVzIHRoYXQgY2FuIGNyb3NzIFdvcmtmbG93IGFuZCBBY3Rpdml0eSBib3VuZGFyaWVzLlxuICpcbiAqICoqTmV2ZXIgZXh0ZW5kIHRoaXMgY2xhc3Mgb3IgYW55IG9mIGl0cyBjaGlsZHJlbi4qKlxuICpcbiAqIFRoZSBvbmx5IGNoaWxkIGNsYXNzIHlvdSBzaG91bGQgZXZlciB0aHJvdyBmcm9tIHlvdXIgY29kZSBpcyB7QGxpbmsgQXBwbGljYXRpb25GYWlsdXJlfS5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdUZW1wb3JhbEZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIFRlbXBvcmFsRmFpbHVyZSBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCBmYWlsdXJlIHRoYXQgY29uc3RydWN0ZWQgdGhpcyBlcnJvci5cbiAgICpcbiAgICogT25seSBwcmVzZW50IGlmIHRoaXMgZXJyb3Igd2FzIGdlbmVyYXRlZCBmcm9tIGFuIGV4dGVybmFsIG9wZXJhdGlvbi5cbiAgICovXG4gIHB1YmxpYyBmYWlsdXJlPzogUHJvdG9GYWlsdXJlO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsLCBwdWJsaWMgcmVhZG9ubHkgY2F1c2U/OiBFcnJvcikge1xuICAgIHN1cGVyKG1lc3NhZ2UgPz8gdW5kZWZpbmVkKTtcbiAgfVxufVxuXG4vKiogRXhjZXB0aW9ucyBvcmlnaW5hdGVkIGF0IHRoZSBUZW1wb3JhbCBzZXJ2aWNlLiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdTZXJ2ZXJGYWlsdXJlJylcbmV4cG9ydCBjbGFzcyBTZXJ2ZXJGYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBwdWJsaWMgcmVhZG9ubHkgbm9uUmV0cnlhYmxlOiBib29sZWFuLCBjYXVzZT86IEVycm9yKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgY2F1c2UpO1xuICB9XG59XG5cbi8qKlxuICogYEFwcGxpY2F0aW9uRmFpbHVyZWBzIGFyZSB1c2VkIHRvIGNvbW11bmljYXRlIGFwcGxpY2F0aW9uLXNwZWNpZmljIGZhaWx1cmVzIGluIFdvcmtmbG93cyBhbmQgQWN0aXZpdGllcy5cbiAqXG4gKiBUaGUge0BsaW5rIHR5cGV9IHByb3BlcnR5IGlzIG1hdGNoZWQgYWdhaW5zdCB7QGxpbmsgUmV0cnlQb2xpY3kubm9uUmV0cnlhYmxlRXJyb3JUeXBlc30gdG8gZGV0ZXJtaW5lIGlmIGFuIGluc3RhbmNlXG4gKiBvZiB0aGlzIGVycm9yIGlzIHJldHJ5YWJsZS4gQW5vdGhlciB3YXkgdG8gYXZvaWQgcmV0cnlpbmcgaXMgYnkgc2V0dGluZyB0aGUge0BsaW5rIG5vblJldHJ5YWJsZX0gZmxhZyB0byBgdHJ1ZWAuXG4gKlxuICogSW4gV29ya2Zsb3dzLCBpZiB5b3UgdGhyb3cgYSBub24tYEFwcGxpY2F0aW9uRmFpbHVyZWAsIHRoZSBXb3JrZmxvdyBUYXNrIHdpbGwgZmFpbCBhbmQgYmUgcmV0cmllZC4gSWYgeW91IHRocm93IGFuXG4gKiBgQXBwbGljYXRpb25GYWlsdXJlYCwgdGhlIFdvcmtmbG93IEV4ZWN1dGlvbiB3aWxsIGZhaWwuXG4gKlxuICogSW4gQWN0aXZpdGllcywgeW91IGNhbiBlaXRoZXIgdGhyb3cgYW4gYEFwcGxpY2F0aW9uRmFpbHVyZWAgb3IgYW5vdGhlciBgRXJyb3JgIHRvIGZhaWwgdGhlIEFjdGl2aXR5IFRhc2suIEluIHRoZVxuICogbGF0dGVyIGNhc2UsIHRoZSBgRXJyb3JgIHdpbGwgYmUgY29udmVydGVkIHRvIGFuIGBBcHBsaWNhdGlvbkZhaWx1cmVgLiBUaGUgY29udmVyc2lvbiBpcyBkb25lIGFzIGZvbGxvd2luZzpcbiAqXG4gKiAtIGB0eXBlYCBpcyBzZXQgdG8gYGVycm9yLmNvbnN0cnVjdG9yPy5uYW1lID8/IGVycm9yLm5hbWVgXG4gKiAtIGBtZXNzYWdlYCBpcyBzZXQgdG8gYGVycm9yLm1lc3NhZ2VgXG4gKiAtIGBub25SZXRyeWFibGVgIGlzIHNldCB0byBmYWxzZVxuICogLSBgZGV0YWlsc2AgYXJlIHNldCB0byBudWxsXG4gKiAtIHN0YWNrIHRyYWNlIGlzIGNvcGllZCBmcm9tIHRoZSBvcmlnaW5hbCBlcnJvclxuICpcbiAqIFdoZW4gYW4ge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby9jb25jZXB0cy93aGF0LWlzLWFuLWFjdGl2aXR5LWV4ZWN1dGlvbiB8IEFjdGl2aXR5IEV4ZWN1dGlvbn0gZmFpbHMsIHRoZVxuICogYEFwcGxpY2F0aW9uRmFpbHVyZWAgZnJvbSB0aGUgbGFzdCBBY3Rpdml0eSBUYXNrIHdpbGwgYmUgdGhlIGBjYXVzZWAgb2YgdGhlIHtAbGluayBBY3Rpdml0eUZhaWx1cmV9IHRocm93biBpbiB0aGVcbiAqIFdvcmtmbG93LlxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ0FwcGxpY2F0aW9uRmFpbHVyZScpXG5leHBvcnQgY2xhc3MgQXBwbGljYXRpb25GYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgLyoqXG4gICAqIEFsdGVybmF0aXZlbHksIHVzZSB7QGxpbmsgZnJvbUVycm9yfSBvciB7QGxpbmsgY3JlYXRlfS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U/OiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsLFxuICAgIHB1YmxpYyByZWFkb25seSB0eXBlPzogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgbm9uUmV0cnlhYmxlPzogYm9vbGVhbiB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgcHVibGljIHJlYWRvbmx5IGRldGFpbHM/OiB1bmtub3duW10gfCB1bmRlZmluZWQgfCBudWxsLFxuICAgIGNhdXNlPzogRXJyb3JcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgY2F1c2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQXBwbGljYXRpb25GYWlsdXJlYCBmcm9tIGFuIEVycm9yIG9iamVjdC5cbiAgICpcbiAgICogRmlyc3QgY2FsbHMge0BsaW5rIGVuc3VyZUFwcGxpY2F0aW9uRmFpbHVyZSB8IGBlbnN1cmVBcHBsaWNhdGlvbkZhaWx1cmUoZXJyb3IpYH0gYW5kIHRoZW4gb3ZlcnJpZGVzIGFueSBmaWVsZHNcbiAgICogcHJvdmlkZWQgaW4gYG92ZXJyaWRlc2AuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21FcnJvcihlcnJvcjogRXJyb3IgfCB1bmtub3duLCBvdmVycmlkZXM/OiBBcHBsaWNhdGlvbkZhaWx1cmVPcHRpb25zKTogQXBwbGljYXRpb25GYWlsdXJlIHtcbiAgICBjb25zdCBmYWlsdXJlID0gZW5zdXJlQXBwbGljYXRpb25GYWlsdXJlKGVycm9yKTtcbiAgICBPYmplY3QuYXNzaWduKGZhaWx1cmUsIG92ZXJyaWRlcyk7XG4gICAgcmV0dXJuIGZhaWx1cmU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBBcHBsaWNhdGlvbkZhaWx1cmVgLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB3aWxsIGJlIHJldHJ5YWJsZSAodW5sZXNzIGl0cyBgdHlwZWAgaXMgaW5jbHVkZWQgaW4ge0BsaW5rIFJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXN9KS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlKG9wdGlvbnM6IEFwcGxpY2F0aW9uRmFpbHVyZU9wdGlvbnMpOiBBcHBsaWNhdGlvbkZhaWx1cmUge1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgdHlwZSwgbm9uUmV0cnlhYmxlID0gZmFsc2UsIGRldGFpbHMsIGNhdXNlIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBuZXcgdGhpcyhtZXNzYWdlLCB0eXBlLCBub25SZXRyeWFibGUsIGRldGFpbHMsIGNhdXNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBuZXcgYEFwcGxpY2F0aW9uRmFpbHVyZWAgd2l0aCB0aGUge0BsaW5rIG5vblJldHJ5YWJsZX0gZmxhZyBzZXQgdG8gZmFsc2UuIE5vdGUgdGhhdCB0aGlzIGVycm9yIHdpbGwgc3RpbGxcbiAgICogbm90IGJlIHJldHJpZWQgaWYgaXRzIGB0eXBlYCBpcyBpbmNsdWRlZCBpbiB7QGxpbmsgUmV0cnlQb2xpY3kubm9uUmV0cnlhYmxlRXJyb3JUeXBlc30uXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlIE9wdGlvbmFsIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHR5cGUgT3B0aW9uYWwgZXJyb3IgdHlwZSAodXNlZCBieSB7QGxpbmsgUmV0cnlQb2xpY3kubm9uUmV0cnlhYmxlRXJyb3JUeXBlc30pXG4gICAqIEBwYXJhbSBkZXRhaWxzIE9wdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIGZhaWx1cmUuIFNlcmlhbGl6ZWQgYnkgdGhlIFdvcmtlcidzIHtAbGluayBQYXlsb2FkQ29udmVydGVyfS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmV0cnlhYmxlKG1lc3NhZ2U/OiBzdHJpbmcgfCBudWxsLCB0eXBlPzogc3RyaW5nIHwgbnVsbCwgLi4uZGV0YWlsczogdW5rbm93bltdKTogQXBwbGljYXRpb25GYWlsdXJlIHtcbiAgICByZXR1cm4gbmV3IHRoaXMobWVzc2FnZSwgdHlwZSA/PyAnRXJyb3InLCBmYWxzZSwgZGV0YWlscyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbmV3IGBBcHBsaWNhdGlvbkZhaWx1cmVgIHdpdGggdGhlIHtAbGluayBub25SZXRyeWFibGV9IGZsYWcgc2V0IHRvIHRydWUuXG4gICAqXG4gICAqIFdoZW4gdGhyb3duIGZyb20gYW4gQWN0aXZpdHkgb3IgV29ya2Zsb3csIHRoZSBBY3Rpdml0eSBvciBXb3JrZmxvdyB3aWxsIG5vdCBiZSByZXRyaWVkIChldmVuIGlmIGB0eXBlYCBpcyBub3RcbiAgICogbGlzdGVkIGluIHtAbGluayBSZXRyeVBvbGljeS5ub25SZXRyeWFibGVFcnJvclR5cGVzfSkuXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlIE9wdGlvbmFsIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHR5cGUgT3B0aW9uYWwgZXJyb3IgdHlwZVxuICAgKiBAcGFyYW0gZGV0YWlscyBPcHRpb25hbCBkZXRhaWxzIGFib3V0IHRoZSBmYWlsdXJlLiBTZXJpYWxpemVkIGJ5IHRoZSBXb3JrZXIncyB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcn0uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG5vblJldHJ5YWJsZShtZXNzYWdlPzogc3RyaW5nIHwgbnVsbCwgdHlwZT86IHN0cmluZyB8IG51bGwsIC4uLmRldGFpbHM6IHVua25vd25bXSk6IEFwcGxpY2F0aW9uRmFpbHVyZSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG1lc3NhZ2UsIHR5cGUgPz8gJ0Vycm9yJywgdHJ1ZSwgZGV0YWlscyk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcHBsaWNhdGlvbkZhaWx1cmVPcHRpb25zIHtcbiAgLyoqXG4gICAqIEVycm9yIG1lc3NhZ2VcbiAgICovXG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEVycm9yIHR5cGUgKHVzZWQgYnkge0BsaW5rIFJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXN9KVxuICAgKi9cbiAgdHlwZT86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgY3VycmVudCBBY3Rpdml0eSBvciBXb3JrZmxvdyBjYW4gYmUgcmV0cmllZFxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgbm9uUmV0cnlhYmxlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRGV0YWlscyBhYm91dCB0aGUgZmFpbHVyZS4gU2VyaWFsaXplZCBieSB0aGUgV29ya2VyJ3Mge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJ9LlxuICAgKi9cbiAgZGV0YWlscz86IHVua25vd25bXTtcblxuICAvKipcbiAgICogQ2F1c2Ugb2YgdGhlIGZhaWx1cmVcbiAgICovXG4gIGNhdXNlPzogRXJyb3I7XG59XG5cbi8qKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gd2hlbiBDYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLiBUbyBhbGxvdyBDYW5jZWxsYXRpb24gdG8gaGFwcGVuLCBsZXQgaXQgcHJvcGFnYXRlLiBUb1xuICogaWdub3JlIENhbmNlbGxhdGlvbiwgY2F0Y2ggaXQgYW5kIGNvbnRpbnVlIGV4ZWN1dGluZy4gTm90ZSB0aGF0IENhbmNlbGxhdGlvbiBjYW4gb25seSBiZSByZXF1ZXN0ZWQgYSBzaW5nbGUgdGltZSwgc29cbiAqIHlvdXIgV29ya2Zsb3cvQWN0aXZpdHkgRXhlY3V0aW9uIHdpbGwgbm90IHJlY2VpdmUgZnVydGhlciBDYW5jZWxsYXRpb24gcmVxdWVzdHMuXG4gKlxuICogV2hlbiBhIFdvcmtmbG93IG9yIEFjdGl2aXR5IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBjYW5jZWxsZWQsIGEgYENhbmNlbGxlZEZhaWx1cmVgIHdpbGwgYmUgdGhlIGBjYXVzZWAuXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignQ2FuY2VsbGVkRmFpbHVyZScpXG5leHBvcnQgY2xhc3MgQ2FuY2VsbGVkRmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCwgcHVibGljIHJlYWRvbmx5IGRldGFpbHM6IHVua25vd25bXSA9IFtdLCBjYXVzZT86IEVycm9yKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgY2F1c2UpO1xuICB9XG59XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgYGNhdXNlYCB3aGVuIGEgV29ya2Zsb3cgaGFzIGJlZW4gdGVybWluYXRlZFxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1Rlcm1pbmF0ZWRGYWlsdXJlJylcbmV4cG9ydCBjbGFzcyBUZXJtaW5hdGVkRmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCwgY2F1c2U/OiBFcnJvcikge1xuICAgIHN1cGVyKG1lc3NhZ2UsIGNhdXNlKTtcbiAgfVxufVxuXG4vKipcbiAqIFVzZWQgdG8gcmVwcmVzZW50IHRpbWVvdXRzIG9mIEFjdGl2aXRpZXMgYW5kIFdvcmtmbG93c1xuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1RpbWVvdXRGYWlsdXJlJylcbmV4cG9ydCBjbGFzcyBUaW1lb3V0RmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgbGFzdEhlYXJ0YmVhdERldGFpbHM6IHVua25vd24sXG4gICAgcHVibGljIHJlYWRvbmx5IHRpbWVvdXRUeXBlOiBUaW1lb3V0VHlwZVxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGFuIEFjdGl2aXR5IGZhaWx1cmUuIEFsd2F5cyBjb250YWlucyB0aGUgb3JpZ2luYWwgcmVhc29uIGZvciB0aGUgZmFpbHVyZSBhcyBpdHMgYGNhdXNlYC5cbiAqIEZvciBleGFtcGxlLCBpZiBhbiBBY3Rpdml0eSB0aW1lZCBvdXQsIHRoZSBjYXVzZSB3aWxsIGJlIGEge0BsaW5rIFRpbWVvdXRGYWlsdXJlfS5cbiAqXG4gKiBUaGlzIGV4Y2VwdGlvbiBpcyBleHBlY3RlZCB0byBiZSB0aHJvd24gb25seSBieSB0aGUgZnJhbWV3b3JrIGNvZGUuXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignQWN0aXZpdHlGYWlsdXJlJylcbmV4cG9ydCBjbGFzcyBBY3Rpdml0eUZhaWx1cmUgZXh0ZW5kcyBUZW1wb3JhbEZhaWx1cmUge1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHB1YmxpYyByZWFkb25seSBhY3Rpdml0eVR5cGU6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgYWN0aXZpdHlJZDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHB1YmxpYyByZWFkb25seSByZXRyeVN0YXRlOiBSZXRyeVN0YXRlLFxuICAgIHB1YmxpYyByZWFkb25seSBpZGVudGl0eTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGNhdXNlPzogRXJyb3JcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgY2F1c2UpO1xuICB9XG59XG5cbi8qKlxuICogQ29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYSBDaGlsZCBXb3JrZmxvdyBmYWlsdXJlLiBBbHdheXMgY29udGFpbnMgdGhlIHJlYXNvbiBmb3IgdGhlIGZhaWx1cmUgYXMgaXRzIHtAbGluayBjYXVzZX0uXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlIENoaWxkIHdhcyBUZXJtaW5hdGVkLCB0aGUgYGNhdXNlYCBpcyBhIHtAbGluayBUZXJtaW5hdGVkRmFpbHVyZX0uXG4gKlxuICogVGhpcyBleGNlcHRpb24gaXMgZXhwZWN0ZWQgdG8gYmUgdGhyb3duIG9ubHkgYnkgdGhlIGZyYW1ld29yayBjb2RlLlxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ0NoaWxkV29ya2Zsb3dGYWlsdXJlJylcbmV4cG9ydCBjbGFzcyBDaGlsZFdvcmtmbG93RmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZXNwYWNlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcHVibGljIHJlYWRvbmx5IGV4ZWN1dGlvbjogV29ya2Zsb3dFeGVjdXRpb24sXG4gICAgcHVibGljIHJlYWRvbmx5IHdvcmtmbG93VHlwZTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSByZXRyeVN0YXRlOiBSZXRyeVN0YXRlLFxuICAgIGNhdXNlPzogRXJyb3JcbiAgKSB7XG4gICAgc3VwZXIoJ0NoaWxkIFdvcmtmbG93IGV4ZWN1dGlvbiBmYWlsZWQnLCBjYXVzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJZiBgZXJyb3JgIGlzIGFscmVhZHkgYW4gYEFwcGxpY2F0aW9uRmFpbHVyZWAsIHJldHVybnMgYGVycm9yYC5cbiAqXG4gKiBPdGhlcndpc2UsIGNvbnZlcnRzIGBlcnJvcmAgaW50byBhbiBgQXBwbGljYXRpb25GYWlsdXJlYCB3aXRoOlxuICpcbiAqIC0gYG1lc3NhZ2VgOiBgZXJyb3IubWVzc2FnZWAgb3IgYFN0cmluZyhlcnJvcilgXG4gKiAtIGB0eXBlYDogYGVycm9yLmNvbnN0cnVjdG9yLm5hbWVgIG9yIGBlcnJvci5uYW1lYFxuICogLSBgc3RhY2tgOiBgZXJyb3Iuc3RhY2tgIG9yIGAnJ2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUFwcGxpY2F0aW9uRmFpbHVyZShlcnJvcjogdW5rbm93bik6IEFwcGxpY2F0aW9uRmFpbHVyZSB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEFwcGxpY2F0aW9uRmFpbHVyZSkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIGNvbnN0IG1lc3NhZ2UgPSAoaXNSZWNvcmQoZXJyb3IpICYmIFN0cmluZyhlcnJvci5tZXNzYWdlKSkgfHwgU3RyaW5nKGVycm9yKTtcbiAgY29uc3QgdHlwZSA9IChpc1JlY29yZChlcnJvcikgJiYgKGVycm9yLmNvbnN0cnVjdG9yPy5uYW1lID8/IGVycm9yLm5hbWUpKSB8fCB1bmRlZmluZWQ7XG4gIGNvbnN0IGZhaWx1cmUgPSBBcHBsaWNhdGlvbkZhaWx1cmUuY3JlYXRlKHsgbWVzc2FnZSwgdHlwZSwgbm9uUmV0cnlhYmxlOiBmYWxzZSB9KTtcbiAgZmFpbHVyZS5zdGFjayA9IChpc1JlY29yZChlcnJvcikgJiYgU3RyaW5nKGVycm9yLnN0YWNrKSkgfHwgJyc7XG4gIHJldHVybiBmYWlsdXJlO1xufVxuXG4vKipcbiAqIElmIGBlcnJgIGlzIGFuIEVycm9yIGl0IGlzIHR1cm5lZCBpbnRvIGFuIGBBcHBsaWNhdGlvbkZhaWx1cmVgLlxuICpcbiAqIElmIGBlcnJgIHdhcyBhbHJlYWR5IGEgYFRlbXBvcmFsRmFpbHVyZWAsIHJldHVybnMgdGhlIG9yaWdpbmFsIGVycm9yLlxuICpcbiAqIE90aGVyd2lzZSByZXR1cm5zIGFuIGBBcHBsaWNhdGlvbkZhaWx1cmVgIHdpdGggYFN0cmluZyhlcnIpYCBhcyB0aGUgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVRlbXBvcmFsRmFpbHVyZShlcnI6IHVua25vd24pOiBUZW1wb3JhbEZhaWx1cmUge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgVGVtcG9yYWxGYWlsdXJlKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICByZXR1cm4gZW5zdXJlQXBwbGljYXRpb25GYWlsdXJlKGVycik7XG59XG5cbi8qKlxuICogR2V0IHRoZSByb290IGNhdXNlIG1lc3NhZ2Ugb2YgZ2l2ZW4gYGVycm9yYC5cbiAqXG4gKiBJbiBjYXNlIGBlcnJvcmAgaXMgYSB7QGxpbmsgVGVtcG9yYWxGYWlsdXJlfSwgcmVjdXJzZSB0aGUgYGNhdXNlYCBjaGFpbiBhbmQgcmV0dXJuIHRoZSByb290IGBjYXVzZS5tZXNzYWdlYC5cbiAqIE90aGVyd2lzZSwgcmV0dXJuIGBlcnJvci5tZXNzYWdlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvb3RDYXVzZShlcnJvcjogdW5rbm93bik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIFRlbXBvcmFsRmFpbHVyZSkge1xuICAgIHJldHVybiBlcnJvci5jYXVzZSA/IHJvb3RDYXVzZShlcnJvci5jYXVzZSkgOiBlcnJvci5tZXNzYWdlO1xuICB9XG4gIHJldHVybiBlcnJvck1lc3NhZ2UoZXJyb3IpO1xufVxuIiwiLyoqXG4gKiBDb21tb24gbGlicmFyeSBmb3IgY29kZSB0aGF0J3MgdXNlZCBhY3Jvc3MgdGhlIENsaWVudCwgV29ya2VyLCBhbmQvb3IgV29ya2Zsb3dcbiAqXG4gKiBAbW9kdWxlXG4gKi9cblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnLi9lbmNvZGluZyc7XG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4vdHlwZS1oZWxwZXJzJztcblxuZXhwb3J0ICogZnJvbSAnLi9hY3Rpdml0eS1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vY29udmVydGVyL2RhdGEtY29udmVydGVyJztcbmV4cG9ydCAqIGZyb20gJy4vY29udmVydGVyL2ZhaWx1cmUtY29udmVydGVyJztcbmV4cG9ydCAqIGZyb20gJy4vY29udmVydGVyL3BheWxvYWQtY29kZWMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb252ZXJ0ZXIvcGF5bG9hZC1jb252ZXJ0ZXInO1xuZXhwb3J0ICogZnJvbSAnLi9jb252ZXJ0ZXIvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9kZXByZWNhdGVkLXRpbWUnO1xuZXhwb3J0ICogZnJvbSAnLi9lcnJvcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9mYWlsdXJlJztcbmV4cG9ydCB7IEhlYWRlcnMsIE5leHQgfSBmcm9tICcuL2ludGVyY2VwdG9ycyc7XG5leHBvcnQgKiBmcm9tICcuL2ludGVyZmFjZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9sb2dnZXInO1xuZXhwb3J0ICogZnJvbSAnLi9yZXRyeS1wb2xpY3knO1xuZXhwb3J0IHR5cGUgeyBUaW1lc3RhbXAsIER1cmF0aW9uLCBTdHJpbmdWYWx1ZSB9IGZyb20gJy4vdGltZSc7XG5leHBvcnQgKiBmcm9tICcuL3dvcmtmbG93LWhhbmRsZSc7XG5leHBvcnQgKiBmcm9tICcuL3dvcmtmbG93LW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi92ZXJzaW9uaW5nLWludGVudCc7XG5cbi8qKlxuICogRW5jb2RlIGEgVVRGLTggc3RyaW5nIGludG8gYSBVaW50OEFycmF5XG4gKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHU4KHM6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gZW5jb2RpbmcuZW5jb2RlKHMpO1xufVxuXG4vKipcbiAqIERlY29kZSBhIFVpbnQ4QXJyYXkgaW50byBhIFVURi04IHN0cmluZ1xuICpcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYXJyOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIGVuY29kaW5nLmRlY29kZShhcnIpO1xufVxuXG4vKipcbiAqIEdldCBgZXJyb3IubWVzc2FnZWAgKG9yIGB1bmRlZmluZWRgIGlmIG5vdCBwcmVzZW50KVxuICpcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvck1lc3NhZ2UoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gaGVscGVycy5lcnJvck1lc3NhZ2UoZXJyb3IpO1xufVxuXG4vKipcbiAqIEdldCBgZXJyb3IuY29kZWAgKG9yIGB1bmRlZmluZWRgIGlmIG5vdCBwcmVzZW50KVxuICpcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckNvZGUoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gaGVscGVycy5lcnJvckNvZGUoZXJyb3IpO1xufVxuIiwiaW1wb3J0IHsgQW55RnVuYywgT21pdExhc3RQYXJhbSB9IGZyb20gJy4vdHlwZS1oZWxwZXJzJztcbmltcG9ydCB7IFBheWxvYWQgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuXG4vKipcbiAqIFR5cGUgb2YgdGhlIG5leHQgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gaW50ZXJjZXB0b3IgZnVuY3Rpb25cbiAqXG4gKiBDYWxsZWQgZnJvbSBhbiBpbnRlcmNlcHRvciB0byBjb250aW51ZSB0aGUgaW50ZXJjZXB0aW9uIGNoYWluXG4gKi9cbmV4cG9ydCB0eXBlIE5leHQ8SUYsIEZOIGV4dGVuZHMga2V5b2YgSUY+ID0gUmVxdWlyZWQ8SUY+W0ZOXSBleHRlbmRzIEFueUZ1bmMgPyBPbWl0TGFzdFBhcmFtPFJlcXVpcmVkPElGPltGTl0+IDogbmV2ZXI7XG5cbi8qKiBIZWFkZXJzIGFyZSBqdXN0IGEgbWFwcGluZyBvZiBoZWFkZXIgbmFtZSB0byBQYXlsb2FkICovXG5leHBvcnQgdHlwZSBIZWFkZXJzID0gUmVjb3JkPHN0cmluZywgUGF5bG9hZD47XG5cbi8qKlxuICogQ29tcG9zZXMgYWxsIGludGVyY2VwdG9yIG1ldGhvZHMgaW50byBhIHNpbmdsZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBpbnRlcmNlcHRvcnMgYSBsaXN0IG9mIGludGVyY2VwdG9yc1xuICogQHBhcmFtIG1ldGhvZCB0aGUgbmFtZSBvZiB0aGUgaW50ZXJjZXB0b3IgbWV0aG9kIHRvIGNvbXBvc2VcbiAqIEBwYXJhbSBuZXh0IHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBpbnRlcmNlcHRpb24gY2hhaW5cbiAqL1xuLy8gdHMtcHJ1bmUtaWdub3JlLW5leHQgKGltcG9ydGVkIHZpYSBsaWIvaW50ZXJjZXB0b3JzKVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvc2VJbnRlcmNlcHRvcnM8SSwgTSBleHRlbmRzIGtleW9mIEk+KGludGVyY2VwdG9yczogSVtdLCBtZXRob2Q6IE0sIG5leHQ6IE5leHQ8SSwgTT4pOiBOZXh0PEksIE0+IHtcbiAgZm9yIChsZXQgaSA9IGludGVyY2VwdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGNvbnN0IGludGVyY2VwdG9yID0gaW50ZXJjZXB0b3JzW2ldO1xuICAgIGlmIChpbnRlcmNlcHRvclttZXRob2RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBuZXh0O1xuICAgICAgLy8gV2UgbG9vc2UgdHlwZSBzYWZldHkgaGVyZSBiZWNhdXNlIFR5cGVzY3JpcHQgY2FuJ3QgZGVkdWNlIHRoYXQgaW50ZXJjZXB0b3JbbWV0aG9kXSBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgICAgLy8gdGhlIHNhbWUgdHlwZSBhcyBOZXh0PEksIE0+XG4gICAgICBuZXh0ID0gKChpbnB1dDogYW55KSA9PiAoaW50ZXJjZXB0b3JbbWV0aG9kXSBhcyBhbnkpKGlucHV0LCBwcmV2KSkgYXMgYW55O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dDtcbn1cbiIsImltcG9ydCB0eXBlIHsgdGVtcG9yYWwgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5cbmV4cG9ydCB0eXBlIFBheWxvYWQgPSB0ZW1wb3JhbC5hcGkuY29tbW9uLnYxLklQYXlsb2FkO1xuXG4vKiogVHlwZSB0aGF0IGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgV29ya2Zsb3cgYGV4ZWN1dGVgIGZ1bmN0aW9uICovXG5leHBvcnQgdHlwZSBXb3JrZmxvd1JldHVyblR5cGUgPSBQcm9taXNlPGFueT47XG5leHBvcnQgdHlwZSBXb3JrZmxvd1NpZ25hbFR5cGUgPSAoLi4uYXJnczogYW55W10pID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dRdWVyeVR5cGUgPSAoLi4uYXJnczogYW55W10pID0+IGFueTtcblxuLyoqXG4gKiBCcm9hZCBXb3JrZmxvdyBmdW5jdGlvbiBkZWZpbml0aW9uLCBzcGVjaWZpYyBXb3JrZmxvd3Mgd2lsbCB0eXBpY2FsbHkgdXNlIGEgbmFycm93ZXIgdHlwZSBkZWZpbml0aW9uLCBlLmc6XG4gKiBgYGB0c1xuICogZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG15V29ya2Zsb3coYXJnMTogbnVtYmVyLCBhcmcyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHR5cGUgV29ya2Zsb3cgPSAoLi4uYXJnczogYW55W10pID0+IFdvcmtmbG93UmV0dXJuVHlwZTtcblxuZGVjbGFyZSBjb25zdCBhcmdzQnJhbmQ6IHVuaXF1ZSBzeW1ib2w7XG4vKipcbiAqIEFuIGludGVyZmFjZSByZXByZXNlbnRpbmcgYSBXb3JrZmxvdyBzaWduYWwgZGVmaW5pdGlvbiwgYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgZGVmaW5lU2lnbmFsfVxuICpcbiAqIEByZW1hcmtzIGBBcmdzYCBjYW4gYmUgdXNlZCBmb3IgcGFyYW1ldGVyIHR5cGUgaW5mZXJlbmNlIGluIGhhbmRsZXIgZnVuY3Rpb25zIGFuZCAqV29ya2Zsb3dIYW5kbGUgbWV0aG9kcy5cbiAqIGBOYW1lYCBjYW4gb3B0aW9uYWxseSBiZSBzcGVjaWZpZWQgd2l0aCBhIHN0cmluZyBsaXRlcmFsIHR5cGUgdG8gcHJlc2VydmUgdHlwZS1sZXZlbCBrbm93bGVkZ2Ugb2YgdGhlIHNpZ25hbCBuYW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25hbERlZmluaXRpb248QXJncyBleHRlbmRzIGFueVtdID0gW10sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgdHlwZTogJ3NpZ25hbCc7XG4gIG5hbWU6IE5hbWU7XG4gIC8qKlxuICAgKiBWaXJ0dWFsIHR5cGUgYnJhbmQgdG8gbWFpbnRhaW4gYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHtAbGluayBTaWduYWxEZWZpbml0aW9ufSB0eXBlcyB3aXRoIGRpZmZlcmVudCBhcmdzLlxuICAgKiBUaGlzIGZpZWxkIGlzIG5vdCBwcmVzZW50IGF0IHJ1bi10aW1lLlxuICAgKi9cbiAgW2FyZ3NCcmFuZF06IEFyZ3M7XG59XG5cbmRlY2xhcmUgY29uc3QgcmV0QnJhbmQ6IHVuaXF1ZSBzeW1ib2w7XG4vKipcbiAqIEFuIGludGVyZmFjZSByZXByZXNlbnRpbmcgYSBXb3JrZmxvdyBxdWVyeSBkZWZpbml0aW9uIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIGRlZmluZVF1ZXJ5fVxuICpcbiAqIEByZW1hcmtzIGBBcmdzYCBhbmQgYFJldGAgY2FuIGJlIHVzZWQgZm9yIHBhcmFtZXRlciB0eXBlIGluZmVyZW5jZSBpbiBoYW5kbGVyIGZ1bmN0aW9ucyBhbmQgKldvcmtmbG93SGFuZGxlIG1ldGhvZHMuXG4gKiBgTmFtZWAgY2FuIG9wdGlvbmFsbHkgYmUgc3BlY2lmaWVkIHdpdGggYSBzdHJpbmcgbGl0ZXJhbCB0eXBlIHRvIHByZXNlcnZlIHR5cGUtbGV2ZWwga25vd2xlZGdlIG9mIHRoZSBxdWVyeSBuYW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5RGVmaW5pdGlvbjxSZXQsIEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdLCBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIHR5cGU6ICdxdWVyeSc7XG4gIG5hbWU6IE5hbWU7XG4gIC8qKlxuICAgKiBWaXJ0dWFsIHR5cGUgYnJhbmQgdG8gbWFpbnRhaW4gYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHtAbGluayBRdWVyeURlZmluaXRpb259IHR5cGVzIHdpdGggZGlmZmVyZW50IGFyZ3MuXG4gICAqIFRoaXMgZmllbGQgaXMgbm90IHByZXNlbnQgYXQgcnVuLXRpbWUuXG4gICAqL1xuICBbYXJnc0JyYW5kXTogQXJncztcbiAgLyoqXG4gICAqIFZpcnR1YWwgdHlwZSBicmFuZCB0byBtYWludGFpbiBhIGRpc3RpbmN0aW9uIGJldHdlZW4ge0BsaW5rIFF1ZXJ5RGVmaW5pdGlvbn0gdHlwZXMgd2l0aCBkaWZmZXJlbnQgcmV0dXJuIHR5cGVzLlxuICAgKiBUaGlzIGZpZWxkIGlzIG5vdCBwcmVzZW50IGF0IHJ1bi10aW1lLlxuICAgKi9cbiAgW3JldEJyYW5kXTogUmV0O1xufVxuXG4vKiogR2V0IHRoZSBcInVud3JhcHBlZFwiIHJldHVybiB0eXBlICh3aXRob3V0IFByb21pc2UpIG9mIHRoZSBleGVjdXRlIGhhbmRsZXIgZnJvbSBXb3JrZmxvdyB0eXBlIGBXYCAqL1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dSZXN1bHRUeXBlPFcgZXh0ZW5kcyBXb3JrZmxvdz4gPSBSZXR1cm5UeXBlPFc+IGV4dGVuZHMgUHJvbWlzZTxpbmZlciBSPiA/IFIgOiBuZXZlcjtcblxuLyoqXG4gKiBJZiBhbm90aGVyIFNESyBjcmVhdGVzIGEgU2VhcmNoIEF0dHJpYnV0ZSB0aGF0J3Mgbm90IGFuIGFycmF5LCB3ZSB3cmFwIGl0IGluIGFuIGFycmF5LlxuICpcbiAqIERhdGVzIGFyZSBzZXJpYWxpemVkIGFzIElTTyBzdHJpbmdzLlxuICovXG5leHBvcnQgdHlwZSBTZWFyY2hBdHRyaWJ1dGVzID0gUmVjb3JkPHN0cmluZywgU2VhcmNoQXR0cmlidXRlVmFsdWUgfCBSZWFkb25seTxTZWFyY2hBdHRyaWJ1dGVWYWx1ZT4gfCB1bmRlZmluZWQ+O1xuZXhwb3J0IHR5cGUgU2VhcmNoQXR0cmlidXRlVmFsdWUgPSBzdHJpbmdbXSB8IG51bWJlcltdIHwgYm9vbGVhbltdIHwgRGF0ZVtdO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFjdGl2aXR5RnVuY3Rpb248UCBleHRlbmRzIGFueVtdID0gYW55W10sIFIgPSBhbnk+IHtcbiAgKC4uLmFyZ3M6IFApOiBQcm9taXNlPFI+O1xufVxuXG4vKipcbiAqIE1hcHBpbmcgb2YgQWN0aXZpdHkgbmFtZSB0byBmdW5jdGlvblxuICogQGRlcHJlY2F0ZWQgbm90IHJlcXVpcmVkIGFueW1vcmUsIGZvciB1bnR5cGVkIGFjdGl2aXRpZXMgdXNlIHtAbGluayBVbnR5cGVkQWN0aXZpdGllc31cbiAqL1xuZXhwb3J0IHR5cGUgQWN0aXZpdHlJbnRlcmZhY2UgPSBSZWNvcmQ8c3RyaW5nLCBBY3Rpdml0eUZ1bmN0aW9uPjtcblxuLyoqXG4gKiBNYXBwaW5nIG9mIEFjdGl2aXR5IG5hbWUgdG8gZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHR5cGUgVW50eXBlZEFjdGl2aXRpZXMgPSBSZWNvcmQ8c3RyaW5nLCBBY3Rpdml0eUZ1bmN0aW9uPjtcblxuLyoqXG4gKiBBIHdvcmtmbG93J3MgaGlzdG9yeSBhbmQgSUQuIFVzZWZ1bCBmb3IgcmVwbGF5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlBbmRXb3JrZmxvd0lkIHtcbiAgd29ya2Zsb3dJZDogc3RyaW5nO1xuICBoaXN0b3J5OiB0ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5IaXN0b3J5IHwgdW5rbm93biB8IHVuZGVmaW5lZDtcbn1cbiIsImV4cG9ydCB0eXBlIExvZ0xldmVsID0gJ1RSQUNFJyB8ICdERUJVRycgfCAnSU5GTycgfCAnV0FSTicgfCAnRVJST1InO1xuXG5leHBvcnQgdHlwZSBMb2dNZXRhZGF0YSA9IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT47XG5cbi8qKlxuICogSW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlIGluIG9yZGVyIHRvIGN1c3RvbWl6ZSB3b3JrZXIgbG9nZ2luZ1xuICovXG5leHBvcnQgaW50ZXJmYWNlIExvZ2dlciB7XG4gIGxvZyhsZXZlbDogTG9nTGV2ZWwsIG1lc3NhZ2U6IHN0cmluZywgbWV0YT86IExvZ01ldGFkYXRhKTogYW55O1xuICB0cmFjZShtZXNzYWdlOiBzdHJpbmcsIG1ldGE/OiBMb2dNZXRhZGF0YSk6IGFueTtcbiAgZGVidWcobWVzc2FnZTogc3RyaW5nLCBtZXRhPzogTG9nTWV0YWRhdGEpOiBhbnk7XG4gIGluZm8obWVzc2FnZTogc3RyaW5nLCBtZXRhPzogTG9nTWV0YWRhdGEpOiBhbnk7XG4gIHdhcm4obWVzc2FnZTogc3RyaW5nLCBtZXRhPzogTG9nTWV0YWRhdGEpOiBhbnk7XG4gIGVycm9yKG1lc3NhZ2U6IHN0cmluZywgbWV0YT86IExvZ01ldGFkYXRhKTogYW55O1xufVxuIiwiaW1wb3J0IHR5cGUgeyB0ZW1wb3JhbCB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcbmltcG9ydCB7IFZhbHVlRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBEdXJhdGlvbiwgbXNPcHRpb25hbFRvTnVtYmVyLCBtc09wdGlvbmFsVG9UcywgbXNUb051bWJlciwgbXNUb1RzLCBvcHRpb25hbFRzVG9NcyB9IGZyb20gJy4vdGltZSc7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgcmV0cnlpbmcgV29ya2Zsb3dzIGFuZCBBY3Rpdml0aWVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmV0cnlQb2xpY3kge1xuICAvKipcbiAgICogQ29lZmZpY2llbnQgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5leHQgcmV0cnkgaW50ZXJ2YWwuXG4gICAqIFRoZSBuZXh0IHJldHJ5IGludGVydmFsIGlzIHByZXZpb3VzIGludGVydmFsIG11bHRpcGxpZWQgYnkgdGhpcyBjb2VmZmljaWVudC5cbiAgICogQG1pbmltdW0gMVxuICAgKiBAZGVmYXVsdCAyXG4gICAqL1xuICBiYWNrb2ZmQ29lZmZpY2llbnQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBJbnRlcnZhbCBvZiB0aGUgZmlyc3QgcmV0cnkuXG4gICAqIElmIGNvZWZmaWNpZW50IGlzIDEgdGhlbiBpdCBpcyB1c2VkIGZvciBhbGwgcmV0cmllc1xuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICogQGRlZmF1bHQgMSBzZWNvbmRcbiAgICovXG4gIGluaXRpYWxJbnRlcnZhbD86IER1cmF0aW9uO1xuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2YgYXR0ZW1wdHMuIFdoZW4gZXhjZWVkZWQsIHJldHJpZXMgc3RvcCAoZXZlbiBpZiB7QGxpbmsgQWN0aXZpdHlPcHRpb25zLnNjaGVkdWxlVG9DbG9zZVRpbWVvdXR9XG4gICAqIGhhc24ndCBiZWVuIHJlYWNoZWQpLlxuICAgKlxuICAgKiBAZGVmYXVsdCBJbmZpbml0eVxuICAgKi9cbiAgbWF4aW11bUF0dGVtcHRzPzogbnVtYmVyO1xuICAvKipcbiAgICogTWF4aW11bSBpbnRlcnZhbCBiZXR3ZWVuIHJldHJpZXMuXG4gICAqIEV4cG9uZW50aWFsIGJhY2tvZmYgbGVhZHMgdG8gaW50ZXJ2YWwgaW5jcmVhc2UuXG4gICAqIFRoaXMgdmFsdWUgaXMgdGhlIGNhcCBvZiB0aGUgaW5jcmVhc2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IDEwMHggb2Yge0BsaW5rIGluaXRpYWxJbnRlcnZhbH1cbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqL1xuICBtYXhpbXVtSW50ZXJ2YWw/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogTGlzdCBvZiBhcHBsaWNhdGlvbiBmYWlsdXJlcyB0eXBlcyB0byBub3QgcmV0cnkuXG4gICAqL1xuICBub25SZXRyeWFibGVFcnJvclR5cGVzPzogc3RyaW5nW107XG59XG5cbi8qKlxuICogVHVybiBhIFRTIFJldHJ5UG9saWN5IGludG8gYSBwcm90byBjb21wYXRpYmxlIFJldHJ5UG9saWN5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlUmV0cnlQb2xpY3kocmV0cnlQb2xpY3k6IFJldHJ5UG9saWN5KTogdGVtcG9yYWwuYXBpLmNvbW1vbi52MS5JUmV0cnlQb2xpY3kge1xuICBpZiAocmV0cnlQb2xpY3kuYmFja29mZkNvZWZmaWNpZW50ICE9IG51bGwgJiYgcmV0cnlQb2xpY3kuYmFja29mZkNvZWZmaWNpZW50IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignUmV0cnlQb2xpY3kuYmFja29mZkNvZWZmaWNpZW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgfVxuICBpZiAocmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzICE9IG51bGwpIHtcbiAgICBpZiAocmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIC8vIGRyb3AgZmllbGQgKEluZmluaXR5IGlzIHRoZSBkZWZhdWx0KVxuICAgICAgY29uc3QgeyBtYXhpbXVtQXR0ZW1wdHM6IF8sIC4uLndpdGhvdXQgfSA9IHJldHJ5UG9saWN5O1xuICAgICAgcmV0cnlQb2xpY3kgPSB3aXRob3V0O1xuICAgIH0gZWxzZSBpZiAocmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdSZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHJldHJ5UG9saWN5Lm1heGltdW1BdHRlbXB0cykpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdSZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1heGltdW1JbnRlcnZhbCA9IG1zT3B0aW9uYWxUb051bWJlcihyZXRyeVBvbGljeS5tYXhpbXVtSW50ZXJ2YWwpO1xuICBjb25zdCBpbml0aWFsSW50ZXJ2YWwgPSBtc1RvTnVtYmVyKHJldHJ5UG9saWN5LmluaXRpYWxJbnRlcnZhbCA/PyAxMDAwKTtcbiAgaWYgKG1heGltdW1JbnRlcnZhbCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdSZXRyeVBvbGljeS5tYXhpbXVtSW50ZXJ2YWwgY2Fubm90IGJlIDAnKTtcbiAgfVxuICBpZiAoaW5pdGlhbEludGVydmFsID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1JldHJ5UG9saWN5LmluaXRpYWxJbnRlcnZhbCBjYW5ub3QgYmUgMCcpO1xuICB9XG4gIGlmIChtYXhpbXVtSW50ZXJ2YWwgIT0gbnVsbCAmJiBtYXhpbXVtSW50ZXJ2YWwgPCBpbml0aWFsSW50ZXJ2YWwpIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignUmV0cnlQb2xpY3kubWF4aW11bUludGVydmFsIGNhbm5vdCBiZSBsZXNzIHRoYW4gaXRzIGluaXRpYWxJbnRlcnZhbCcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWF4aW11bUF0dGVtcHRzOiByZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMsXG4gICAgaW5pdGlhbEludGVydmFsOiBtc1RvVHMoaW5pdGlhbEludGVydmFsKSxcbiAgICBtYXhpbXVtSW50ZXJ2YWw6IG1zT3B0aW9uYWxUb1RzKG1heGltdW1JbnRlcnZhbCksXG4gICAgYmFja29mZkNvZWZmaWNpZW50OiByZXRyeVBvbGljeS5iYWNrb2ZmQ29lZmZpY2llbnQsXG4gICAgbm9uUmV0cnlhYmxlRXJyb3JUeXBlczogcmV0cnlQb2xpY3kubm9uUmV0cnlhYmxlRXJyb3JUeXBlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJuIGEgcHJvdG8gY29tcGF0aWJsZSBSZXRyeVBvbGljeSBpbnRvIGEgVFMgUmV0cnlQb2xpY3lcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcGlsZVJldHJ5UG9saWN5KFxuICByZXRyeVBvbGljeT86IHRlbXBvcmFsLmFwaS5jb21tb24udjEuSVJldHJ5UG9saWN5IHwgbnVsbFxuKTogUmV0cnlQb2xpY3kgfCB1bmRlZmluZWQge1xuICBpZiAoIXJldHJ5UG9saWN5KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFja29mZkNvZWZmaWNpZW50OiByZXRyeVBvbGljeS5iYWNrb2ZmQ29lZmZpY2llbnQgPz8gdW5kZWZpbmVkLFxuICAgIG1heGltdW1BdHRlbXB0czogcmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzID8/IHVuZGVmaW5lZCxcbiAgICBtYXhpbXVtSW50ZXJ2YWw6IG9wdGlvbmFsVHNUb01zKHJldHJ5UG9saWN5Lm1heGltdW1JbnRlcnZhbCksXG4gICAgaW5pdGlhbEludGVydmFsOiBvcHRpb25hbFRzVG9NcyhyZXRyeVBvbGljeS5pbml0aWFsSW50ZXJ2YWwpLFxuICAgIG5vblJldHJ5YWJsZUVycm9yVHlwZXM6IHJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXMgPz8gdW5kZWZpbmVkLFxuICB9O1xufVxuIiwiaW1wb3J0IExvbmcgZnJvbSAnbG9uZyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLW5hbWVkLWFzLWRlZmF1bHRcbmltcG9ydCBtcywgeyBTdHJpbmdWYWx1ZSB9IGZyb20gJ21zJztcbmltcG9ydCB0eXBlIHsgZ29vZ2xlIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHsgVmFsdWVFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcblxuLy8gTk9URTogdGhlc2UgYXJlIHRoZSBzYW1lIGludGVyZmFjZSBpbiBKU1xuLy8gZ29vZ2xlLnByb3RvYnVmLklEdXJhdGlvbjtcbi8vIGdvb2dsZS5wcm90b2J1Zi5JVGltZXN0YW1wO1xuLy8gVGhlIGNvbnZlcnNpb24gZnVuY3Rpb25zIGJlbG93IHNob3VsZCB3b3JrIGZvciBib3RoXG5cbmV4cG9ydCB0eXBlIFRpbWVzdGFtcCA9IGdvb2dsZS5wcm90b2J1Zi5JVGltZXN0YW1wO1xuXG4vKipcbiAqIEEgZHVyYXRpb24sIGV4cHJlc3NlZCBlaXRoZXIgYXMgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBvciBhcyBhIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9LlxuICovXG5leHBvcnQgdHlwZSBEdXJhdGlvbiA9IFN0cmluZ1ZhbHVlIHwgbnVtYmVyO1xuXG5leHBvcnQgdHlwZSB7IFN0cmluZ1ZhbHVlIH0gZnJvbSAnbXMnO1xuXG4vKipcbiAqIExvc3N5IGNvbnZlcnNpb24gZnVuY3Rpb24gZnJvbSBUaW1lc3RhbXAgdG8gbnVtYmVyIGR1ZSB0byBwb3NzaWJsZSBvdmVyZmxvdy5cbiAqIElmIHRzIGlzIG51bGwgb3IgdW5kZWZpbmVkIHJldHVybnMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uYWxUc1RvTXModHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAodHMgPT09IHVuZGVmaW5lZCB8fCB0cyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHRzVG9Ncyh0cyk7XG59XG5cbi8qKlxuICogTG9zc3kgY29udmVyc2lvbiBmdW5jdGlvbiBmcm9tIFRpbWVzdGFtcCB0byBudW1iZXIgZHVlIHRvIHBvc3NpYmxlIG92ZXJmbG93XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0c1RvTXModHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICBpZiAodHMgPT09IHVuZGVmaW5lZCB8fCB0cyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdGltZXN0YW1wLCBnb3QgJHt0c31gKTtcbiAgfVxuICBjb25zdCB7IHNlY29uZHMsIG5hbm9zIH0gPSB0cztcbiAgcmV0dXJuIChzZWNvbmRzIHx8IExvbmcuVVpFUk8pXG4gICAgLm11bCgxMDAwKVxuICAgIC5hZGQoTWF0aC5mbG9vcigobmFub3MgfHwgMCkgLyAxMDAwMDAwKSlcbiAgICAudG9OdW1iZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1zTnVtYmVyVG9UcyhtaWxsaXM6IG51bWJlcik6IFRpbWVzdGFtcCB7XG4gIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKG1pbGxpcyAvIDEwMDApO1xuICBjb25zdCBuYW5vcyA9IChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDA7XG4gIGlmIChOdW1iZXIuaXNOYU4oc2Vjb25kcykgfHwgTnVtYmVyLmlzTmFOKG5hbm9zKSkge1xuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBJbnZhbGlkIG1pbGxpcyAke21pbGxpc31gKTtcbiAgfVxuICByZXR1cm4geyBzZWNvbmRzOiBMb25nLmZyb21OdW1iZXIoc2Vjb25kcyksIG5hbm9zIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtc1RvVHMoc3RyOiBEdXJhdGlvbik6IFRpbWVzdGFtcCB7XG4gIHJldHVybiBtc051bWJlclRvVHMobXNUb051bWJlcihzdHIpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1zT3B0aW9uYWxUb1RzKHN0cjogRHVyYXRpb24gfCB1bmRlZmluZWQpOiBUaW1lc3RhbXAgfCB1bmRlZmluZWQge1xuICByZXR1cm4gc3RyID8gbXNUb1RzKHN0cikgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtc09wdGlvbmFsVG9OdW1iZXIodmFsOiBEdXJhdGlvbiB8IHVuZGVmaW5lZCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1zVG9OdW1iZXIodmFsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1zVG9OdW1iZXIodmFsOiBEdXJhdGlvbik6IG51bWJlciB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgcmV0dXJuIG1zV2l0aFZhbGlkYXRpb24odmFsKTtcbn1cblxuZnVuY3Rpb24gbXNXaXRoVmFsaWRhdGlvbihzdHI6IFN0cmluZ1ZhbHVlKTogbnVtYmVyIHtcbiAgY29uc3QgbWlsbGlzID0gbXMoc3RyKTtcbiAgaWYgKG1pbGxpcyA9PSBudWxsIHx8IGlzTmFOKG1pbGxpcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGR1cmF0aW9uIHN0cmluZzogJyR7c3RyfSdgKTtcbiAgfVxuICByZXR1cm4gbWlsbGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHNUb0RhdGUodHM6IFRpbWVzdGFtcCk6IERhdGUge1xuICByZXR1cm4gbmV3IERhdGUodHNUb01zKHRzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25hbFRzVG9EYXRlKHRzOiBUaW1lc3RhbXAgfCBudWxsIHwgdW5kZWZpbmVkKTogRGF0ZSB8IHVuZGVmaW5lZCB7XG4gIGlmICh0cyA9PT0gdW5kZWZpbmVkIHx8IHRzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUodHNUb01zKHRzKSk7XG59XG5cbi8vIHRzLXBydW5lLWlnbm9yZS1uZXh0IChpbXBvcnRlZCB2aWEgc2NoZWR1bGUtaGVscGVycy50cylcbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25hbERhdGVUb1RzKGRhdGU6IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkKTogVGltZXN0YW1wIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGRhdGUgPT09IHVuZGVmaW5lZCB8fCBkYXRlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gbXNUb1RzKGRhdGUuZ2V0VGltZSgpKTtcbn1cbiIsIi8qKiBTaG9ydGhhbmQgYWxpYXMgKi9cbmV4cG9ydCB0eXBlIEFueUZ1bmMgPSAoLi4uYXJnczogYW55W10pID0+IGFueTtcbi8qKiBBIHR1cGxlIHdpdGhvdXQgaXRzIGxhc3QgZWxlbWVudCAqL1xuZXhwb3J0IHR5cGUgT21pdExhc3Q8VD4gPSBUIGV4dGVuZHMgWy4uLmluZmVyIFJFU1QsIGFueV0gPyBSRVNUIDogbmV2ZXI7XG4vKiogRiB3aXRoIGFsbCBhcmd1bWVudHMgYnV0IHRoZSBsYXN0ICovXG5leHBvcnQgdHlwZSBPbWl0TGFzdFBhcmFtPEYgZXh0ZW5kcyBBbnlGdW5jPiA9ICguLi5hcmdzOiBPbWl0TGFzdDxQYXJhbWV0ZXJzPEY+PikgPT4gUmV0dXJuVHlwZTxGPjtcbi8qKiBSZXF1aXJlIHRoYXQgVCBoYXMgYXQgbGVhc3Qgb25lIG9mIHRoZSBwcm92aWRlZCBwcm9wZXJ0aWVzIGRlZmluZWQgKi9cbmV4cG9ydCB0eXBlIFJlcXVpcmVBdExlYXN0T25lPFQsIEtleXMgZXh0ZW5kcyBrZXlvZiBUID0ga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgS2V5cz4+ICZcbiAge1xuICAgIFtLIGluIEtleXNdLT86IFJlcXVpcmVkPFBpY2s8VCwgSz4+ICYgUGFydGlhbDxQaWNrPFQsIEV4Y2x1ZGU8S2V5cywgSz4+PjtcbiAgfVtLZXlzXTtcblxuLyoqIFZlcmlmeSB0aGF0IGFuIHR5cGUgX0NvcHkgZXh0ZW5kcyBfT3JpZyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRXh0ZW5kczxfT3JpZywgX0NvcHkgZXh0ZW5kcyBfT3JpZz4oKTogdm9pZCB7XG4gIC8vIG5vb3AsIGp1c3QgdHlwZSBjaGVja1xufVxuXG5leHBvcnQgdHlwZSBSZXBsYWNlPEJhc2UsIE5ldz4gPSBPbWl0PEJhc2UsIGtleW9mIE5ldz4gJiBOZXc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlY29yZCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eTxYIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIFkgZXh0ZW5kcyBQcm9wZXJ0eUtleT4oXG4gIHJlY29yZDogWCxcbiAgcHJvcDogWVxuKTogcmVjb3JkIGlzIFggJiBSZWNvcmQ8WSwgdW5rbm93bj4ge1xuICByZXR1cm4gcHJvcCBpbiByZWNvcmQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0aWVzPFggZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgWSBleHRlbmRzIFByb3BlcnR5S2V5PihcbiAgcmVjb3JkOiBYLFxuICBwcm9wczogWVtdXG4pOiByZWNvcmQgaXMgWCAmIFJlY29yZDxZLCB1bmtub3duPiB7XG4gIHJldHVybiBwcm9wcy5ldmVyeSgocHJvcCkgPT4gcHJvcCBpbiByZWNvcmQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEVycm9yIHtcbiAgcmV0dXJuIChcbiAgICBpc1JlY29yZChlcnJvcikgJiZcbiAgICB0eXBlb2YgZXJyb3IubmFtZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICAoZXJyb3Iuc3RhY2sgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3Iuc3RhY2sgPT09ICdzdHJpbmcnKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBYm9ydEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgRXJyb3IgJiB7IG5hbWU6ICdBYm9ydEVycm9yJyB9IHtcbiAgcmV0dXJuIGlzRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJztcbn1cblxuLyoqXG4gKiBHZXQgYGVycm9yLm1lc3NhZ2VgIChvciBgdW5kZWZpbmVkYCBpZiBub3QgcHJlc2VudClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yTWVzc2FnZShlcnJvcjogdW5rbm93bik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChpc0Vycm9yKGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuaW50ZXJmYWNlIEVycm9yV2l0aENvZGUge1xuICBjb2RlOiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JXaXRoQ29kZShlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEVycm9yV2l0aENvZGUge1xuICByZXR1cm4gaXNSZWNvcmQoZXJyb3IpICYmIHR5cGVvZiBlcnJvci5jb2RlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBHZXQgYGVycm9yLmNvZGVgIChvciBgdW5kZWZpbmVkYCBpZiBub3QgcHJlc2VudClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yQ29kZShlcnJvcjogdW5rbm93bik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChpc0Vycm9yV2l0aENvZGUoZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yLmNvZGU7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEFzc2VydHMgdGhhdCBzb21lIHR5cGUgaXMgdGhlIG5ldmVyIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5ldmVyKG1zZzogc3RyaW5nLCB4OiBuZXZlcik6IG5ldmVyIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2cgKyAnOiAnICsgeCk7XG59XG5cbmV4cG9ydCB0eXBlIENsYXNzPEUgZXh0ZW5kcyBFcnJvcj4gPSB7XG4gIG5ldyAoLi4uYXJnczogYW55W10pOiBFO1xuICBwcm90b3R5cGU6IEU7XG59O1xuXG4vKipcbiAqIEEgZGVjb3JhdG9yIHRvIGJlIHVzZWQgb24gZXJyb3IgY2xhc3Nlcy4gSXQgYWRkcyB0aGUgJ25hbWUnIHByb3BlcnR5IEFORCBwcm92aWRlcyBhIGN1c3RvbVxuICogJ2luc3RhbmNlb2YnIGhhbmRsZXIgdGhhdCB3b3JrcyBjb3JyZWN0bHkgYWNyb3NzIGV4ZWN1dGlvbiBjb250ZXh0cy5cbiAqXG4gKiAjIyMgRGV0YWlscyAjIyNcbiAqXG4gKiBBY2NvcmRpbmcgdG8gdGhlIEVjbWFTY3JpcHQncyBzcGVjLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBKYXZhU2NyaXB0J3MgYHggaW5zdGFuY2VvZiBZYCBvcGVyYXRvciBpcyB0byB3YWxrIHVwIHRoZVxuICogcHJvdG90eXBlIGNoYWluIG9mIG9iamVjdCAneCcsIGNoZWNraW5nIGlmIGFueSBjb25zdHJ1Y3RvciBpbiB0aGF0IGhpZXJhcmNoeSBpcyBfZXhhY3RseSB0aGUgc2FtZSBvYmplY3RfIGFzIHRoZVxuICogY29uc3RydWN0b3IgZnVuY3Rpb24gJ1knLlxuICpcbiAqIFVuZm9ydHVuYXRlbHksIGl0IGhhcHBlbnMgaW4gdmFyaW91cyBzaXR1YXRpb25zIHRoYXQgZGlmZmVyZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uIG9iamVjdHMgZ2V0IGNyZWF0ZWQgZm9yIHdoYXRcbiAqIGFwcGVhcnMgdG8gYmUgdGhlIHZlcnkgc2FtZSBjbGFzcy4gVGhpcyBsZWFkcyB0byBzdXJwcmlzaW5nIGJlaGF2aW9yIHdoZXJlIGBpbnN0YW5jZW9mYCByZXR1cm5zIGZhbHNlIHRob3VnaCBpdCBpc1xuICoga25vd24gdGhhdCB0aGUgb2JqZWN0IGlzIGluZGVlZCBhbiBpbnN0YW5jZSBvZiB0aGF0IGNsYXNzLiBPbmUgcGFydGljdWxhciBjYXNlIHdoZXJlIHRoaXMgaGFwcGVucyBpcyB3aGVuIGNvbnN0cnVjdG9yXG4gKiAnWScgYmVsb25ncyB0byBhIGRpZmZlcmVudCByZWFsbSB0aGFuIHRoZSBjb25zdHVjdG9yIHdpdGggd2hpY2ggJ3gnIHdhcyBpbnN0YW50aWF0ZWQuIEFub3RoZXIgY2FzZSBpcyB3aGVuIHR3byBjb3BpZXNcbiAqIG9mIHRoZSBzYW1lIGxpYnJhcnkgZ2V0cyBsb2FkZWQgaW4gdGhlIHNhbWUgcmVhbG0uXG4gKlxuICogSW4gcHJhY3RpY2UsIHRoaXMgdGVuZHMgdG8gY2F1c2UgaXNzdWVzIHdoZW4gY3Jvc3NpbmcgdGhlIHdvcmtmbG93LXNhbmRib3hpbmcgYm91bmRhcnkgKHNpbmNlIE5vZGUncyB2bSBtb2R1bGVcbiAqIHJlYWxseSBjcmVhdGVzIG5ldyBleGVjdXRpb24gcmVhbG1zKSwgYXMgd2VsbCBhcyB3aGVuIHJ1bm5pbmcgdGVzdHMgdXNpbmcgSmVzdCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qZXN0anMvamVzdC9pc3N1ZXMvMjU0OVxuICogZm9yIHNvbWUgZGV0YWlscyBvbiB0aGF0IG9uZSkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpbmplY3RzIGEgY3VzdG9tICdpbnN0YW5jZW9mJyBoYW5kbGVyIGludG8gdGhlIHByb3RvdHlwZSBvZiAnY2xhenonLCB3aGljaCBpcyBib3RoIGNyb3NzLXJlYWxtIHNhZmUgYW5kXG4gKiBjcm9zcy1jb3BpZXMtb2YtdGhlLXNhbWUtbGliIHNhZmUuIEl0IHdvcmtzIGJ5IGFkZGluZyBhIHNwZWNpYWwgc3ltYm9sIHByb3BlcnR5IHRvIHRoZSBwcm90b3R5cGUgb2YgJ2NsYXp6JywgYW5kIHRoZW5cbiAqIGNoZWNraW5nIGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhhdCBzeW1ib2wuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcjxFIGV4dGVuZHMgRXJyb3I+KG1hcmtlck5hbWU6IHN0cmluZyk6IChjbGF6ejogQ2xhc3M8RT4pID0+IHZvaWQge1xuICByZXR1cm4gKGNsYXp6OiBDbGFzczxFPik6IHZvaWQgPT4ge1xuICAgIGNvbnN0IG1hcmtlciA9IFN5bWJvbC5mb3IoYF9fdGVtcG9yYWxfaXMke21hcmtlck5hbWV9YCk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhenoucHJvdG90eXBlLCAnbmFtZScsIHsgdmFsdWU6IG1hcmtlck5hbWUsIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXp6LnByb3RvdHlwZSwgbWFya2VyLCB7IHZhbHVlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhenosIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9iamVjdC1zaG9ydGhhbmRcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAodGhpczogYW55LCBlcnJvcjogb2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzID09PSBjbGF6eikge1xuICAgICAgICAgIHJldHVybiBpc1JlY29yZChlcnJvcikgJiYgKGVycm9yIGFzIGFueSlbbWFya2VyXSA9PT0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAndGhpcycgbXVzdCBiZSBhIF9zdWJjbGFzc18gb2YgY2xhenogdGhhdCBkb2Vzbid0IHJlZGVmaW5lZCBbU3ltYm9sLmhhc0luc3RhbmNlXSwgc28gdGhhdCBpdCBpbmhlcml0ZWRcbiAgICAgICAgICAvLyBmcm9tIGNsYXp6J3MgW1N5bWJvbC5oYXNJbnN0YW5jZV0uIElmIHdlIGRvbid0IGhhbmRsZSB0aGlzIHBhcnRpY3VsYXIgc2l0dWF0aW9uLCB0aGVuXG4gICAgICAgICAgLy8gYHggaW5zdGFuY2VvZiBTdWJjbGFzc09mUGFyZW50YCB3b3VsZCByZXR1cm4gdHJ1ZSBmb3IgYW55IGluc3RhbmNlIG9mICdQYXJlbnQnLCB3aGljaCBpcyBjbGVhcmx5IHdyb25nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSWRlYWxseSwgaXQnZCBiZSBwcmVmZXJhYmxlIHRvIGF2b2lkIHRoaXMgY2FzZSBlbnRpcmVseSwgYnkgbWFraW5nIHN1cmUgdGhhdCBhbGwgc3ViY2xhc3NlcyBvZiAnY2xhenonXG4gICAgICAgICAgLy8gcmVkZWZpbmUgW1N5bWJvbC5oYXNJbnN0YW5jZV0sIGJ1dCB3ZSBjYW4ndCBlbmZvcmNlIHRoYXQuIFdlIHRoZXJlZm9yZSBmYWxsYmFjayB0byB0aGUgZGVmYXVsdCBpbnN0YW5jZW9mXG4gICAgICAgICAgLy8gYmVoYXZpb3IgKHdoaWNoIGlzIE5PVCBjcm9zcy1yZWFsbSBzYWZlKS5cbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihlcnJvcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gIH07XG59XG4iLCJpbXBvcnQgdHlwZSB7IGNvcmVzZGsgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQgdHlwZSB7IFZlcnNpb25pbmdJbnRlbnQgYXMgVmVyc2lvbmluZ0ludGVudFN0cmluZyB9IGZyb20gJy4vdmVyc2lvbmluZy1pbnRlbnQnO1xuaW1wb3J0IHsgYXNzZXJ0TmV2ZXIsIGNoZWNrRXh0ZW5kcyB9IGZyb20gJy4vdHlwZS1oZWxwZXJzJztcblxuLy8gQXZvaWQgaW1wb3J0aW5nIHRoZSBwcm90byBpbXBsZW1lbnRhdGlvbiB0byByZWR1Y2Ugd29ya2Zsb3cgYnVuZGxlIHNpemVcbi8vIENvcGllZCBmcm9tIGNvcmVzZGsuY29tbW9uLlZlcnNpb25pbmdJbnRlbnRcbi8qKlxuICogUHJvdG9idWYgZW51bSByZXByZXNlbnRhdGlvbiBvZiB7QGxpbmsgVmVyc2lvbmluZ0ludGVudFN0cmluZ30uXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgZW51bSBWZXJzaW9uaW5nSW50ZW50IHtcbiAgVU5TUEVDSUZJRUQgPSAwLFxuICBDT01QQVRJQkxFID0gMSxcbiAgREVGQVVMVCA9IDIsXG59XG5cbmNoZWNrRXh0ZW5kczxjb3Jlc2RrLmNvbW1vbi5WZXJzaW9uaW5nSW50ZW50LCBWZXJzaW9uaW5nSW50ZW50PigpO1xuY2hlY2tFeHRlbmRzPFZlcnNpb25pbmdJbnRlbnQsIGNvcmVzZGsuY29tbW9uLlZlcnNpb25pbmdJbnRlbnQ+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZXJzaW9uaW5nSW50ZW50VG9Qcm90byhpbnRlbnQ6IFZlcnNpb25pbmdJbnRlbnRTdHJpbmcgfCB1bmRlZmluZWQpOiBWZXJzaW9uaW5nSW50ZW50IHtcbiAgc3dpdGNoIChpbnRlbnQpIHtcbiAgICBjYXNlICdERUZBVUxUJzpcbiAgICAgIHJldHVybiBWZXJzaW9uaW5nSW50ZW50LkRFRkFVTFQ7XG4gICAgY2FzZSAnQ09NUEFUSUJMRSc6XG4gICAgICByZXR1cm4gVmVyc2lvbmluZ0ludGVudC5DT01QQVRJQkxFO1xuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgcmV0dXJuIFZlcnNpb25pbmdJbnRlbnQuVU5TUEVDSUZJRUQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIGFzc2VydE5ldmVyKCdVbmV4cGVjdGVkIFZlcnNpb25pbmdJbnRlbnQnLCBpbnRlbnQpO1xuICB9XG59XG4iLCIvKipcbiAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGludGVuZHMgY2VydGFpbiBjb21tYW5kcyB0byBiZSBydW4gb24gYSBjb21wYXRpYmxlIHdvcmtlciBCdWlsZCBJZFxuICogdmVyc2lvbiBvciBub3QuXG4gKlxuICogYENPTVBBVElCTEVgIGluZGljYXRlcyB0aGF0IHRoZSBjb21tYW5kIHNob3VsZCBydW4gb24gYSB3b3JrZXIgd2l0aCBjb21wYXRpYmxlIHZlcnNpb24gaWZcbiAqIHBvc3NpYmxlLiBJdCBtYXkgbm90IGJlIHBvc3NpYmxlIGlmIHRoZSB0YXJnZXQgdGFzayBxdWV1ZSBkb2VzIG5vdCBhbHNvIGhhdmUga25vd2xlZGdlIG9mIHRoZVxuICogY3VycmVudCB3b3JrZXIncyBCdWlsZCBJZC5cbiAqXG4gKiBgREVGQVVMVGAgaW5kaWNhdGVzIHRoYXQgdGhlIGNvbW1hbmQgc2hvdWxkIHJ1biBvbiB0aGUgdGFyZ2V0IHRhc2sgcXVldWUncyBjdXJyZW50XG4gKiBvdmVyYWxsLWRlZmF1bHQgQnVpbGQgSWQuXG4gKlxuICogV2hlcmUgdGhpcyB0eXBlIGlzIGFjY2VwdGVkIG9wdGlvbmFsbHksIGFuIHVuc2V0IHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSBTREsgc2hvdWxkIGNob29zZSB0aGVcbiAqIG1vc3Qgc2Vuc2libGUgZGVmYXVsdCBiZWhhdmlvciBmb3IgdGhlIHR5cGUgb2YgY29tbWFuZCwgYWNjb3VudGluZyBmb3Igd2hldGhlciB0aGUgY29tbWFuZCB3aWxsXG4gKiBiZSBydW4gb24gdGhlIHNhbWUgdGFzayBxdWV1ZSBhcyB0aGUgY3VycmVudCB3b3JrZXIuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgdHlwZSBWZXJzaW9uaW5nSW50ZW50ID0gJ0NPTVBBVElCTEUnIHwgJ0RFRkFVTFQnO1xuIiwiaW1wb3J0IHsgV29ya2Zsb3csIFdvcmtmbG93UmVzdWx0VHlwZSwgU2lnbmFsRGVmaW5pdGlvbiB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5cbi8qKlxuICogQmFzZSBXb3JrZmxvd0hhbmRsZSBpbnRlcmZhY2UsIGV4dGVuZGVkIGluIHdvcmtmbG93IGFuZCBjbGllbnQgbGlicy5cbiAqXG4gKiBUcmFuc2Zvcm1zIGEgd29ya2Zsb3cgaW50ZXJmYWNlIGBUYCBpbnRvIGEgY2xpZW50IGludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCYXNlV29ya2Zsb3dIYW5kbGU8VCBleHRlbmRzIFdvcmtmbG93PiB7XG4gIC8qKlxuICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBXb3JrZmxvdyBleGVjdXRpb24gY29tcGxldGVzXG4gICAqL1xuICByZXN1bHQoKTogUHJvbWlzZTxXb3JrZmxvd1Jlc3VsdFR5cGU8VD4+O1xuXG4gIC8qKlxuICAgKiBTaWduYWwgYSBydW5uaW5nIFdvcmtmbG93LlxuICAgKlxuICAgKiBAcGFyYW0gZGVmIGEgc2lnbmFsIGRlZmluaXRpb24gYXMgcmV0dXJuZWQgZnJvbSB7QGxpbmsgZGVmaW5lU2lnbmFsfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBhd2FpdCBoYW5kbGUuc2lnbmFsKGluY3JlbWVudFNpZ25hbCwgMyk7XG4gICAqIGBgYFxuICAgKi9cbiAgc2lnbmFsPEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdLCBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihcbiAgICBkZWY6IFNpZ25hbERlZmluaXRpb248QXJncywgTmFtZT4gfCBzdHJpbmcsXG4gICAgLi4uYXJnczogQXJnc1xuICApOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgd29ya2Zsb3dJZCBvZiB0aGUgY3VycmVudCBXb3JrZmxvd1xuICAgKi9cbiAgcmVhZG9ubHkgd29ya2Zsb3dJZDogc3RyaW5nO1xufVxuIiwiaW1wb3J0IHR5cGUgeyB0ZW1wb3JhbCwgZ29vZ2xlIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHsgU2VhcmNoQXR0cmlidXRlcywgV29ya2Zsb3cgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgUmV0cnlQb2xpY3kgfSBmcm9tICcuL3JldHJ5LXBvbGljeSc7XG5pbXBvcnQgeyBEdXJhdGlvbiwgbXNPcHRpb25hbFRvVHMgfSBmcm9tICcuL3RpbWUnO1xuaW1wb3J0IHsgY2hlY2tFeHRlbmRzLCBSZXBsYWNlIH0gZnJvbSAnLi90eXBlLWhlbHBlcnMnO1xuXG4vLyBBdm9pZCBpbXBvcnRpbmcgdGhlIHByb3RvIGltcGxlbWVudGF0aW9uIHRvIHJlZHVjZSB3b3JrZmxvdyBidW5kbGUgc2l6ZVxuLy8gQ29waWVkIGZyb20gdGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93SWRSZXVzZVBvbGljeVxuLyoqXG4gKiBDb25jZXB0OiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL2NvbmNlcHRzL3doYXQtaXMtYS13b3JrZmxvdy1pZC1yZXVzZS1wb2xpY3kvIHwgV29ya2Zsb3cgSWQgUmV1c2UgUG9saWN5fVxuICpcbiAqIFdoZXRoZXIgYSBXb3JrZmxvdyBjYW4gYmUgc3RhcnRlZCB3aXRoIGEgV29ya2Zsb3cgSWQgb2YgYSBDbG9zZWQgV29ya2Zsb3cuXG4gKlxuICogKk5vdGU6IEEgV29ya2Zsb3cgY2FuIG5ldmVyIGJlIHN0YXJ0ZWQgd2l0aCBhIFdvcmtmbG93IElkIG9mIGEgUnVubmluZyBXb3JrZmxvdy4qXG4gKi9cbmV4cG9ydCBlbnVtIFdvcmtmbG93SWRSZXVzZVBvbGljeSB7XG4gIC8qKlxuICAgKiBObyBuZWVkIHRvIHVzZSB0aGlzLlxuICAgKlxuICAgKiAoSWYgYSBgV29ya2Zsb3dJZFJldXNlUG9saWN5YCBpcyBzZXQgdG8gdGhpcywgb3IgaXMgbm90IHNldCBhdCBhbGwsIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZC4pXG4gICAqL1xuICBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfVU5TUEVDSUZJRUQgPSAwLFxuXG4gIC8qKlxuICAgKiBUaGUgV29ya2Zsb3cgY2FuIGJlIHN0YXJ0ZWQgaWYgdGhlIHByZXZpb3VzIFdvcmtmbG93IGlzIGluIGEgQ2xvc2VkIHN0YXRlLlxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX0FMTE9XX0RVUExJQ0FURSA9IDEsXG5cbiAgLyoqXG4gICAqIFRoZSBXb3JrZmxvdyBjYW4gYmUgc3RhcnRlZCBpZiB0aGUgcHJldmlvdXMgV29ya2Zsb3cgaXMgaW4gYSBDbG9zZWQgc3RhdGUgdGhhdCBpcyBub3QgQ29tcGxldGVkLlxuICAgKi9cbiAgV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX0FMTE9XX0RVUExJQ0FURV9GQUlMRURfT05MWSA9IDIsXG5cbiAgLyoqXG4gICAqIFRoZSBXb3JrZmxvdyBjYW5ub3QgYmUgc3RhcnRlZC5cbiAgICovXG4gIFdPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9SRUpFQ1RfRFVQTElDQVRFID0gMyxcblxuICAvKipcbiAgICogVGVybWluYXRlIHRoZSBjdXJyZW50IHdvcmtmbG93IGlmIG9uZSBpcyBhbHJlYWR5IHJ1bm5pbmcuXG4gICAqL1xuICBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfVEVSTUlOQVRFX0lGX1JVTk5JTkcgPSA0LFxufVxuXG5jaGVja0V4dGVuZHM8dGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93SWRSZXVzZVBvbGljeSwgV29ya2Zsb3dJZFJldXNlUG9saWN5PigpO1xuY2hlY2tFeHRlbmRzPFdvcmtmbG93SWRSZXVzZVBvbGljeSwgdGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93SWRSZXVzZVBvbGljeT4oKTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXNlV29ya2Zsb3dPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgYSBXb3JrZmxvdyBjYW4gYmUgc3RhcnRlZCB3aXRoIGEgV29ya2Zsb3cgSWQgb2YgYSBDbG9zZWQgV29ya2Zsb3cuXG4gICAqXG4gICAqICpOb3RlOiBBIFdvcmtmbG93IGNhbiBuZXZlciBiZSBzdGFydGVkIHdpdGggYSBXb3JrZmxvdyBJZCBvZiBhIFJ1bm5pbmcgV29ya2Zsb3cuKlxuICAgKlxuICAgKiBAZGVmYXVsdCB7QGxpbmsgV29ya2Zsb3dJZFJldXNlUG9saWN5LldPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9BTExPV19EVVBMSUNBVEV9XG4gICAqL1xuICB3b3JrZmxvd0lkUmV1c2VQb2xpY3k/OiBXb3JrZmxvd0lkUmV1c2VQb2xpY3k7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGhvdyBhIFdvcmtmbG93IEV4ZWN1dGlvbiBpcyByZXRyaWVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBXb3JrZmxvdyBFeGVjdXRpb25zIGFyZSBub3QgcmV0cmllZC4gRG8gbm90IG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL2NvbmNlcHRzL3doYXQtaXMtYS1yZXRyeS1wb2xpY3kvIHwgTW9yZSBpbmZvcm1hdGlvbn0uXG4gICAqL1xuICByZXRyeT86IFJldHJ5UG9saWN5O1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjcm9uIHNjaGVkdWxlIGZvciBXb3JrZmxvdy4gSWYgYSBjcm9uIHNjaGVkdWxlIGlzIHNwZWNpZmllZCwgdGhlIFdvcmtmbG93IHdpbGwgcnVuIGFzIGEgY3JvbiBiYXNlZCBvbiB0aGVcbiAgICogc2NoZWR1bGUuIFRoZSBzY2hlZHVsaW5nIHdpbGwgYmUgYmFzZWQgb24gVVRDIHRpbWUuIFRoZSBzY2hlZHVsZSBmb3IgdGhlIG5leHQgcnVuIG9ubHkgaGFwcGVucyBhZnRlciB0aGUgY3VycmVudFxuICAgKiBydW4gaXMgY29tcGxldGVkL2ZhaWxlZC90aW1lb3V0LiBJZiBhIFJldHJ5UG9saWN5IGlzIGFsc28gc3VwcGxpZWQsIGFuZCB0aGUgV29ya2Zsb3cgZmFpbGVkIG9yIHRpbWVkIG91dCwgdGhlXG4gICAqIFdvcmtmbG93IHdpbGwgYmUgcmV0cmllZCBiYXNlZCBvbiB0aGUgcmV0cnkgcG9saWN5LiBXaGlsZSB0aGUgV29ya2Zsb3cgaXMgcmV0cnlpbmcsIGl0IHdvbid0IHNjaGVkdWxlIGl0cyBuZXh0IHJ1bi5cbiAgICogSWYgdGhlIG5leHQgc2NoZWR1bGUgaXMgZHVlIHdoaWxlIHRoZSBXb3JrZmxvdyBpcyBydW5uaW5nIChvciByZXRyeWluZyksIHRoZW4gaXQgd2lsbCBza2lwIHRoYXQgc2NoZWR1bGUuIENyb25cbiAgICogV29ya2Zsb3cgd2lsbCBub3Qgc3RvcCB1bnRpbCBpdCBpcyB0ZXJtaW5hdGVkIG9yIGNhbmNlbGxlZCAoYnkgcmV0dXJuaW5nIHRlbXBvcmFsLkNhbmNlbGVkRXJyb3IpLlxuICAgKiBodHRwczovL2Nyb250YWIuZ3VydS8gaXMgdXNlZnVsIGZvciB0ZXN0aW5nIHlvdXIgY3JvbiBleHByZXNzaW9ucy5cbiAgICovXG4gIGNyb25TY2hlZHVsZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmaWVzIGFkZGl0aW9uYWwgbm9uLWluZGV4ZWQgaW5mb3JtYXRpb24gdG8gYXR0YWNoIHRvIHRoZSBXb3JrZmxvdyBFeGVjdXRpb24uIFRoZSB2YWx1ZXMgY2FuIGJlIGFueXRoaW5nIHRoYXRcbiAgICogaXMgc2VyaWFsaXphYmxlIGJ5IHtAbGluayBEYXRhQ29udmVydGVyfS5cbiAgICovXG4gIG1lbW8/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIGFkZGl0aW9uYWwgaW5kZXhlZCBpbmZvcm1hdGlvbiB0byBhdHRhY2ggdG8gdGhlIFdvcmtmbG93IEV4ZWN1dGlvbi4gTW9yZSBpbmZvOlxuICAgKiBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vZG9jcy90eXBlc2NyaXB0L3NlYXJjaC1hdHRyaWJ1dGVzXG4gICAqXG4gICAqIFZhbHVlcyBhcmUgYWx3YXlzIGNvbnZlcnRlZCB1c2luZyB7QGxpbmsgSnNvblBheWxvYWRDb252ZXJ0ZXJ9LCBldmVuIHdoZW4gYSBjdXN0b20gZGF0YSBjb252ZXJ0ZXIgaXMgcHJvdmlkZWQuXG4gICAqL1xuICBzZWFyY2hBdHRyaWJ1dGVzPzogU2VhcmNoQXR0cmlidXRlcztcbn1cblxuZXhwb3J0IHR5cGUgV2l0aFdvcmtmbG93QXJnczxXIGV4dGVuZHMgV29ya2Zsb3csIFQ+ID0gVCAmXG4gIChQYXJhbWV0ZXJzPFc+IGV4dGVuZHMgW2FueSwgLi4uYW55W11dXG4gICAgPyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgV29ya2Zsb3dcbiAgICAgICAgICovXG4gICAgICAgIGFyZ3M6IFBhcmFtZXRlcnM8Vz4gfCBSZWFkb25seTxQYXJhbWV0ZXJzPFc+PjtcbiAgICAgIH1cbiAgICA6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBXb3JrZmxvd1xuICAgICAgICAgKi9cbiAgICAgICAgYXJncz86IFBhcmFtZXRlcnM8Vz4gfCBSZWFkb25seTxQYXJhbWV0ZXJzPFc+PjtcbiAgICAgIH0pO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93RHVyYXRpb25PcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB0aW1lIGFmdGVyIHdoaWNoIHdvcmtmbG93IHJ1biBpcyBhdXRvbWF0aWNhbGx5IHRlcm1pbmF0ZWQgYnkgVGVtcG9yYWwgc2VydmljZS4gRG8gbm90XG4gICAqIHJlbHkgb24gcnVuIHRpbWVvdXQgZm9yIGJ1c2luZXNzIGxldmVsIHRpbWVvdXRzLiBJdCBpcyBwcmVmZXJyZWQgdG8gdXNlIGluIHdvcmtmbG93IHRpbWVyc1xuICAgKiBmb3IgdGhpcyBwdXJwb3NlLlxuICAgKlxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHdvcmtmbG93UnVuVGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKlxuICAgKiBUaGUgdGltZSBhZnRlciB3aGljaCB3b3JrZmxvdyBleGVjdXRpb24gKHdoaWNoIGluY2x1ZGVzIHJ1biByZXRyaWVzIGFuZCBjb250aW51ZSBhcyBuZXcpIGlzXG4gICAqIGF1dG9tYXRpY2FsbHkgdGVybWluYXRlZCBieSBUZW1wb3JhbCBzZXJ2aWNlLiBEbyBub3QgcmVseSBvbiBleGVjdXRpb24gdGltZW91dCBmb3IgYnVzaW5lc3NcbiAgICogbGV2ZWwgdGltZW91dHMuIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgaW4gd29ya2Zsb3cgdGltZXJzIGZvciB0aGlzIHB1cnBvc2UuXG4gICAqXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgd29ya2Zsb3dFeGVjdXRpb25UaW1lb3V0PzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqIE1heGltdW0gZXhlY3V0aW9uIHRpbWUgb2YgYSBzaW5nbGUgd29ya2Zsb3cgdGFzay4gRGVmYXVsdCBpcyAxMCBzZWNvbmRzLlxuICAgKlxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHdvcmtmbG93VGFza1RpbWVvdXQ/OiBEdXJhdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgQ29tbW9uV29ya2Zsb3dPcHRpb25zID0gQmFzZVdvcmtmbG93T3B0aW9ucyAmIFdvcmtmbG93RHVyYXRpb25PcHRpb25zO1xuXG5leHBvcnQgdHlwZSBXaXRoQ29tcGlsZWRXb3JrZmxvd09wdGlvbnM8VCBleHRlbmRzIENvbW1vbldvcmtmbG93T3B0aW9ucz4gPSBSZXBsYWNlPFxuICBULFxuICB7XG4gICAgd29ya2Zsb3dFeGVjdXRpb25UaW1lb3V0PzogZ29vZ2xlLnByb3RvYnVmLklEdXJhdGlvbjtcbiAgICB3b3JrZmxvd1J1blRpbWVvdXQ/OiBnb29nbGUucHJvdG9idWYuSUR1cmF0aW9uO1xuICAgIHdvcmtmbG93VGFza1RpbWVvdXQ/OiBnb29nbGUucHJvdG9idWYuSUR1cmF0aW9uO1xuICB9XG4+O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVdvcmtmbG93T3B0aW9uczxUIGV4dGVuZHMgQ29tbW9uV29ya2Zsb3dPcHRpb25zPihvcHRpb25zOiBUKTogV2l0aENvbXBpbGVkV29ya2Zsb3dPcHRpb25zPFQ+IHtcbiAgY29uc3QgeyB3b3JrZmxvd0V4ZWN1dGlvblRpbWVvdXQsIHdvcmtmbG93UnVuVGltZW91dCwgd29ya2Zsb3dUYXNrVGltZW91dCwgLi4ucmVzdCB9ID0gb3B0aW9ucztcblxuICByZXR1cm4ge1xuICAgIC4uLnJlc3QsXG4gICAgd29ya2Zsb3dFeGVjdXRpb25UaW1lb3V0OiBtc09wdGlvbmFsVG9Ucyh3b3JrZmxvd0V4ZWN1dGlvblRpbWVvdXQpLFxuICAgIHdvcmtmbG93UnVuVGltZW91dDogbXNPcHRpb25hbFRvVHMod29ya2Zsb3dSdW5UaW1lb3V0KSxcbiAgICB3b3JrZmxvd1Rhc2tUaW1lb3V0OiBtc09wdGlvbmFsVG9Ucyh3b3JrZmxvd1Rhc2tUaW1lb3V0KSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RXb3JrZmxvd1R5cGU8VCBleHRlbmRzIFdvcmtmbG93Pih3b3JrZmxvd1R5cGVPckZ1bmM6IHN0cmluZyB8IFQpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIHdvcmtmbG93VHlwZU9yRnVuYyA9PT0gJ3N0cmluZycpIHJldHVybiB3b3JrZmxvd1R5cGVPckZ1bmMgYXMgc3RyaW5nO1xuICBpZiAodHlwZW9mIHdvcmtmbG93VHlwZU9yRnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh3b3JrZmxvd1R5cGVPckZ1bmM/Lm5hbWUpIHJldHVybiB3b3JrZmxvd1R5cGVPckZ1bmMubmFtZTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHdvcmtmbG93IHR5cGU6IHRoZSB3b3JrZmxvdyBmdW5jdGlvbiBpcyBhbm9ueW1vdXMnKTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgIGBJbnZhbGlkIHdvcmtmbG93IHR5cGU6IGV4cGVjdGVkIGVpdGhlciBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLCBnb3QgJyR7dHlwZW9mIHdvcmtmbG93VHlwZU9yRnVuY30nYFxuICApO1xufVxuIiwiaW1wb3J0IHtcbiAgaXNDYW5jZWxsYXRpb24sXG4gIE5leHQsXG4gIFdvcmtmbG93RXhlY3V0ZUlucHV0LFxuICBXb3JrZmxvd0luYm91bmRDYWxsc0ludGVyY2VwdG9yLFxuICBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvcixcbiAgd29ya2Zsb3dJbmZvLFxuICBXb3JrZmxvd0luZm8sXG4gIFdvcmtmbG93SW50ZXJjZXB0b3JzRmFjdG9yeSxcbiAgbG9nLFxuICBDb250aW51ZUFzTmV3LFxuICBHZXRMb2dBdHRyaWJ1dGVzSW5wdXQsXG59IGZyb20gJ0B0ZW1wb3JhbGlvL3dvcmtmbG93JztcbmltcG9ydCB7IHVudHJhY2tQcm9taXNlIH0gZnJvbSAnQHRlbXBvcmFsaW8vd29ya2Zsb3cvbGliL3N0YWNrLWhlbHBlcnMnO1xuXG4vKipcbiAqIFJldHVybnMgYSBtYXAgb2YgYXR0cmlidXRlcyB0byBiZSBzZXQgb24gbG9nIG1lc3NhZ2VzIGZvciBhIGdpdmVuIFdvcmtmbG93XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3b3JrZmxvd0xvZ0F0dHJpYnV0ZXMoaW5mbzogV29ya2Zsb3dJbmZvKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICByZXR1cm4ge1xuICAgIG5hbWVzcGFjZTogaW5mby5uYW1lc3BhY2UsXG4gICAgdGFza1F1ZXVlOiBpbmZvLnRhc2tRdWV1ZSxcbiAgICB3b3JrZmxvd0lkOiBpbmZvLndvcmtmbG93SWQsXG4gICAgcnVuSWQ6IGluZm8ucnVuSWQsXG4gICAgd29ya2Zsb3dUeXBlOiBpbmZvLndvcmtmbG93VHlwZSxcbiAgfTtcbn1cblxuLyoqIExvZ3Mgd29ya2Zsb3cgZXhlY3V0aW9uIHN0YXJ0cyBhbmQgY29tcGxldGlvbnMsIGF0dGFjaGVzIGxvZyBhdHRyaWJ1dGVzIHRvIGB3b3JrZmxvdy5sb2dgIGNhbGxzICAqL1xuZXhwb3J0IGNsYXNzIFdvcmtmbG93TG9nSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBXb3JrZmxvd0luYm91bmRDYWxsc0ludGVyY2VwdG9yLCBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvciB7XG4gIGdldExvZ0F0dHJpYnV0ZXMoXG4gICAgaW5wdXQ6IEdldExvZ0F0dHJpYnV0ZXNJbnB1dCxcbiAgICBuZXh0OiBOZXh0PFdvcmtmbG93T3V0Ym91bmRDYWxsc0ludGVyY2VwdG9yLCAnZ2V0TG9nQXR0cmlidXRlcyc+XG4gICk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgICByZXR1cm4gbmV4dCh7IC4uLmlucHV0LCAuLi53b3JrZmxvd0xvZ0F0dHJpYnV0ZXMod29ya2Zsb3dJbmZvKCkpIH0pO1xuICB9XG5cbiAgZXhlY3V0ZShpbnB1dDogV29ya2Zsb3dFeGVjdXRlSW5wdXQsIG5leHQ6IE5leHQ8V29ya2Zsb3dJbmJvdW5kQ2FsbHNJbnRlcmNlcHRvciwgJ2V4ZWN1dGUnPik6IFByb21pc2U8dW5rbm93bj4ge1xuICAgIGxvZy5kZWJ1ZygnV29ya2Zsb3cgc3RhcnRlZCcpO1xuICAgIGNvbnN0IHAgPSBuZXh0KGlucHV0KS50aGVuKFxuICAgICAgKHJlcykgPT4ge1xuICAgICAgICBsb2cuZGVidWcoJ1dvcmtmbG93IGNvbXBsZXRlZCcpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSxcbiAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAvLyBBdm9pZCB1c2luZyBpbnN0YW5jZW9mIGNoZWNrcyBpbiBjYXNlIHRoZSBtb2R1bGVzIHRoZXkncmUgZGVmaW5lZCBpbiBsb2FkZWQgbW9yZSB0aGFuIG9uY2UsXG4gICAgICAgIC8vIGUuZy4gYnkgamVzdCBvciB3aGVuIG11bHRpcGxlIHZlcnNpb25zIGFyZSBpbnN0YWxsZWQuXG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoaXNDYW5jZWxsYXRpb24oZXJyb3IpKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoJ1dvcmtmbG93IGNvbXBsZXRlZCBhcyBjYW5jZWxsZWQnKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDb250aW51ZUFzTmV3KSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoJ1dvcmtmbG93IGNvbnRpbnVlZCBhcyBuZXcnKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2cud2FybignV29ya2Zsb3cgZmFpbGVkJywgeyBlcnJvciB9KTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgKTtcbiAgICAvLyBBdm9pZCBzaG93aW5nIHRoaXMgaW50ZXJjZXB0b3IgaW4gc3RhY2sgdHJhY2UgcXVlcnlcbiAgICB1bnRyYWNrUHJvbWlzZShwKTtcbiAgICByZXR1cm4gcDtcbiAgfVxufVxuXG4vKiogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBXb3JrZmxvd0xvZ0ludGVyY2VwdG9yfSBpbnN0ZWFkICovXG5leHBvcnQgY29uc3QgV29ya2Zsb3dJbmJvdW5kTG9nSW50ZXJjZXB0b3IgPSBXb3JrZmxvd0xvZ0ludGVyY2VwdG9yO1xuXG4vLyB0cy1wcnVuZS1pZ25vcmUtbmV4dFxuZXhwb3J0IGNvbnN0IGludGVyY2VwdG9yczogV29ya2Zsb3dJbnRlcmNlcHRvcnNGYWN0b3J5ID0gKCkgPT4ge1xuICBjb25zdCBpbnRlcmNlcHRvciA9IG5ldyBXb3JrZmxvd0xvZ0ludGVyY2VwdG9yKCk7XG4gIHJldHVybiB7IGluYm91bmQ6IFtpbnRlcmNlcHRvcl0sIG91dGJvdW5kOiBbaW50ZXJjZXB0b3JdIH07XG59O1xuIiwiLy8gQSBwb3J0IG9mIGFuIGFsZ29yaXRobSBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLmNvbT4sIDIwMTBcbi8vIGh0dHA6Ly9iYWFnb2UuY29tL2VuL1JhbmRvbU11c2luZ3MvamF2YXNjcmlwdC9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ucXVpbmxhbi9iZXR0ZXItcmFuZG9tLW51bWJlcnMtZm9yLWphdmFzY3JpcHQtbWlycm9yXG4vLyBPcmlnaW5hbCB3b3JrIGlzIHVuZGVyIE1JVCBsaWNlbnNlIC1cblxuLy8gQ29weXJpZ2h0IChDKSAyMDEwIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2Uub3JnPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8vIFRha2VuIGFuZCBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJhdS9zZWVkcmFuZG9tL2Jsb2IvcmVsZWFzZWQvbGliL2FsZWEuanNcblxuY2xhc3MgQWxlYSB7XG4gIHB1YmxpYyBjOiBudW1iZXI7XG4gIHB1YmxpYyBzMDogbnVtYmVyO1xuICBwdWJsaWMgczE6IG51bWJlcjtcbiAgcHVibGljIHMyOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Ioc2VlZDogbnVtYmVyW10pIHtcbiAgICBjb25zdCBtYXNoID0gbmV3IE1hc2goKTtcbiAgICAvLyBBcHBseSB0aGUgc2VlZGluZyBhbGdvcml0aG0gZnJvbSBCYWFnb2UuXG4gICAgdGhpcy5jID0gMTtcbiAgICB0aGlzLnMwID0gbWFzaC5tYXNoKFszMl0pO1xuICAgIHRoaXMuczEgPSBtYXNoLm1hc2goWzMyXSk7XG4gICAgdGhpcy5zMiA9IG1hc2gubWFzaChbMzJdKTtcbiAgICB0aGlzLnMwIC09IG1hc2gubWFzaChzZWVkKTtcbiAgICBpZiAodGhpcy5zMCA8IDApIHtcbiAgICAgIHRoaXMuczAgKz0gMTtcbiAgICB9XG4gICAgdGhpcy5zMSAtPSBtYXNoLm1hc2goc2VlZCk7XG4gICAgaWYgKHRoaXMuczEgPCAwKSB7XG4gICAgICB0aGlzLnMxICs9IDE7XG4gICAgfVxuICAgIHRoaXMuczIgLT0gbWFzaC5tYXNoKHNlZWQpO1xuICAgIGlmICh0aGlzLnMyIDwgMCkge1xuICAgICAgdGhpcy5zMiArPSAxO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBuZXh0KCk6IG51bWJlciB7XG4gICAgY29uc3QgdCA9IDIwOTE2MzkgKiB0aGlzLnMwICsgdGhpcy5jICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgICB0aGlzLnMwID0gdGhpcy5zMTtcbiAgICB0aGlzLnMxID0gdGhpcy5zMjtcbiAgICByZXR1cm4gKHRoaXMuczIgPSB0IC0gKHRoaXMuYyA9IHQgfCAwKSk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUk5HID0gKCkgPT4gbnVtYmVyO1xuXG5leHBvcnQgZnVuY3Rpb24gYWxlYShzZWVkOiBudW1iZXJbXSk6IFJORyB7XG4gIGNvbnN0IHhnID0gbmV3IEFsZWEoc2VlZCk7XG4gIHJldHVybiB4Zy5uZXh0LmJpbmQoeGcpO1xufVxuXG5leHBvcnQgY2xhc3MgTWFzaCB7XG4gIHByaXZhdGUgbiA9IDB4ZWZjODI0OWQ7XG5cbiAgcHVibGljIG1hc2goZGF0YTogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGxldCB7IG4gfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuICs9IGRhdGFbaV07XG4gICAgICBsZXQgaCA9IDAuMDI1MTk2MDMyODI0MTY5MzggKiBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBoICo9IG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIG4gKz0gaCAqIDB4MTAwMDAwMDAwOyAvLyAyXjMyXG4gICAgfVxuICAgIHRoaXMubiA9IG47XG4gICAgcmV0dXJuIChuID4+PiAwKSAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgQXN5bmNMb2NhbFN0b3JhZ2UgYXMgQUxTIH0gZnJvbSAnbm9kZTphc3luY19ob29rcyc7XG5pbXBvcnQgeyBDYW5jZWxsZWRGYWlsdXJlLCBEdXJhdGlvbiwgSWxsZWdhbFN0YXRlRXJyb3IgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuaW1wb3J0IHsgdW50cmFja1Byb21pc2UgfSBmcm9tICcuL3N0YWNrLWhlbHBlcnMnO1xuXG4vLyBBc3luY0xvY2FsU3RvcmFnZSBpcyBpbmplY3RlZCB2aWEgdm0gbW9kdWxlIGludG8gZ2xvYmFsIHNjb3BlLlxuLy8gSW4gY2FzZSBXb3JrZmxvdyBjb2RlIGlzIGltcG9ydGVkIGluIE5vZGUuanMgY29udGV4dCwgcmVwbGFjZSB3aXRoIGFuIGVtcHR5IGNsYXNzLlxuZXhwb3J0IGNvbnN0IEFzeW5jTG9jYWxTdG9yYWdlOiBuZXcgPFQ+KCkgPT4gQUxTPFQ+ID0gKGdsb2JhbFRoaXMgYXMgYW55KS5Bc3luY0xvY2FsU3RvcmFnZSA/PyBjbGFzcyB7fTtcblxuLyoqIE1hZ2ljIHN5bWJvbCB1c2VkIHRvIGNyZWF0ZSB0aGUgcm9vdCBzY29wZSAtIGludGVudGlvbmFsbHkgbm90IGV4cG9ydGVkICovXG5jb25zdCBOT19QQVJFTlQgPSBTeW1ib2woJ05PX1BBUkVOVCcpO1xuXG4vKipcbiAqIE9wdGlvbiBmb3IgY29uc3RydWN0aW5nIGEgQ2FuY2VsbGF0aW9uU2NvcGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYW5jZWxsYXRpb25TY29wZU9wdGlvbnMge1xuICAvKipcbiAgICogVGltZSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBzY29wZSBjYW5jZWxsYXRpb24gaXMgYXV0b21hdGljYWxseSByZXF1ZXN0ZWRcbiAgICovXG4gIHRpbWVvdXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIElmIGZhbHNlLCBwcmV2ZW50IG91dGVyIGNhbmNlbGxhdGlvbiBmcm9tIHByb3BhZ2F0aW5nIHRvIGlubmVyIHNjb3BlcywgQWN0aXZpdGllcywgdGltZXJzLCBhbmQgVHJpZ2dlcnMsIGRlZmF1bHRzIHRvIHRydWUuXG4gICAqIChTY29wZSBzdGlsbCBwcm9wYWdhdGVzIENhbmNlbGxlZEZhaWx1cmUgdGhyb3duIGZyb20gd2l0aGluKS5cbiAgICovXG4gIGNhbmNlbGxhYmxlOiBib29sZWFuO1xuICAvKipcbiAgICogQW4gb3B0aW9uYWwgQ2FuY2VsbGF0aW9uU2NvcGUgKHVzZWZ1bCBmb3IgcnVubmluZyBiYWNrZ3JvdW5kIHRhc2tzKS5cbiAgICogVGhlIGBOT19QQVJFTlRgIHN5bWJvbCBpcyByZXNlcnZlZCBmb3IgdGhlIHJvb3Qgc2NvcGUuXG4gICAqL1xuICBwYXJlbnQ/OiBDYW5jZWxsYXRpb25TY29wZSB8IHR5cGVvZiBOT19QQVJFTlQ7XG59XG5cbi8qKlxuICogSW4gdGhlIFNESywgV29ya2Zsb3dzIGFyZSByZXByZXNlbnRlZCBpbnRlcm5hbGx5IGJ5IGEgdHJlZSBvZiBzY29wZXMgd2hlcmUgdGhlIGBleGVjdXRlYCBmdW5jdGlvbiBydW5zIGluIHRoZSByb290IHNjb3BlLlxuICogQ2FuY2VsbGF0aW9uIHByb3BhZ2F0ZXMgZnJvbSBvdXRlciBzY29wZXMgdG8gaW5uZXIgb25lcyBhbmQgaXMgaGFuZGxlZCBieSBjYXRjaGluZyB7QGxpbmsgQ2FuY2VsbGVkRmFpbHVyZX1zXG4gKiB0aHJvd24gYnkgY2FuY2VsbGFibGUgb3BlcmF0aW9ucyAoc2VlIGJlbG93KS5cbiAqXG4gKiBTY29wZXMgYXJlIGNyZWF0ZWQgdXNpbmcgdGhlIGBDYW5jZWxsYXRpb25TY29wZWAgY29uc3RydWN0b3Igb3IgdGhlIHN0YXRpYyBoZWxwZXIgbWV0aG9kc1xuICoge0BsaW5rIGNhbmNlbGxhYmxlfSwge0BsaW5rIG5vbkNhbmNlbGxhYmxlfSBhbmQge0BsaW5rIHdpdGhUaW1lb3V0fS5cbiAqXG4gKiBXaGVuIGEgYENhbmNlbGxhdGlvblNjb3BlYCBpcyBjYW5jZWxsZWQsIGl0IHdpbGwgcHJvcGFnYXRlIGNhbmNlbGxhdGlvbiBhbnkgY2hpbGQgc2NvcGVzIGFuZCBhbnkgY2FuY2VsbGFibGVcbiAqIG9wZXJhdGlvbnMgY3JlYXRlZCB3aXRoaW4gaXQsIHN1Y2ggYXM6XG4gKlxuICogLSBBY3Rpdml0aWVzXG4gKiAtIENoaWxkIFdvcmtmbG93c1xuICogLSBUaW1lcnMgKGNyZWF0ZWQgd2l0aCB0aGUge0BsaW5rIHNsZWVwfSBmdW5jdGlvbilcbiAqIC0ge0BsaW5rIFRyaWdnZXJ9c1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGF3YWl0IENhbmNlbGxhdGlvblNjb3BlLmNhbmNlbGxhYmxlKGFzeW5jICgpID0+IHtcbiAqICAgY29uc3QgcHJvbWlzZSA9IHNvbWVBY3Rpdml0eSgpO1xuICogICBDYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCkuY2FuY2VsKCk7IC8vIENhbmNlbHMgdGhlIGFjdGl2aXR5XG4gKiAgIGF3YWl0IHByb21pc2U7IC8vIFRocm93cyBgQWN0aXZpdHlGYWlsdXJlYCB3aXRoIGBjYXVzZWAgc2V0IHRvIGBDYW5jZWxsZWRGYWlsdXJlYFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBzY29wZSA9IG5ldyBDYW5jZWxsYXRpb25TY29wZSgpO1xuICogY29uc3QgcHJvbWlzZSA9IHNjb3BlLnJ1bihzb21lQWN0aXZpdHkpO1xuICogc2NvcGUuY2FuY2VsKCk7IC8vIENhbmNlbHMgdGhlIGFjdGl2aXR5XG4gKiBhd2FpdCBwcm9taXNlOyAvLyBUaHJvd3MgYEFjdGl2aXR5RmFpbHVyZWAgd2l0aCBgY2F1c2VgIHNldCB0byBgQ2FuY2VsbGVkRmFpbHVyZWBcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ2FuY2VsbGF0aW9uU2NvcGUge1xuICAvKipcbiAgICogVGltZSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBzY29wZSBjYW5jZWxsYXRpb24gaXMgYXV0b21hdGljYWxseSByZXF1ZXN0ZWRcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSB0aW1lb3V0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJZiBmYWxzZSwgcHJldmVudCBvdXRlciBjYW5jZWxsYXRpb24gZnJvbSBwcm9wYWdhdGluZyB0byBpbm5lciBzY29wZXMsIEFjdGl2aXRpZXMsIHRpbWVycywgYW5kIFRyaWdnZXJzLCBkZWZhdWx0cyB0byB0cnVlLlxuICAgKiAoU2NvcGUgc3RpbGwgcHJvcGFnYXRlcyBDYW5jZWxsZWRGYWlsdXJlIHRocm93biBmcm9tIHdpdGhpbilcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBjYW5jZWxsYWJsZTogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIENhbmNlbGxhdGlvblNjb3BlICh1c2VmdWwgZm9yIHJ1bm5pbmcgYmFja2dyb3VuZCB0YXNrcyksIGRlZmF1bHRzIHRvIHtAbGluayBDYW5jZWxsYXRpb25TY29wZS5jdXJyZW50fSgpXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcGFyZW50PzogQ2FuY2VsbGF0aW9uU2NvcGU7XG5cbiAgLyoqXG4gICAqIFJlamVjdGVkIHdoZW4gc2NvcGUgY2FuY2VsbGF0aW9uIGlzIHJlcXVlc3RlZFxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNhbmNlbFJlcXVlc3RlZDogUHJvbWlzZTxuZXZlcj47XG5cbiAgI2NhbmNlbFJlcXVlc3RlZCA9IGZhbHNlO1xuXG4gIC8vIFR5cGVzY3JpcHQgZG9lcyBub3QgdW5kZXJzdGFuZCB0aGF0IHRoZSBQcm9taXNlIGV4ZWN1dG9yIHJ1bnMgc3luY2hyb25vdXNseSBpbiB0aGUgY29uc3RydWN0b3JcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIHByb3RlY3RlZCByZWFkb25seSByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQ7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IENhbmNlbGxhdGlvblNjb3BlT3B0aW9ucykge1xuICAgIHRoaXMudGltZW91dCA9IG9wdGlvbnM/LnRpbWVvdXQ7XG4gICAgdGhpcy5jYW5jZWxsYWJsZSA9IG9wdGlvbnM/LmNhbmNlbGxhYmxlID8/IHRydWU7XG4gICAgdGhpcy5jYW5jZWxSZXF1ZXN0ZWQgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBUeXBlc2NyaXB0IGRvZXMgbm90IHVuZGVyc3RhbmQgdGhhdCB0aGUgUHJvbWlzZSBleGVjdXRvciBydW5zIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMucmVqZWN0ID0gKGVycikgPT4ge1xuICAgICAgICB0aGlzLiNjYW5jZWxSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdW50cmFja1Byb21pc2UodGhpcy5jYW5jZWxSZXF1ZXN0ZWQpO1xuICAgIC8vIEF2b2lkIHVuaGFuZGxlZCByZWplY3Rpb25zXG4gICAgdW50cmFja1Byb21pc2UodGhpcy5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKSk7XG4gICAgaWYgKG9wdGlvbnM/LnBhcmVudCAhPT0gTk9fUEFSRU5UKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IG9wdGlvbnM/LnBhcmVudCB8fCBDYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCk7XG4gICAgICB0aGlzLiNjYW5jZWxSZXF1ZXN0ZWQgPSB0aGlzLnBhcmVudC4jY2FuY2VsUmVxdWVzdGVkO1xuICAgICAgdGhpcy5wYXJlbnQuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5yZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgY29uc2lkZXJlZENhbmNlbGxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy4jY2FuY2VsUmVxdWVzdGVkICYmIHRoaXMuY2FuY2VsbGFibGU7XG4gIH1cbiAgLyoqXG4gICAqIEFjdGl2YXRlIHRoZSBzY29wZSBhcyBjdXJyZW50IGFuZCBydW4gIGBmbmBcbiAgICpcbiAgICogQW55IHRpbWVycywgQWN0aXZpdGllcywgVHJpZ2dlcnMgYW5kIENhbmNlbGxhdGlvblNjb3BlcyBjcmVhdGVkIGluIHRoZSBib2R5IG9mIGBmbmBcbiAgICogYXV0b21hdGljYWxseSBsaW5rIHRoZWlyIGNhbmNlbGxhdGlvbiB0byB0aGlzIHNjb3BlLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByZXN1bHQgb2YgYGZuYFxuICAgKi9cbiAgcnVuPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIHN0b3JhZ2UucnVuKHRoaXMsIHRoaXMucnVuSW5Db250ZXh0LmJpbmQodGhpcywgZm4pIGFzICgpID0+IFByb21pc2U8VD4pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB0aGF0IHJ1bnMgYSBmdW5jdGlvbiBpbiBBc3luY0xvY2FsU3RvcmFnZSBjb250ZXh0LlxuICAgKlxuICAgKiBDb3VsZCBoYXZlIGJlZW4gd3JpdHRlbiBhcyBhbm9ueW1vdXMgZnVuY3Rpb24sIG1hZGUgaW50byBhIG1ldGhvZCBmb3IgaW1wcm92ZWQgc3RhY2sgdHJhY2VzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIHJ1bkluQ29udGV4dDxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKFxuICAgICAgICBzbGVlcCh0aGlzLnRpbWVvdXQpLnRoZW4oXG4gICAgICAgICAgKCkgPT4gdGhpcy5jYW5jZWwoKSxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAvLyBzY29wZSB3YXMgYWxyZWFkeSBjYW5jZWxsZWQsIGlnbm9yZVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBjYW5jZWwgdGhlIHNjb3BlIGFuZCBsaW5rZWQgY2hpbGRyZW5cbiAgICovXG4gIGNhbmNlbCgpOiB2b2lkIHtcbiAgICB0aGlzLnJlamVjdChuZXcgQ2FuY2VsbGVkRmFpbHVyZSgnQ2FuY2VsbGF0aW9uIHNjb3BlIGNhbmNlbGxlZCcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgXCJhY3RpdmVcIiBzY29wZVxuICAgKi9cbiAgc3RhdGljIGN1cnJlbnQoKTogQ2FuY2VsbGF0aW9uU2NvcGUge1xuICAgIC8vIFVzaW5nIGdsb2JhbHMgZGlyZWN0bHkgaW5zdGVhZCBvZiBhIGhlbHBlciBmdW5jdGlvbiB0byBhdm9pZCBjaXJjdWxhciBpbXBvcnRcbiAgICByZXR1cm4gc3RvcmFnZS5nZXRTdG9yZSgpID8/IChnbG9iYWxUaGlzIGFzIGFueSkuX19URU1QT1JBTF9BQ1RJVkFUT1JfXy5yb290U2NvcGU7XG4gIH1cblxuICAvKiogQWxpYXMgdG8gYG5ldyBDYW5jZWxsYXRpb25TY29wZSh7IGNhbmNlbGxhYmxlOiB0cnVlIH0pLnJ1bihmbilgICovXG4gIHN0YXRpYyBjYW5jZWxsYWJsZTxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiBuZXcgdGhpcyh7IGNhbmNlbGxhYmxlOiB0cnVlIH0pLnJ1bihmbik7XG4gIH1cblxuICAvKiogQWxpYXMgdG8gYG5ldyBDYW5jZWxsYXRpb25TY29wZSh7IGNhbmNlbGxhYmxlOiBmYWxzZSB9KS5ydW4oZm4pYCAqL1xuICBzdGF0aWMgbm9uQ2FuY2VsbGFibGU8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gbmV3IHRoaXMoeyBjYW5jZWxsYWJsZTogZmFsc2UgfSkucnVuKGZuKTtcbiAgfVxuXG4gIC8qKiBBbGlhcyB0byBgbmV3IENhbmNlbGxhdGlvblNjb3BlKHsgY2FuY2VsbGFibGU6IHRydWUsIHRpbWVvdXQgfSkucnVuKGZuKWAgKi9cbiAgc3RhdGljIHdpdGhUaW1lb3V0PFQ+KHRpbWVvdXQ6IG51bWJlciwgZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gbmV3IHRoaXMoeyBjYW5jZWxsYWJsZTogdHJ1ZSwgdGltZW91dCB9KS5ydW4oZm4pO1xuICB9XG59XG5cbmNvbnN0IHN0b3JhZ2UgPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2U8Q2FuY2VsbGF0aW9uU2NvcGU+KCk7XG5cbi8qKlxuICogQXZvaWQgZXhwb3NpbmcgdGhlIHN0b3JhZ2UgZGlyZWN0bHkgc28gaXQgZG9lc24ndCBnZXQgZnJvemVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlU3RvcmFnZSgpOiB2b2lkIHtcbiAgc3RvcmFnZS5kaXNhYmxlKCk7XG59XG5cbmV4cG9ydCBjbGFzcyBSb290Q2FuY2VsbGF0aW9uU2NvcGUgZXh0ZW5kcyBDYW5jZWxsYXRpb25TY29wZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgY2FuY2VsbGFibGU6IHRydWUsIHBhcmVudDogTk9fUEFSRU5UIH0pO1xuICB9XG5cbiAgY2FuY2VsKCk6IHZvaWQge1xuICAgIHRoaXMucmVqZWN0KG5ldyBDYW5jZWxsZWRGYWlsdXJlKCdXb3JrZmxvdyBjYW5jZWxsZWQnKSk7XG4gIH1cbn1cblxuLyoqIFRoaXMgZnVuY3Rpb24gaXMgaGVyZSB0byBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGlzIG1vZHVsZSBhbmQgd29ya2Zsb3cudHMgKi9cbmxldCBzbGVlcCA9IChfOiBEdXJhdGlvbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXJyb3IoJ1dvcmtmbG93IGhhcyBub3QgYmVlbiBwcm9wZXJseSBpbml0aWFsaXplZCcpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyU2xlZXBJbXBsZW1lbnRhdGlvbihmbjogdHlwZW9mIHNsZWVwKTogdm9pZCB7XG4gIHNsZWVwID0gZm47XG59XG4iLCJpbXBvcnQgeyBBY3Rpdml0eUZhaWx1cmUsIENhbmNlbGxlZEZhaWx1cmUsIENoaWxkV29ya2Zsb3dGYWlsdXJlIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uJztcbmltcG9ydCB7IFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi90eXBlLWhlbHBlcnMnO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCB3b3JrZmxvdyBlcnJvcnNcbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdXb3JrZmxvd0Vycm9yJylcbmV4cG9ydCBjbGFzcyBXb3JrZmxvd0Vycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuLyoqXG4gKiBUaHJvd24gaW4gd29ya2Zsb3cgd2hlbiBpdCB0cmllcyB0byBkbyBzb21ldGhpbmcgdGhhdCBub24tZGV0ZXJtaW5pc3RpYyBzdWNoIGFzIGNvbnN0cnVjdCBhIFdlYWtSZWYoKVxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ0RldGVybWluaXNtVmlvbGF0aW9uRXJyb3InKVxuZXhwb3J0IGNsYXNzIERldGVybWluaXNtVmlvbGF0aW9uRXJyb3IgZXh0ZW5kcyBXb3JrZmxvd0Vycm9yIHt9XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHByb3ZpZGVkIGBlcnJgIGlzIGNhdXNlZCBieSBjYW5jZWxsYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FuY2VsbGF0aW9uKGVycjogdW5rbm93bik6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGVyciBpbnN0YW5jZW9mIENhbmNlbGxlZEZhaWx1cmUgfHxcbiAgICAoKGVyciBpbnN0YW5jZW9mIEFjdGl2aXR5RmFpbHVyZSB8fCBlcnIgaW5zdGFuY2VvZiBDaGlsZFdvcmtmbG93RmFpbHVyZSkgJiYgZXJyLmNhdXNlIGluc3RhbmNlb2YgQ2FuY2VsbGVkRmFpbHVyZSlcbiAgKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBtYXliZUdldEFjdGl2YXRvclVudHlwZWQoKTogdW5rbm93biB7XG4gIHJldHVybiAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fVEVNUE9SQUxfQUNUSVZBVE9SX187XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRBY3RpdmF0b3JVbnR5cGVkKGFjdGl2YXRvcjogdW5rbm93bik6IHZvaWQge1xuICAoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fVEVNUE9SQUxfQUNUSVZBVE9SX18gPSBhY3RpdmF0b3I7XG59XG4iLCIvKipcbiAqIFRoaXMgbGlicmFyeSBwcm92aWRlcyB0b29scyByZXF1aXJlZCBmb3IgYXV0aG9yaW5nIHdvcmtmbG93cy5cbiAqXG4gKiAjIyBVc2FnZVxuICogU2VlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL3R5cGVzY3JpcHQvaGVsbG8td29ybGQjd29ya2Zsb3dzIHwgdHV0b3JpYWx9IGZvciB3cml0aW5nIHlvdXIgZmlyc3Qgd29ya2Zsb3cuXG4gKlxuICogIyMjIFRpbWVyc1xuICpcbiAqIFRoZSByZWNvbW1lbmRlZCB3YXkgb2Ygc2NoZWR1bGluZyB0aW1lcnMgaXMgYnkgdXNpbmcgdGhlIHtAbGluayBzbGVlcH0gZnVuY3Rpb24uIFdlJ3ZlIHJlcGxhY2VkIGBzZXRUaW1lb3V0YCBhbmRcbiAqIGBjbGVhclRpbWVvdXRgIHdpdGggZGV0ZXJtaW5pc3RpYyB2ZXJzaW9ucyBzbyB0aGVzZSBhcmUgYWxzbyB1c2FibGUgYnV0IGhhdmUgYSBsaW1pdGF0aW9uIHRoYXQgdGhleSBkb24ndCBwbGF5IHdlbGxcbiAqIHdpdGgge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby90eXBlc2NyaXB0L2NhbmNlbGxhdGlvbi1zY29wZXMgfCBjYW5jZWxsYXRpb24gc2NvcGVzfS5cbiAqXG4gKiA8IS0tU05JUFNUQVJUIHR5cGVzY3JpcHQtc2xlZXAtd29ya2Zsb3ctLT5cbiAqIDwhLS1TTklQRU5ELS0+XG4gKlxuICogIyMjIEFjdGl2aXRpZXNcbiAqXG4gKiBUbyBzY2hlZHVsZSBBY3Rpdml0aWVzLCB1c2Uge0BsaW5rIHByb3h5QWN0aXZpdGllc30gdG8gb2J0YWluIGFuIEFjdGl2aXR5IGZ1bmN0aW9uIGFuZCBjYWxsLlxuICpcbiAqIDwhLS1TTklQU1RBUlQgdHlwZXNjcmlwdC1zY2hlZHVsZS1hY3Rpdml0eS13b3JrZmxvdy0tPlxuICogPCEtLVNOSVBFTkQtLT5cbiAqXG4gKiAjIyMgU2lnbmFscyBhbmQgUXVlcmllc1xuICpcbiAqIFRvIGFkZCBzaWduYWwgaGFuZGxlcnMgdG8gYSBXb3JrZmxvdywgYWRkIGEgc2lnbmFscyBwcm9wZXJ0eSB0byB0aGUgZXhwb3J0ZWQgYHdvcmtmbG93YCBvYmplY3QuIFNpZ25hbCBoYW5kbGVycyBjYW5cbiAqIHJldHVybiBlaXRoZXIgYHZvaWRgIG9yIGBQcm9taXNlPHZvaWQ+YCwgeW91IG1heSBzY2hlZHVsZSBhY3Rpdml0aWVzIGFuZCB0aW1lcnMgZnJvbSBhIHNpZ25hbCBoYW5kbGVyLlxuICpcbiAqIFRvIGFkZCBxdWVyeSBoYW5kbGVycyB0byBhIFdvcmtmbG93LCBhZGQgYSBxdWVyaWVzIHByb3BlcnR5IHRvIHRoZSBleHBvcnRlZCBgd29ya2Zsb3dgIG9iamVjdC4gUXVlcnkgaGFuZGxlcnMgbXVzdFxuICogKipub3QqKiBtdXRhdGUgYW55IHZhcmlhYmxlcyBvciBnZW5lcmF0ZSBhbnkgY29tbWFuZHMgKGxpa2UgQWN0aXZpdGllcyBvciBUaW1lcnMpLCB0aGV5IHJ1biBzeW5jaHJvbm91c2x5IGFuZCB0aHVzXG4gKiAqKm11c3QqKiByZXR1cm4gYSBgUHJvbWlzZWAuXG4gKlxuICogIyMjIyBJbXBsZW1lbnRhdGlvblxuICpcbiAqIDwhLS1TTklQU1RBUlQgdHlwZXNjcmlwdC13b3JrZmxvdy1zaWduYWwtaW1wbGVtZW50YXRpb24tLT5cbiAqIDwhLS1TTklQRU5ELS0+XG4gKlxuICogIyMjIE1vcmVcbiAqXG4gKiAtIFtEZXRlcm1pbmlzdGljIGJ1aWx0LWluc10oaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL3R5cGVzY3JpcHQvZGV0ZXJtaW5pc20jc291cmNlcy1vZi1ub24tZGV0ZXJtaW5pc20pXG4gKiAtIFtDYW5jZWxsYXRpb24gYW5kIHNjb3Blc10oaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL3R5cGVzY3JpcHQvY2FuY2VsbGF0aW9uLXNjb3BlcylcbiAqICAgLSB7QGxpbmsgQ2FuY2VsbGF0aW9uU2NvcGV9XG4gKiAgIC0ge0BsaW5rIFRyaWdnZXJ9XG4gKiAtIFtTaW5rc10oaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL2FwcGxpY2F0aW9uLWRldmVsb3BtZW50L29ic2VydmFiaWxpdHkvP2xhbmc9dHMjbG9nZ2luZylcbiAqICAgLSB7QGxpbmsgU2lua3N9XG4gKlxuICogQG1vZHVsZVxuICovXG5cbmV4cG9ydCB7XG4gIEFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZSxcbiAgQWN0aXZpdHlGYWlsdXJlLFxuICBBY3Rpdml0eU9wdGlvbnMsXG4gIEFwcGxpY2F0aW9uRmFpbHVyZSxcbiAgQ2FuY2VsbGVkRmFpbHVyZSxcbiAgQ2hpbGRXb3JrZmxvd0ZhaWx1cmUsXG4gIGRlZmF1bHRQYXlsb2FkQ29udmVydGVyLFxuICBQYXlsb2FkQ29udmVydGVyLFxuICBSZXRyeVBvbGljeSxcbiAgcm9vdENhdXNlLFxuICBTZXJ2ZXJGYWlsdXJlLFxuICBUZW1wb3JhbEZhaWx1cmUsXG4gIFRlcm1pbmF0ZWRGYWlsdXJlLFxuICBUaW1lb3V0RmFpbHVyZSxcbn0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uJztcbmV4cG9ydCAqIGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvZXJyb3JzJztcbmV4cG9ydCB7XG4gIEFjdGl2aXR5RnVuY3Rpb24sXG4gIEFjdGl2aXR5SW50ZXJmYWNlLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIFBheWxvYWQsXG4gIFF1ZXJ5RGVmaW5pdGlvbixcbiAgU2VhcmNoQXR0cmlidXRlcyxcbiAgU2VhcmNoQXR0cmlidXRlVmFsdWUsXG4gIFNpZ25hbERlZmluaXRpb24sXG4gIFVudHlwZWRBY3Rpdml0aWVzLFxuICBXb3JrZmxvdyxcbiAgV29ya2Zsb3dRdWVyeVR5cGUsXG4gIFdvcmtmbG93UmVzdWx0VHlwZSxcbiAgV29ya2Zsb3dSZXR1cm5UeXBlLFxuICBXb3JrZmxvd1NpZ25hbFR5cGUsXG59IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvaW50ZXJmYWNlcyc7XG5leHBvcnQgKiBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL3dvcmtmbG93LWhhbmRsZSc7XG5leHBvcnQgKiBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL3dvcmtmbG93LW9wdGlvbnMnO1xuZXhwb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2UsIENhbmNlbGxhdGlvblNjb3BlLCBDYW5jZWxsYXRpb25TY29wZU9wdGlvbnMgfSBmcm9tICcuL2NhbmNlbGxhdGlvbi1zY29wZSc7XG5leHBvcnQgKiBmcm9tICcuL2Vycm9ycyc7XG5leHBvcnQgKiBmcm9tICcuL2ludGVyY2VwdG9ycyc7XG5leHBvcnQge1xuICBDaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZSxcbiAgQ2hpbGRXb3JrZmxvd09wdGlvbnMsXG4gIENvbnRpbnVlQXNOZXcsXG4gIENvbnRpbnVlQXNOZXdPcHRpb25zLFxuICBFbmhhbmNlZFN0YWNrVHJhY2UsXG4gIEZpbGVMb2NhdGlvbixcbiAgRmlsZVNsaWNlLFxuICBQYXJlbnRDbG9zZVBvbGljeSxcbiAgUGFyZW50V29ya2Zsb3dJbmZvLFxuICBTREtJbmZvLFxuICBTdGFja1RyYWNlLFxuICBVbnNhZmVXb3JrZmxvd0luZm8sXG4gIFdvcmtmbG93SW5mbyxcbn0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmV4cG9ydCB7IExvZ2dlclNpbmtzLCBTaW5rLCBTaW5rQ2FsbCwgU2lua0Z1bmN0aW9uLCBTaW5rcyB9IGZyb20gJy4vc2lua3MnO1xuZXhwb3J0IHsgVHJpZ2dlciB9IGZyb20gJy4vdHJpZ2dlcic7XG5leHBvcnQgKiBmcm9tICcuL3dvcmtmbG93JztcbmV4cG9ydCB7IENoaWxkV29ya2Zsb3dIYW5kbGUsIEV4dGVybmFsV29ya2Zsb3dIYW5kbGUgfSBmcm9tICcuL3dvcmtmbG93LWhhbmRsZSc7XG4iLCIvKipcbiAqIFR5cGUgZGVmaW5pdGlvbnMgYW5kIGdlbmVyaWMgaGVscGVycyBmb3IgaW50ZXJjZXB0b3JzLlxuICpcbiAqIFRoZSBXb3JrZmxvdyBzcGVjaWZpYyBpbnRlcmNlcHRvcnMgYXJlIGRlZmluZWQgaGVyZS5cbiAqXG4gKiBAbW9kdWxlXG4gKi9cblxuaW1wb3J0IHsgQWN0aXZpdHlPcHRpb25zLCBIZWFkZXJzLCBMb2NhbEFjdGl2aXR5T3B0aW9ucywgTmV4dCwgVGltZXN0YW1wLCBXb3JrZmxvd0V4ZWN1dGlvbiB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbic7XG5pbXBvcnQgdHlwZSB7IGNvcmVzZGsgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQgeyBDaGlsZFdvcmtmbG93T3B0aW9uc1dpdGhEZWZhdWx0cywgQ29udGludWVBc05ld09wdGlvbnMgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuXG5leHBvcnQgeyBOZXh0LCBIZWFkZXJzIH07XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dJbmJvdW5kQ2FsbHNJbnRlcmNlcHRvci5leGVjdXRlICovXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93RXhlY3V0ZUlucHV0IHtcbiAgcmVhZG9ubHkgYXJnczogdW5rbm93bltdO1xuICByZWFkb25seSBoZWFkZXJzOiBIZWFkZXJzO1xufVxuXG4vKiogSW5wdXQgZm9yIFdvcmtmbG93SW5ib3VuZENhbGxzSW50ZXJjZXB0b3IuaGFuZGxlU2lnbmFsICovXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25hbElucHV0IHtcbiAgcmVhZG9ubHkgc2lnbmFsTmFtZTogc3RyaW5nO1xuICByZWFkb25seSBhcmdzOiB1bmtub3duW107XG4gIHJlYWRvbmx5IGhlYWRlcnM6IEhlYWRlcnM7XG59XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dJbmJvdW5kQ2FsbHNJbnRlcmNlcHRvci5oYW5kbGVRdWVyeSAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeUlucHV0IHtcbiAgcmVhZG9ubHkgcXVlcnlJZDogc3RyaW5nO1xuICByZWFkb25seSBxdWVyeU5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgYXJnczogdW5rbm93bltdO1xuICByZWFkb25seSBoZWFkZXJzOiBIZWFkZXJzO1xufVxuXG4vKipcbiAqIEltcGxlbWVudCBhbnkgb2YgdGhlc2UgbWV0aG9kcyB0byBpbnRlcmNlcHQgV29ya2Zsb3cgaW5ib3VuZCBjYWxscyBsaWtlIGV4ZWN1dGlvbiwgYW5kIHNpZ25hbCBhbmQgcXVlcnkgaGFuZGxpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV29ya2Zsb3dJbmJvdW5kQ2FsbHNJbnRlcmNlcHRvciB7XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBXb3JrZmxvdyBleGVjdXRlIG1ldGhvZCBpcyBjYWxsZWRcbiAgICpcbiAgICogQHJldHVybiByZXN1bHQgb2YgdGhlIFdvcmtmbG93IGV4ZWN1dGlvblxuICAgKi9cbiAgZXhlY3V0ZT86IChpbnB1dDogV29ya2Zsb3dFeGVjdXRlSW5wdXQsIG5leHQ6IE5leHQ8dGhpcywgJ2V4ZWN1dGUnPikgPT4gUHJvbWlzZTx1bmtub3duPjtcblxuICAvKiogQ2FsbGVkIHdoZW4gc2lnbmFsIGlzIGRlbGl2ZXJlZCB0byBhIFdvcmtmbG93IGV4ZWN1dGlvbiAqL1xuICBoYW5kbGVTaWduYWw/OiAoaW5wdXQ6IFNpZ25hbElucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdoYW5kbGVTaWduYWwnPikgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBXb3JrZmxvdyBpcyBxdWVyaWVkXG4gICAqXG4gICAqIEByZXR1cm4gcmVzdWx0IG9mIHRoZSBxdWVyeVxuICAgKi9cbiAgaGFuZGxlUXVlcnk/OiAoaW5wdXQ6IFF1ZXJ5SW5wdXQsIG5leHQ6IE5leHQ8dGhpcywgJ2hhbmRsZVF1ZXJ5Jz4pID0+IFByb21pc2U8dW5rbm93bj47XG59XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3Iuc2NoZWR1bGVBY3Rpdml0eSAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpdml0eUlucHV0IHtcbiAgcmVhZG9ubHkgYWN0aXZpdHlUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFyZ3M6IHVua25vd25bXTtcbiAgcmVhZG9ubHkgb3B0aW9uczogQWN0aXZpdHlPcHRpb25zO1xuICByZWFkb25seSBoZWFkZXJzOiBIZWFkZXJzO1xuICByZWFkb25seSBzZXE6IG51bWJlcjtcbn1cblxuLyoqIElucHV0IGZvciBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvci5zY2hlZHVsZUxvY2FsQWN0aXZpdHkgKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxBY3Rpdml0eUlucHV0IHtcbiAgcmVhZG9ubHkgYWN0aXZpdHlUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFyZ3M6IHVua25vd25bXTtcbiAgcmVhZG9ubHkgb3B0aW9uczogTG9jYWxBY3Rpdml0eU9wdGlvbnM7XG4gIHJlYWRvbmx5IGhlYWRlcnM6IEhlYWRlcnM7XG4gIHJlYWRvbmx5IHNlcTogbnVtYmVyO1xuICByZWFkb25seSBvcmlnaW5hbFNjaGVkdWxlVGltZT86IFRpbWVzdGFtcDtcbiAgcmVhZG9ubHkgYXR0ZW1wdDogbnVtYmVyO1xufVxuXG4vKiogSW5wdXQgZm9yIFdvcmtmbG93T3V0Ym91bmRDYWxsc0ludGVyY2VwdG9yLnN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25JbnB1dCB7XG4gIHJlYWRvbmx5IHdvcmtmbG93VHlwZTogc3RyaW5nO1xuICByZWFkb25seSBvcHRpb25zOiBDaGlsZFdvcmtmbG93T3B0aW9uc1dpdGhEZWZhdWx0cztcbiAgcmVhZG9ubHkgaGVhZGVyczogSGVhZGVycztcbiAgcmVhZG9ubHkgc2VxOiBudW1iZXI7XG59XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3Iuc3RhcnRUaW1lciAqL1xuZXhwb3J0IGludGVyZmFjZSBUaW1lcklucHV0IHtcbiAgcmVhZG9ubHkgZHVyYXRpb25NczogbnVtYmVyO1xuICByZWFkb25seSBzZXE6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBTYW1lIGFzIENvbnRpbnVlQXNOZXdPcHRpb25zIGJ1dCB3b3JrZmxvd1R5cGUgbXVzdCBiZSBkZWZpbmVkXG4gKi9cbmV4cG9ydCB0eXBlIENvbnRpbnVlQXNOZXdJbnB1dE9wdGlvbnMgPSBDb250aW51ZUFzTmV3T3B0aW9ucyAmIFJlcXVpcmVkPFBpY2s8Q29udGludWVBc05ld09wdGlvbnMsICd3b3JrZmxvd1R5cGUnPj47XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3IuY29udGludWVBc05ldyAqL1xuZXhwb3J0IGludGVyZmFjZSBDb250aW51ZUFzTmV3SW5wdXQge1xuICByZWFkb25seSBhcmdzOiB1bmtub3duW107XG4gIHJlYWRvbmx5IGhlYWRlcnM6IEhlYWRlcnM7XG4gIHJlYWRvbmx5IG9wdGlvbnM6IENvbnRpbnVlQXNOZXdJbnB1dE9wdGlvbnM7XG59XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3Iuc2lnbmFsV29ya2Zsb3cgKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbmFsV29ya2Zsb3dJbnB1dCB7XG4gIHJlYWRvbmx5IHNlcTogbnVtYmVyO1xuICByZWFkb25seSBzaWduYWxOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFyZ3M6IHVua25vd25bXTtcbiAgcmVhZG9ubHkgaGVhZGVyczogSGVhZGVycztcbiAgcmVhZG9ubHkgdGFyZ2V0OlxuICAgIHwge1xuICAgICAgICByZWFkb25seSB0eXBlOiAnZXh0ZXJuYWwnO1xuICAgICAgICByZWFkb25seSB3b3JrZmxvd0V4ZWN1dGlvbjogV29ya2Zsb3dFeGVjdXRpb247XG4gICAgICB9XG4gICAgfCB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6ICdjaGlsZCc7XG4gICAgICAgIHJlYWRvbmx5IGNoaWxkV29ya2Zsb3dJZDogc3RyaW5nO1xuICAgICAgfTtcbn1cblxuLyoqIElucHV0IGZvciBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvci5nZXRMb2dBdHRyaWJ1dGVzICovXG5leHBvcnQgdHlwZSBHZXRMb2dBdHRyaWJ1dGVzSW5wdXQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuLyoqXG4gKiBJbXBsZW1lbnQgYW55IG9mIHRoZXNlIG1ldGhvZHMgdG8gaW50ZXJjZXB0IFdvcmtmbG93IGNvZGUgY2FsbHMgdG8gdGhlIFRlbXBvcmFsIEFQSXMsIGxpa2Ugc2NoZWR1bGluZyBhbiBhY3Rpdml0eSBhbmQgc3RhcnRpbmcgYSB0aW1lclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93T3V0Ym91bmRDYWxsc0ludGVyY2VwdG9yIHtcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIFdvcmtmbG93IHNjaGVkdWxlcyBhbiBBY3Rpdml0eVxuICAgKlxuICAgKiBAcmV0dXJuIHJlc3VsdCBvZiB0aGUgYWN0aXZpdHkgZXhlY3V0aW9uXG4gICAqL1xuICBzY2hlZHVsZUFjdGl2aXR5PzogKGlucHV0OiBBY3Rpdml0eUlucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdzY2hlZHVsZUFjdGl2aXR5Jz4pID0+IFByb21pc2U8dW5rbm93bj47XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIFdvcmtmbG93IHNjaGVkdWxlcyBhIGxvY2FsIEFjdGl2aXR5XG4gICAqXG4gICAqIEByZXR1cm4gcmVzdWx0IG9mIHRoZSBhY3Rpdml0eSBleGVjdXRpb25cbiAgICovXG4gIHNjaGVkdWxlTG9jYWxBY3Rpdml0eT86IChpbnB1dDogTG9jYWxBY3Rpdml0eUlucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdzY2hlZHVsZUxvY2FsQWN0aXZpdHknPikgPT4gUHJvbWlzZTx1bmtub3duPjtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gV29ya2Zsb3cgc3RhcnRzIGEgdGltZXJcbiAgICovXG4gIHN0YXJ0VGltZXI/OiAoaW5wdXQ6IFRpbWVySW5wdXQsIG5leHQ6IE5leHQ8dGhpcywgJ3N0YXJ0VGltZXInPikgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gV29ya2Zsb3cgY2FsbHMgY29udGludWVBc05ld1xuICAgKi9cbiAgY29udGludWVBc05ldz86IChpbnB1dDogQ29udGludWVBc05ld0lucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdjb250aW51ZUFzTmV3Jz4pID0+IFByb21pc2U8bmV2ZXI+O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBXb3JrZmxvdyBzaWduYWxzIGEgY2hpbGQgb3IgZXh0ZXJuYWwgV29ya2Zsb3dcbiAgICovXG4gIHNpZ25hbFdvcmtmbG93PzogKGlucHV0OiBTaWduYWxXb3JrZmxvd0lucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdzaWduYWxXb3JrZmxvdyc+KSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBXb3JrZmxvdyBzdGFydHMgYSBjaGlsZCB3b3JrZmxvdyBleGVjdXRpb24sIHRoZSBpbnRlcmNlcHRvciBmdW5jdGlvbiByZXR1cm5zIDIgcHJvbWlzZXM6XG4gICAqXG4gICAqIC0gVGhlIGZpcnN0IHJlc29sdmVzIHdpdGggdGhlIGBydW5JZGAgd2hlbiB0aGUgY2hpbGQgd29ya2Zsb3cgaGFzIHN0YXJ0ZWQgb3IgcmVqZWN0cyBpZiBmYWlsZWQgdG8gc3RhcnQuXG4gICAqIC0gVGhlIHNlY29uZCByZXNvbHZlcyB3aXRoIHRoZSB3b3JrZmxvdyByZXN1bHQgd2hlbiB0aGUgY2hpbGQgd29ya2Zsb3cgY29tcGxldGVzIG9yIHJlamVjdHMgb24gZmFpbHVyZS5cbiAgICovXG4gIHN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbj86IChcbiAgICBpbnB1dDogU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uSW5wdXQsXG4gICAgbmV4dDogTmV4dDx0aGlzLCAnc3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uJz5cbiAgKSA9PiBQcm9taXNlPFtQcm9taXNlPHN0cmluZz4sIFByb21pc2U8dW5rbm93bj5dPjtcblxuICAvKipcbiAgICogQ2FsbGVkIG9uIGVhY2ggaW52b2NhdGlvbiBvZiB0aGUgYHdvcmtmbG93LmxvZ2AgbWV0aG9kcy5cbiAgICpcbiAgICogVGhlIGF0dHJpYnV0ZXMgcmV0dXJuZWQgaW4gdGhpcyBjYWxsIGFyZSBhdHRhY2hlZCB0byBldmVyeSBsb2cgbWVzc2FnZS5cbiAgICovXG4gIGdldExvZ0F0dHJpYnV0ZXM/OiAoaW5wdXQ6IEdldExvZ0F0dHJpYnV0ZXNJbnB1dCwgbmV4dDogTmV4dDx0aGlzLCAnZ2V0TG9nQXR0cmlidXRlcyc+KSA9PiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbn1cblxuLyoqIElucHV0IGZvciBXb3JrZmxvd0ludGVybmFsc0ludGVyY2VwdG9yLmNvbmNsdWRlQWN0aXZhdGlvbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25jbHVkZUFjdGl2YXRpb25JbnB1dCB7XG4gIGNvbW1hbmRzOiBjb3Jlc2RrLndvcmtmbG93X2NvbW1hbmRzLklXb3JrZmxvd0NvbW1hbmRbXTtcbn1cblxuLyoqIE91dHB1dCBmb3IgV29ya2Zsb3dJbnRlcm5hbHNJbnRlcmNlcHRvci5jb25jbHVkZUFjdGl2YXRpb24gKi9cbmV4cG9ydCB0eXBlIENvbmNsdWRlQWN0aXZhdGlvbk91dHB1dCA9IENvbmNsdWRlQWN0aXZhdGlvbklucHV0O1xuXG4vKiogSW5wdXQgZm9yIFdvcmtmbG93SW50ZXJuYWxzSW50ZXJjZXB0b3IuYWN0aXZhdGUgKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aXZhdGVJbnB1dCB7XG4gIGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JV29ya2Zsb3dBY3RpdmF0aW9uO1xuICBiYXRjaEluZGV4OiBudW1iZXI7XG59XG5cbi8qKiBJbnB1dCBmb3IgV29ya2Zsb3dJbnRlcm5hbHNJbnRlcmNlcHRvci5kaXNwb3NlICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBEaXNwb3NlSW5wdXQge31cblxuLyoqXG4gKiBJbnRlcmNlcHRvciBmb3IgdGhlIGludGVybmFscyBvZiB0aGUgV29ya2Zsb3cgcnVudGltZS5cbiAqXG4gKiBVc2UgdG8gbWFuaXB1bGF0ZSBvciB0cmFjZSBXb3JrZmxvdyBhY3RpdmF0aW9ucy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgQVBJIGlzIGZvciBhZHZhbmNlZCB1c2UgY2FzZXMgYW5kIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXb3JrZmxvd0ludGVybmFsc0ludGVyY2VwdG9yIHtcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBXb3JrZmxvdyBydW50aW1lIHJ1bnMgYSBXb3JrZmxvd0FjdGl2YXRpb25Kb2IuXG4gICAqL1xuICBhY3RpdmF0ZT8oaW5wdXQ6IEFjdGl2YXRlSW5wdXQsIG5leHQ6IE5leHQ8dGhpcywgJ2FjdGl2YXRlJz4pOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgYWZ0ZXIgYWxsIGBXb3JrZmxvd0FjdGl2YXRpb25Kb2JgcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIGZvciBhbiBhY3RpdmF0aW9uLlxuICAgKlxuICAgKiBDYW4gbWFuaXB1bGF0ZSB0aGUgY29tbWFuZHMgZ2VuZXJhdGVkIGJ5IHRoZSBXb3JrZmxvd1xuICAgKi9cbiAgY29uY2x1ZGVBY3RpdmF0aW9uPyhpbnB1dDogQ29uY2x1ZGVBY3RpdmF0aW9uSW5wdXQsIG5leHQ6IE5leHQ8dGhpcywgJ2NvbmNsdWRlQWN0aXZhdGlvbic+KTogQ29uY2x1ZGVBY3RpdmF0aW9uT3V0cHV0O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgYmVmb3JlIGRpc3Bvc2luZyB0aGUgV29ya2Zsb3cgaXNvbGF0ZSBjb250ZXh0LlxuICAgKlxuICAgKiBJbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBhbnkgcmVzb3VyY2UgY2xlYW51cC5cbiAgICovXG4gIGRpc3Bvc2U/KGlucHV0OiBEaXNwb3NlSW5wdXQsIG5leHQ6IE5leHQ8dGhpcywgJ2Rpc3Bvc2UnPik6IHZvaWQ7XG59XG5cbi8qKlxuICogQSBtYXBwaW5nIGZyb20gaW50ZXJjZXB0b3IgdHlwZSB0byBhbiBvcHRpb25hbCBsaXN0IG9mIGludGVyY2VwdG9yIGltcGxlbWVudGF0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93SW50ZXJjZXB0b3JzIHtcbiAgaW5ib3VuZD86IFdvcmtmbG93SW5ib3VuZENhbGxzSW50ZXJjZXB0b3JbXTtcbiAgb3V0Ym91bmQ/OiBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvcltdO1xuICBpbnRlcm5hbHM/OiBXb3JrZmxvd0ludGVybmFsc0ludGVyY2VwdG9yW107XG59XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMge0BsaW5rIFdvcmtmbG93SW50ZXJjZXB0b3JzfSBhbmQgdGFrZXMgbm8gYXJndW1lbnRzLlxuICpcbiAqIFdvcmtmbG93IGludGVyY2VwdG9yIG1vZHVsZXMgc2hvdWxkIGV4cG9ydCBhbiBgaW50ZXJjZXB0b3JzYCBmdW5jdGlvbiBvZiB0aGlzIHR5cGUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogZXhwb3J0IGZ1bmN0aW9uIGludGVyY2VwdG9ycygpOiBXb3JrZmxvd0ludGVyY2VwdG9ycyB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgaW5ib3VuZDogW10sICAgLy8gUG9wdWxhdGUgd2l0aCBsaXN0IG9mIGludGVyY2VwdG9yIGltcGxlbWVudGF0aW9uc1xuICogICAgIG91dGJvdW5kOiBbXSwgIC8vIFBvcHVsYXRlIHdpdGggbGlzdCBvZiBpbnRlcmNlcHRvciBpbXBsZW1lbnRhdGlvbnNcbiAqICAgICBpbnRlcm5hbHM6IFtdLCAvLyBQb3B1bGF0ZSB3aXRoIGxpc3Qgb2YgaW50ZXJjZXB0b3IgaW1wbGVtZW50YXRpb25zXG4gKiAgIH07XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dJbnRlcmNlcHRvcnNGYWN0b3J5ID0gKCkgPT4gV29ya2Zsb3dJbnRlcmNlcHRvcnM7XG4iLCJpbXBvcnQgdHlwZSB7IFJhd1NvdXJjZU1hcCB9IGZyb20gJ3NvdXJjZS1tYXAnO1xuaW1wb3J0IHtcbiAgUmV0cnlQb2xpY3ksXG4gIFRlbXBvcmFsRmFpbHVyZSxcbiAgQ29tbW9uV29ya2Zsb3dPcHRpb25zLFxuICBTZWFyY2hBdHRyaWJ1dGVzLFxuICBTaWduYWxEZWZpbml0aW9uLFxuICBRdWVyeURlZmluaXRpb24sXG4gIER1cmF0aW9uLFxuICBWZXJzaW9uaW5nSW50ZW50LFxufSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuaW1wb3J0IHsgY2hlY2tFeHRlbmRzLCBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvciB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvdHlwZS1oZWxwZXJzJztcbmltcG9ydCB0eXBlIHsgY29yZXNkayB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcblxuLyoqXG4gKiBXb3JrZmxvdyBFeGVjdXRpb24gaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXb3JrZmxvd0luZm8ge1xuICAvKipcbiAgICogSUQgb2YgdGhlIFdvcmtmbG93LCB0aGlzIGNhbiBiZSBzZXQgYnkgdGhlIGNsaWVudCBkdXJpbmcgV29ya2Zsb3cgY3JlYXRpb24uXG4gICAqIEEgc2luZ2xlIFdvcmtmbG93IG1heSBydW4gbXVsdGlwbGUgdGltZXMgZS5nLiB3aGVuIHNjaGVkdWxlZCB3aXRoIGNyb24uXG4gICAqL1xuICB3b3JrZmxvd0lkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElEIG9mIGEgc2luZ2xlIFdvcmtmbG93IHJ1blxuICAgKi9cbiAgcnVuSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogV29ya2Zsb3cgZnVuY3Rpb24ncyBuYW1lXG4gICAqL1xuICB3b3JrZmxvd1R5cGU6IHN0cmluZztcblxuICAvKipcbiAgICogSW5kZXhlZCBpbmZvcm1hdGlvbiBhdHRhY2hlZCB0byB0aGUgV29ya2Zsb3cgRXhlY3V0aW9uXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgbWF5IGNoYW5nZSBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIGFuIEV4ZWN1dGlvbi5cbiAgICovXG4gIHNlYXJjaEF0dHJpYnV0ZXM6IFNlYXJjaEF0dHJpYnV0ZXM7XG5cbiAgLyoqXG4gICAqIE5vbi1pbmRleGVkIGluZm9ybWF0aW9uIGF0dGFjaGVkIHRvIHRoZSBXb3JrZmxvdyBFeGVjdXRpb25cbiAgICovXG4gIG1lbW8/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuICAvKipcbiAgICogUGFyZW50IFdvcmtmbG93IGluZm8gKHByZXNlbnQgaWYgdGhpcyBpcyBhIENoaWxkIFdvcmtmbG93KVxuICAgKi9cbiAgcGFyZW50PzogUGFyZW50V29ya2Zsb3dJbmZvO1xuXG4gIC8qKlxuICAgKiBSZXN1bHQgZnJvbSB0aGUgcHJldmlvdXMgUnVuIChwcmVzZW50IGlmIHRoaXMgaXMgYSBDcm9uIFdvcmtmbG93IG9yIHdhcyBDb250aW51ZWQgQXMgTmV3KS5cbiAgICpcbiAgICogQW4gYXJyYXkgb2YgdmFsdWVzLCBzaW5jZSBvdGhlciBTREtzIG1heSByZXR1cm4gbXVsdGlwbGUgdmFsdWVzIGZyb20gYSBXb3JrZmxvdy5cbiAgICovXG4gIGxhc3RSZXN1bHQ/OiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBGYWlsdXJlIGZyb20gdGhlIHByZXZpb3VzIFJ1biAocHJlc2VudCB3aGVuIHRoaXMgUnVuIGlzIGEgcmV0cnksIG9yIHRoZSBsYXN0IFJ1biBvZiBhIENyb24gV29ya2Zsb3cgZmFpbGVkKVxuICAgKi9cbiAgbGFzdEZhaWx1cmU/OiBUZW1wb3JhbEZhaWx1cmU7XG5cbiAgLyoqXG4gICAqIExlbmd0aCBvZiBXb3JrZmxvdyBoaXN0b3J5IHVwIHVudGlsIHRoZSBjdXJyZW50IFdvcmtmbG93IFRhc2suXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgY2hhbmdlcyBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIGFuIEV4ZWN1dGlvbi5cbiAgICpcbiAgICogWW91IG1heSBzYWZlbHkgdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGVjaWRlIHdoZW4gdG8ge0BsaW5rIGNvbnRpbnVlQXNOZXd9LlxuICAgKi9cbiAgaGlzdG9yeUxlbmd0aDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTaXplIG9mIFdvcmtmbG93IGhpc3RvcnkgaW4gYnl0ZXMgdW50aWwgdGhlIGN1cnJlbnQgV29ya2Zsb3cgVGFzay5cbiAgICpcbiAgICogVGhpcyB2YWx1ZSBjaGFuZ2VzIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgYW4gRXhlY3V0aW9uLlxuICAgKlxuICAgKiBTdXBwb3J0ZWQgb25seSBvbiBUZW1wb3JhbCBTZXJ2ZXIgMS4yMCssIGFsd2F5cyB6ZXJvIG9uIG9sZGVyIHNlcnZlcnMuXG4gICAqXG4gICAqIFlvdSBtYXkgc2FmZWx5IHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGRlY2lkZSB3aGVuIHRvIHtAbGluayBjb250aW51ZUFzTmV3fS5cbiAgICovXG4gIGhpc3RvcnlTaXplOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEEgaGludCBwcm92aWRlZCBieSB0aGUgY3VycmVudCBXb3JrZmxvd1Rhc2tTdGFydGVkIGV2ZW50IHJlY29tbWVuZGluZyB3aGV0aGVyIHRvXG4gICAqIHtAbGluayBjb250aW51ZUFzTmV3fS5cbiAgICpcbiAgICogVGhpcyB2YWx1ZSBjaGFuZ2VzIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgYW4gRXhlY3V0aW9uLlxuICAgKlxuICAgKiBTdXBwb3J0ZWQgb25seSBvbiBUZW1wb3JhbCBTZXJ2ZXIgMS4yMCssIGFsd2F5cyBgZmFsc2VgIG9uIG9sZGVyIHNlcnZlcnMuXG4gICAqL1xuICBjb250aW51ZUFzTmV3U3VnZ2VzdGVkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUYXNrIHF1ZXVlIHRoaXMgV29ya2Zsb3cgaXMgZXhlY3V0aW5nIG9uXG4gICAqL1xuICB0YXNrUXVldWU6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZXNwYWNlIHRoaXMgV29ya2Zsb3cgaXMgZXhlY3V0aW5nIGluXG4gICAqL1xuICBuYW1lc3BhY2U6IHN0cmluZztcblxuICAvKipcbiAgICogUnVuIElkIG9mIHRoZSBmaXJzdCBSdW4gaW4gdGhpcyBFeGVjdXRpb24gQ2hhaW5cbiAgICovXG4gIGZpcnN0RXhlY3V0aW9uUnVuSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxhc3QgUnVuIElkIGluIHRoaXMgRXhlY3V0aW9uIENoYWluXG4gICAqL1xuICBjb250aW51ZWRGcm9tRXhlY3V0aW9uUnVuSWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRpbWUgYXQgd2hpY2ggdGhpcyBbV29ya2Zsb3cgRXhlY3V0aW9uIENoYWluXShodHRwczovL2RvY3MudGVtcG9yYWwuaW8vd29ya2Zsb3dzI3dvcmtmbG93LWV4ZWN1dGlvbi1jaGFpbikgd2FzIHN0YXJ0ZWRcbiAgICovXG4gIHN0YXJ0VGltZTogRGF0ZTtcblxuICAvKipcbiAgICogVGltZSBhdCB3aGljaCB0aGUgY3VycmVudCBXb3JrZmxvdyBSdW4gc3RhcnRlZFxuICAgKi9cbiAgcnVuU3RhcnRUaW1lOiBEYXRlO1xuXG4gIC8qKlxuICAgKiBNaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIFdvcmtmbG93IEV4ZWN1dGlvbiBpcyBhdXRvbWF0aWNhbGx5IHRlcm1pbmF0ZWQgYnkgVGVtcG9yYWwgU2VydmVyLiBTZXQgdmlhIHtAbGluayBXb3JrZmxvd09wdGlvbnMud29ya2Zsb3dFeGVjdXRpb25UaW1lb3V0fS5cbiAgICovXG4gIGV4ZWN1dGlvblRpbWVvdXRNcz86IG51bWJlcjtcblxuICAvKipcbiAgICogVGltZSBhdCB3aGljaCB0aGUgV29ya2Zsb3cgRXhlY3V0aW9uIGV4cGlyZXNcbiAgICovXG4gIGV4ZWN1dGlvbkV4cGlyYXRpb25UaW1lPzogRGF0ZTtcblxuICAvKipcbiAgICogTWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBXb3JrZmxvdyBSdW4gaXMgYXV0b21hdGljYWxseSB0ZXJtaW5hdGVkIGJ5IFRlbXBvcmFsIFNlcnZlci4gU2V0IHZpYSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93UnVuVGltZW91dH0uXG4gICAqL1xuICBydW5UaW1lb3V0TXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE1heGltdW0gZXhlY3V0aW9uIHRpbWUgb2YgYSBXb3JrZmxvdyBUYXNrIGluIG1pbGxpc2Vjb25kcy4gU2V0IHZpYSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93VGFza1RpbWVvdXR9LlxuICAgKi9cbiAgdGFza1RpbWVvdXRNczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBSZXRyeSBQb2xpY3kgZm9yIHRoaXMgRXhlY3V0aW9uLiBTZXQgdmlhIHtAbGluayBXb3JrZmxvd09wdGlvbnMucmV0cnl9LlxuICAgKi9cbiAgcmV0cnlQb2xpY3k/OiBSZXRyeVBvbGljeTtcblxuICAvKipcbiAgICogU3RhcnRzIGF0IDEgYW5kIGluY3JlbWVudHMgZm9yIGV2ZXJ5IHJldHJ5IGlmIHRoZXJlIGlzIGEgYHJldHJ5UG9saWN5YFxuICAgKi9cbiAgYXR0ZW1wdDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDcm9uIFNjaGVkdWxlIGZvciB0aGlzIEV4ZWN1dGlvbi4gU2V0IHZpYSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLmNyb25TY2hlZHVsZX0uXG4gICAqL1xuICBjcm9uU2NoZWR1bGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1pbGxpc2Vjb25kcyBiZXR3ZWVuIENyb24gUnVuc1xuICAgKi9cbiAgY3JvblNjaGVkdWxlVG9TY2hlZHVsZUludGVydmFsPzogbnVtYmVyO1xuXG4gIHVuc2FmZTogVW5zYWZlV29ya2Zsb3dJbmZvO1xufVxuXG4vKipcbiAqIFVuc2FmZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBXb3JrZmxvdyBFeGVjdXRpb24uXG4gKlxuICogTmV2ZXIgcmVseSBvbiB0aGlzIGluZm9ybWF0aW9uIGluIFdvcmtmbG93IGxvZ2ljIGFzIGl0IHdpbGwgY2F1c2Ugbm9uLWRldGVybWluaXN0aWMgYmVoYXZpb3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVW5zYWZlV29ya2Zsb3dJbmZvIHtcbiAgLyoqXG4gICAqIEN1cnJlbnQgc3lzdGVtIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqXG4gICAqIFRoZSBzYWZlIHZlcnNpb24gb2YgdGltZSBpcyBgbmV3IERhdGUoKWAgYW5kIGBEYXRlLm5vdygpYCwgd2hpY2ggYXJlIHNldCBvbiB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiBhIFdvcmtmbG93XG4gICAqIFRhc2sgYW5kIHN0YXkgY29uc3RhbnQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgVGFzayBhbmQgZHVyaW5nIHJlcGxheS5cbiAgICovXG4gIG5vdygpOiBudW1iZXI7XG5cbiAgaXNSZXBsYXlpbmc6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyZW50V29ya2Zsb3dJbmZvIHtcbiAgd29ya2Zsb3dJZDogc3RyaW5nO1xuICBydW5JZDogc3RyaW5nO1xuICBuYW1lc3BhY2U6IHN0cmluZztcbn1cblxuLyoqXG4gKiBOb3QgYW4gYWN0dWFsIGVycm9yLCB1c2VkIGJ5IHRoZSBXb3JrZmxvdyBydW50aW1lIHRvIGFib3J0IGV4ZWN1dGlvbiB3aGVuIHtAbGluayBjb250aW51ZUFzTmV3fSBpcyBjYWxsZWRcbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdDb250aW51ZUFzTmV3JylcbmV4cG9ydCBjbGFzcyBDb250aW51ZUFzTmV3IGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgY29tbWFuZDogY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5JQ29udGludWVBc05ld1dvcmtmbG93RXhlY3V0aW9uKSB7XG4gICAgc3VwZXIoJ1dvcmtmbG93IGNvbnRpbnVlZCBhcyBuZXcnKTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGNvbnRpbnVpbmcgYSBXb3JrZmxvdyBhcyBuZXdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb250aW51ZUFzTmV3T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIFdvcmtmbG93IHR5cGUgbmFtZSwgZS5nLiB0aGUgZmlsZW5hbWUgaW4gdGhlIE5vZGUuanMgU0RLIG9yIGNsYXNzIG5hbWUgaW4gSmF2YVxuICAgKi9cbiAgd29ya2Zsb3dUeXBlPzogc3RyaW5nO1xuICAvKipcbiAgICogVGFzayBxdWV1ZSB0byBjb250aW51ZSB0aGUgV29ya2Zsb3cgaW5cbiAgICovXG4gIHRhc2tRdWV1ZT86IHN0cmluZztcbiAgLyoqXG4gICAqIFRpbWVvdXQgZm9yIHRoZSBlbnRpcmUgV29ya2Zsb3cgcnVuXG4gICAqIEBmb3JtYXQge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHdvcmtmbG93UnVuVGltZW91dD86IER1cmF0aW9uO1xuICAvKipcbiAgICogVGltZW91dCBmb3IgYSBzaW5nbGUgV29ya2Zsb3cgdGFza1xuICAgKiBAZm9ybWF0IHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqL1xuICB3b3JrZmxvd1Rhc2tUaW1lb3V0PzogRHVyYXRpb247XG4gIC8qKlxuICAgKiBOb24tc2VhcmNoYWJsZSBhdHRyaWJ1dGVzIHRvIGF0dGFjaCB0byBuZXh0IFdvcmtmbG93IHJ1blxuICAgKi9cbiAgbWVtbz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAvKipcbiAgICogU2VhcmNoYWJsZSBhdHRyaWJ1dGVzIHRvIGF0dGFjaCB0byBuZXh0IFdvcmtmbG93IHJ1blxuICAgKi9cbiAgc2VhcmNoQXR0cmlidXRlcz86IFNlYXJjaEF0dHJpYnV0ZXM7XG4gIC8qKlxuICAgKiBXaGVuIHVzaW5nIHRoZSBXb3JrZXIgVmVyc2lvbmluZyBmZWF0dXJlLCBzcGVjaWZpZXMgd2hldGhlciB0aGlzIFdvcmtmbG93IHNob3VsZFxuICAgKiBDb250aW51ZS1hcy1OZXcgb250byBhIHdvcmtlciB3aXRoIGEgY29tcGF0aWJsZSBCdWlsZCBJZCBvciBub3QuIFNlZSB7QGxpbmsgVmVyc2lvbmluZ0ludGVudH0uXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHZlcnNpb25pbmdJbnRlbnQ/OiBWZXJzaW9uaW5nSW50ZW50O1xufVxuXG4vKipcbiAqIFNwZWNpZmllczpcbiAqIC0gd2hldGhlciBjYW5jZWxsYXRpb24gcmVxdWVzdHMgYXJlIHNlbnQgdG8gdGhlIENoaWxkXG4gKiAtIHdoZXRoZXIgYW5kIHdoZW4gYSB7QGxpbmsgQ2FuY2VsZWRGYWlsdXJlfSBpcyB0aHJvd24gZnJvbSB7QGxpbmsgZXhlY3V0ZUNoaWxkfSBvclxuICogICB7QGxpbmsgQ2hpbGRXb3JrZmxvd0hhbmRsZS5yZXN1bHR9XG4gKlxuICogQGRlZmF1bHQge0BsaW5rIENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlLldBSVRfQ0FOQ0VMTEFUSU9OX0NPTVBMRVRFRH1cbiAqL1xuZXhwb3J0IGVudW0gQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUge1xuICAvKipcbiAgICogRG9uJ3Qgc2VuZCBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0IHRvIHRoZSBDaGlsZC5cbiAgICovXG4gIEFCQU5ET04gPSAwLFxuXG4gIC8qKlxuICAgKiBTZW5kIGEgY2FuY2VsbGF0aW9uIHJlcXVlc3QgdG8gdGhlIENoaWxkLiBJbW1lZGlhdGVseSB0aHJvdyB0aGUgZXJyb3IuXG4gICAqL1xuICBUUllfQ0FOQ0VMID0gMSxcblxuICAvKipcbiAgICogU2VuZCBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0IHRvIHRoZSBDaGlsZC4gVGhlIENoaWxkIG1heSByZXNwZWN0IGNhbmNlbGxhdGlvbiwgaW4gd2hpY2ggY2FzZSBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICAgKiB3aGVuIGNhbmNlbGxhdGlvbiBoYXMgY29tcGxldGVkLCBhbmQge0BsaW5rIGlzQ2FuY2VsbGF0aW9ufShlcnJvcikgd2lsbCBiZSB0cnVlLiBPbiB0aGUgb3RoZXIgaGFuZCwgdGhlIENoaWxkIG1heVxuICAgKiBpZ25vcmUgdGhlIGNhbmNlbGxhdGlvbiByZXF1ZXN0LCBpbiB3aGljaCBjYXNlIGFuIGVycm9yIG1pZ2h0IGJlIHRocm93biB3aXRoIGEgZGlmZmVyZW50IGNhdXNlLCBvciB0aGUgQ2hpbGQgbWF5XG4gICAqIGNvbXBsZXRlIHN1Y2Nlc3NmdWxseS5cbiAgICpcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIFdBSVRfQ0FOQ0VMTEFUSU9OX0NPTVBMRVRFRCA9IDIsXG5cbiAgLyoqXG4gICAqIFNlbmQgYSBjYW5jZWxsYXRpb24gcmVxdWVzdCB0byB0aGUgQ2hpbGQuIFRocm93IHRoZSBlcnJvciBvbmNlIHRoZSBTZXJ2ZXIgcmVjZWl2ZXMgdGhlIENoaWxkIGNhbmNlbGxhdGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgV0FJVF9DQU5DRUxMQVRJT05fUkVRVUVTVEVEID0gMyxcbn1cblxuY2hlY2tFeHRlbmRzPGNvcmVzZGsuY2hpbGRfd29ya2Zsb3cuQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUsIENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlPigpO1xuY2hlY2tFeHRlbmRzPENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlLCBjb3Jlc2RrLmNoaWxkX3dvcmtmbG93LkNoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlPigpO1xuXG4vKipcbiAqIEhvdyBhIENoaWxkIFdvcmtmbG93IHJlYWN0cyB0byB0aGUgUGFyZW50IFdvcmtmbG93IHJlYWNoaW5nIGEgQ2xvc2VkIHN0YXRlLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby9jb25jZXB0cy93aGF0LWlzLWEtcGFyZW50LWNsb3NlLXBvbGljeS8gfCBQYXJlbnQgQ2xvc2UgUG9saWN5fVxuICovXG5leHBvcnQgZW51bSBQYXJlbnRDbG9zZVBvbGljeSB7XG4gIC8qKlxuICAgKiBJZiBhIGBQYXJlbnRDbG9zZVBvbGljeWAgaXMgc2V0IHRvIHRoaXMsIG9yIGlzIG5vdCBzZXQgYXQgYWxsLCB0aGUgc2VydmVyIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgUEFSRU5UX0NMT1NFX1BPTElDWV9VTlNQRUNJRklFRCA9IDAsXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIFBhcmVudCBpcyBDbG9zZWQsIHRoZSBDaGlsZCBpcyBUZXJtaW5hdGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgUEFSRU5UX0NMT1NFX1BPTElDWV9URVJNSU5BVEUgPSAxLFxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBQYXJlbnQgaXMgQ2xvc2VkLCBub3RoaW5nIGlzIGRvbmUgdG8gdGhlIENoaWxkLlxuICAgKi9cbiAgUEFSRU5UX0NMT1NFX1BPTElDWV9BQkFORE9OID0gMixcblxuICAvKipcbiAgICogV2hlbiB0aGUgUGFyZW50IGlzIENsb3NlZCwgdGhlIENoaWxkIGlzIENhbmNlbGxlZC5cbiAgICovXG4gIFBBUkVOVF9DTE9TRV9QT0xJQ1lfUkVRVUVTVF9DQU5DRUwgPSAzLFxufVxuXG5jaGVja0V4dGVuZHM8Y29yZXNkay5jaGlsZF93b3JrZmxvdy5QYXJlbnRDbG9zZVBvbGljeSwgUGFyZW50Q2xvc2VQb2xpY3k+KCk7XG5jaGVja0V4dGVuZHM8UGFyZW50Q2xvc2VQb2xpY3ksIGNvcmVzZGsuY2hpbGRfd29ya2Zsb3cuUGFyZW50Q2xvc2VQb2xpY3k+KCk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hpbGRXb3JrZmxvd09wdGlvbnMgZXh0ZW5kcyBDb21tb25Xb3JrZmxvd09wdGlvbnMge1xuICAvKipcbiAgICogV29ya2Zsb3cgaWQgdG8gdXNlIHdoZW4gc3RhcnRpbmcuIElmIG5vdCBzcGVjaWZpZWQgYSBVVUlEIGlzIGdlbmVyYXRlZC4gTm90ZSB0aGF0IGl0IGlzXG4gICAqIGRhbmdlcm91cyBhcyBpbiBjYXNlIG9mIGNsaWVudCBzaWRlIHJldHJpZXMgbm8gZGVkdXBsaWNhdGlvbiB3aWxsIGhhcHBlbiBiYXNlZCBvbiB0aGVcbiAgICogZ2VuZXJhdGVkIGlkLiBTbyBwcmVmZXIgYXNzaWduaW5nIGJ1c2luZXNzIG1lYW5pbmdmdWwgaWRzIGlmIHBvc3NpYmxlLlxuICAgKi9cbiAgd29ya2Zsb3dJZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGFzayBxdWV1ZSB0byB1c2UgZm9yIFdvcmtmbG93IHRhc2tzLiBJdCBzaG91bGQgbWF0Y2ggYSB0YXNrIHF1ZXVlIHNwZWNpZmllZCB3aGVuIGNyZWF0aW5nIGFcbiAgICogYFdvcmtlcmAgdGhhdCBob3N0cyB0aGUgV29ya2Zsb3cgY29kZS5cbiAgICovXG4gIHRhc2tRdWV1ZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmaWVzOlxuICAgKiAtIHdoZXRoZXIgY2FuY2VsbGF0aW9uIHJlcXVlc3RzIGFyZSBzZW50IHRvIHRoZSBDaGlsZFxuICAgKiAtIHdoZXRoZXIgYW5kIHdoZW4gYW4gZXJyb3IgaXMgdGhyb3duIGZyb20ge0BsaW5rIGV4ZWN1dGVDaGlsZH0gb3JcbiAgICogICB7QGxpbmsgQ2hpbGRXb3JrZmxvd0hhbmRsZS5yZXN1bHR9XG4gICAqXG4gICAqIEBkZWZhdWx0IHtAbGluayBDaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZS5XQUlUX0NBTkNFTExBVElPTl9DT01QTEVURUR9XG4gICAqL1xuICBjYW5jZWxsYXRpb25UeXBlPzogQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGU7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyBob3cgdGhlIENoaWxkIHJlYWN0cyB0byB0aGUgUGFyZW50IFdvcmtmbG93IHJlYWNoaW5nIGEgQ2xvc2VkIHN0YXRlLlxuICAgKlxuICAgKiBAZGVmYXVsdCB7QGxpbmsgUGFyZW50Q2xvc2VQb2xpY3kuUEFSRU5UX0NMT1NFX1BPTElDWV9URVJNSU5BVEV9XG4gICAqL1xuICBwYXJlbnRDbG9zZVBvbGljeT86IFBhcmVudENsb3NlUG9saWN5O1xuXG4gIC8qKlxuICAgKiBXaGVuIHVzaW5nIHRoZSBXb3JrZXIgVmVyc2lvbmluZyBmZWF0dXJlLCBzcGVjaWZpZXMgd2hldGhlciB0aGlzIENoaWxkIFdvcmtmbG93IHNob3VsZCBydW4gb25cbiAgICogYSB3b3JrZXIgd2l0aCBhIGNvbXBhdGlibGUgQnVpbGQgSWQgb3Igbm90LiBTZWUge0BsaW5rIFZlcnNpb25pbmdJbnRlbnR9LlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICB2ZXJzaW9uaW5nSW50ZW50PzogVmVyc2lvbmluZ0ludGVudDtcbn1cblxuZXhwb3J0IHR5cGUgUmVxdWlyZWRDaGlsZFdvcmtmbG93T3B0aW9ucyA9IFJlcXVpcmVkPFBpY2s8Q2hpbGRXb3JrZmxvd09wdGlvbnMsICd3b3JrZmxvd0lkJyB8ICdjYW5jZWxsYXRpb25UeXBlJz4+ICYge1xuICBhcmdzOiB1bmtub3duW107XG59O1xuXG5leHBvcnQgdHlwZSBDaGlsZFdvcmtmbG93T3B0aW9uc1dpdGhEZWZhdWx0cyA9IENoaWxkV29ya2Zsb3dPcHRpb25zICYgUmVxdWlyZWRDaGlsZFdvcmtmbG93T3B0aW9ucztcblxuZXhwb3J0IGludGVyZmFjZSBTREtJbmZvIHtcbiAgbmFtZTogc3RyaW5nO1xuICB2ZXJzaW9uOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNsaWNlIG9mIGEgZmlsZSBzdGFydGluZyBhdCBsaW5lT2Zmc2V0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVNsaWNlIHtcbiAgLyoqXG4gICAqIHNsaWNlIG9mIGEgZmlsZSB3aXRoIGBcXG5gIChuZXdsaW5lKSBsaW5lIHRlcm1pbmF0b3IuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBPbmx5IHVzZWQgcG9zc2libGUgdG8gdHJpbSB0aGUgZmlsZSB3aXRob3V0IGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuXG4gICAqL1xuICBsaW5lT2Zmc2V0OiBudW1iZXI7XG59XG5cbi8qKlxuICogQSBwb2ludGVyIHRvIGEgbG9jYXRpb24gaW4gYSBmaWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUxvY2F0aW9uIHtcbiAgLyoqXG4gICAqIFBhdGggdG8gc291cmNlIGZpbGUgKGFic29sdXRlIG9yIHJlbGF0aXZlKS5cbiAgICogV2hlbiB1c2luZyBhIHJlbGF0aXZlIHBhdGgsIG1ha2Ugc3VyZSBhbGwgcGF0aHMgYXJlIHJlbGF0aXZlIHRvIHRoZSBzYW1lIHJvb3QuXG4gICAqL1xuICBmaWxlUGF0aD86IHN0cmluZztcbiAgLyoqXG4gICAqIElmIHBvc3NpYmxlLCBTREsgc2hvdWxkIHNlbmQgdGhpcywgcmVxdWlyZWQgZm9yIGRpc3BsYXlpbmcgdGhlIGNvZGUgbG9jYXRpb24uXG4gICAqL1xuICBsaW5lPzogbnVtYmVyO1xuICAvKipcbiAgICogSWYgcG9zc2libGUsIFNESyBzaG91bGQgc2VuZCB0aGlzLlxuICAgKi9cbiAgY29sdW1uPzogbnVtYmVyO1xuICAvKipcbiAgICogRnVuY3Rpb24gbmFtZSB0aGlzIGxpbmUgYmVsb25ncyB0byAoaWYgYXBwbGljYWJsZSkuXG4gICAqIFVzZWQgZm9yIGZhbGxpbmcgYmFjayB0byBzdGFjayB0cmFjZSB2aWV3LlxuICAgKi9cbiAgZnVuY3Rpb25OYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YWNrVHJhY2Uge1xuICBsb2NhdGlvbnM6IEZpbGVMb2NhdGlvbltdO1xufVxuXG4vKipcbiAqIFVzZWQgYXMgdGhlIHJlc3VsdCBmb3IgdGhlIGVuaGFuY2VkIHN0YWNrIHRyYWNlIHF1ZXJ5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW5oYW5jZWRTdGFja1RyYWNlIHtcbiAgc2RrOiBTREtJbmZvO1xuICAvKipcbiAgICogTWFwcGluZyBvZiBmaWxlIHBhdGggdG8gZmlsZSBjb250ZW50cy5cbiAgICogU0RLIG1heSBjaG9vc2UgdG8gc2VuZCBubywgc29tZSBvciBhbGwgc291cmNlcy5cbiAgICogU291cmNlcyBtaWdodCBiZSB0cmltbWVkLCBhbmQgc29tZSB0aW1lIG9ubHkgdGhlIGZpbGUocykgb2YgdGhlIHRvcCBlbGVtZW50IG9mIHRoZSB0cmFjZSB3aWxsIGJlIHNlbnQuXG4gICAqL1xuICBzb3VyY2VzOiBSZWNvcmQ8c3RyaW5nLCBGaWxlU2xpY2VbXT47XG4gIHN0YWNrczogU3RhY2tUcmFjZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93Q3JlYXRlT3B0aW9ucyB7XG4gIGluZm86IFdvcmtmbG93SW5mbztcbiAgcmFuZG9tbmVzc1NlZWQ6IG51bWJlcltdO1xuICBub3c6IG51bWJlcjtcbiAgcGF0Y2hlczogc3RyaW5nW107XG4gIHNob3dTdGFja1RyYWNlU291cmNlczogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXb3JrZmxvd0NyZWF0ZU9wdGlvbnNJbnRlcm5hbCBleHRlbmRzIFdvcmtmbG93Q3JlYXRlT3B0aW9ucyB7XG4gIHNvdXJjZU1hcDogUmF3U291cmNlTWFwO1xuICByZWdpc3RlcmVkQWN0aXZpdHlOYW1lczogU2V0PHN0cmluZz47XG4gIGdldFRpbWVPZkRheSgpOiBiaWdpbnQ7XG59XG5cbi8qKlxuICogQSBoYW5kbGVyIGZ1bmN0aW9uIGNhcGFibGUgb2YgYWNjZXB0aW5nIHRoZSBhcmd1bWVudHMgZm9yIGEgZ2l2ZW4gU2lnbmFsRGVmaW5pdGlvbiBvciBRdWVyeURlZmluaXRpb24uXG4gKi9cbmV4cG9ydCB0eXBlIEhhbmRsZXI8XG4gIFJldCxcbiAgQXJncyBleHRlbmRzIGFueVtdLFxuICBUIGV4dGVuZHMgU2lnbmFsRGVmaW5pdGlvbjxBcmdzPiB8IFF1ZXJ5RGVmaW5pdGlvbjxSZXQsIEFyZ3M+XG4+ID0gVCBleHRlbmRzIFNpZ25hbERlZmluaXRpb248aW5mZXIgQT5cbiAgPyAoLi4uYXJnczogQSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD5cbiAgOiBUIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGluZmVyIFIsIGluZmVyIEE+XG4gID8gKC4uLmFyZ3M6IEEpID0+IFJcbiAgOiBuZXZlcjtcblxuLyoqXG4gKiBBIGhhbmRsZXIgZnVuY3Rpb24gYWNjZXB0aW5nIHNpZ25hbHMgY2FsbHMgZm9yIG5vbi1yZWdpc3RlcmVkIHNpZ25hbCBuYW1lcy5cbiAqL1xuZXhwb3J0IHR5cGUgRGVmYXVsdFNpZ25hbEhhbmRsZXIgPSAoc2lnbmFsTmFtZTogc3RyaW5nLCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuIiwiaW1wb3J0IHR5cGUgeyBSYXdTb3VyY2VNYXAgfSBmcm9tICdzb3VyY2UtbWFwJztcbmltcG9ydCB7XG4gIGRlZmF1bHRGYWlsdXJlQ29udmVydGVyLFxuICBGYWlsdXJlQ29udmVydGVyLFxuICBQYXlsb2FkQ29udmVydGVyLFxuICBhcnJheUZyb21QYXlsb2FkcyxcbiAgZGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIsXG4gIGVuc3VyZVRlbXBvcmFsRmFpbHVyZSxcbiAgSWxsZWdhbFN0YXRlRXJyb3IsXG4gIFRlbXBvcmFsRmFpbHVyZSxcbiAgV29ya2Zsb3csXG4gIFdvcmtmbG93RXhlY3V0aW9uQWxyZWFkeVN0YXJ0ZWRFcnJvcixcbiAgV29ya2Zsb3dRdWVyeVR5cGUsXG4gIFdvcmtmbG93U2lnbmFsVHlwZSxcbiAgUHJvdG9GYWlsdXJlLFxufSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuaW1wb3J0IHsgY29tcG9zZUludGVyY2VwdG9ycyB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvaW50ZXJjZXB0b3JzJztcbmltcG9ydCB7IGNoZWNrRXh0ZW5kcywgU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL3R5cGUtaGVscGVycyc7XG5pbXBvcnQgdHlwZSB7IGNvcmVzZGsgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQgeyBhbGVhLCBSTkcgfSBmcm9tICcuL2FsZWEnO1xuaW1wb3J0IHsgUm9vdENhbmNlbGxhdGlvblNjb3BlIH0gZnJvbSAnLi9jYW5jZWxsYXRpb24tc2NvcGUnO1xuaW1wb3J0IHsgRGV0ZXJtaW5pc21WaW9sYXRpb25FcnJvciwgaXNDYW5jZWxsYXRpb24gfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBRdWVyeUlucHV0LCBTaWduYWxJbnB1dCwgV29ya2Zsb3dFeGVjdXRlSW5wdXQsIFdvcmtmbG93SW50ZXJjZXB0b3JzIH0gZnJvbSAnLi9pbnRlcmNlcHRvcnMnO1xuaW1wb3J0IHtcbiAgQ29udGludWVBc05ldyxcbiAgRGVmYXVsdFNpZ25hbEhhbmRsZXIsXG4gIFNES0luZm8sXG4gIEZpbGVTbGljZSxcbiAgRW5oYW5jZWRTdGFja1RyYWNlLFxuICBGaWxlTG9jYXRpb24sXG4gIFdvcmtmbG93SW5mbyxcbiAgV29ya2Zsb3dDcmVhdGVPcHRpb25zSW50ZXJuYWwsXG59IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTaW5rQ2FsbCB9IGZyb20gJy4vc2lua3MnO1xuaW1wb3J0IHsgdW50cmFja1Byb21pc2UgfSBmcm9tICcuL3N0YWNrLWhlbHBlcnMnO1xuaW1wb3J0IHBrZyBmcm9tICcuL3BrZyc7XG5pbXBvcnQgeyBtYXliZUdldEFjdGl2YXRvclVudHlwZWQgfSBmcm9tICcuL2dsb2JhbC1hdHRyaWJ1dGVzJztcblxuZW51bSBTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZSB7XG4gIFNUQVJUX0NISUxEX1dPUktGTE9XX0VYRUNVVElPTl9GQUlMRURfQ0FVU0VfVU5TUEVDSUZJRUQgPSAwLFxuICBTVEFSVF9DSElMRF9XT1JLRkxPV19FWEVDVVRJT05fRkFJTEVEX0NBVVNFX1dPUktGTE9XX0FMUkVBRFlfRVhJU1RTID0gMSxcbn1cblxuY2hlY2tFeHRlbmRzPGNvcmVzZGsuY2hpbGRfd29ya2Zsb3cuU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2UsIFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZENhdXNlPigpO1xuY2hlY2tFeHRlbmRzPFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZENhdXNlLCBjb3Jlc2RrLmNoaWxkX3dvcmtmbG93LlN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZENhdXNlPigpO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YWNrIHtcbiAgZm9ybWF0dGVkOiBzdHJpbmc7XG4gIHN0cnVjdHVyZWQ6IEZpbGVMb2NhdGlvbltdO1xufVxuXG4vKipcbiAqIEdsb2JhbCBzdG9yZSB0byB0cmFjayBwcm9taXNlIHN0YWNrcyBmb3Igc3RhY2sgdHJhY2UgcXVlcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9taXNlU3RhY2tTdG9yZSB7XG4gIGNoaWxkVG9QYXJlbnQ6IE1hcDxQcm9taXNlPHVua25vd24+LCBTZXQ8UHJvbWlzZTx1bmtub3duPj4+O1xuICBwcm9taXNlVG9TdGFjazogTWFwPFByb21pc2U8dW5rbm93bj4sIFN0YWNrPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uIHtcbiAgcmVzb2x2ZSh2YWw6IHVua25vd24pOiB1bmtub3duO1xuICByZWplY3QocmVhc29uOiB1bmtub3duKTogdW5rbm93bjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb25kaXRpb24ge1xuICBmbigpOiBib29sZWFuO1xuICByZXNvbHZlKCk6IHZvaWQ7XG59XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGFjdHMgYXMgYSBtYXJrZXIgZm9yIHRoaXMgc3BlY2lhbCByZXN1bHQgdHlwZVxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ0xvY2FsQWN0aXZpdHlEb0JhY2tvZmYnKVxuZXhwb3J0IGNsYXNzIExvY2FsQWN0aXZpdHlEb0JhY2tvZmYgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBiYWNrb2ZmOiBjb3Jlc2RrLmFjdGl2aXR5X3Jlc3VsdC5JRG9CYWNrb2ZmKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBBY3RpdmF0aW9uSGFuZGxlckZ1bmN0aW9uPEsgZXh0ZW5kcyBrZXlvZiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVdvcmtmbG93QWN0aXZhdGlvbkpvYj4gPSAoXG4gIGFjdGl2YXRpb246IE5vbk51bGxhYmxlPGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JV29ya2Zsb3dBY3RpdmF0aW9uSm9iW0tdPlxuKSA9PiB2b2lkO1xuXG4vKipcbiAqIFZlcmlmaWVzIGFsbCBhY3RpdmF0aW9uIGpvYiBoYW5kbGluZyBtZXRob2RzIGFyZSBpbXBsZW1lbnRlZFxuICovXG5leHBvcnQgdHlwZSBBY3RpdmF0aW9uSGFuZGxlciA9IHtcbiAgW1AgaW4ga2V5b2YgY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklXb3JrZmxvd0FjdGl2YXRpb25Kb2JdOiBBY3RpdmF0aW9uSGFuZGxlckZ1bmN0aW9uPFA+O1xufTtcblxuLyoqXG4gKiBLZWVwcyBhbGwgb2YgdGhlIFdvcmtmbG93IHJ1bnRpbWUgc3RhdGUgbGlrZSBwZW5kaW5nIGNvbXBsZXRpb25zIGZvciBhY3Rpdml0aWVzIGFuZCB0aW1lcnMuXG4gKlxuICogSW1wbGVtZW50cyBoYW5kbGVycyBmb3IgYWxsIHdvcmtmbG93IGFjdGl2YXRpb24gam9icy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFjdGl2YXRvciBpbXBsZW1lbnRzIEFjdGl2YXRpb25IYW5kbGVyIHtcbiAgLyoqXG4gICAqIENhY2hlIGZvciBtb2R1bGVzIC0gcmVmZXJlbmNlZCBpbiByZXVzYWJsZS12bS50c1xuICAgKi9cbiAgcmVhZG9ubHkgbW9kdWxlQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgdW5rbm93bj4oKTtcbiAgLyoqXG4gICAqIE1hcCBvZiB0YXNrIHNlcXVlbmNlIHRvIGEgQ29tcGxldGlvblxuICAgKi9cbiAgcmVhZG9ubHkgY29tcGxldGlvbnMgPSB7XG4gICAgdGltZXI6IG5ldyBNYXA8bnVtYmVyLCBDb21wbGV0aW9uPigpLFxuICAgIGFjdGl2aXR5OiBuZXcgTWFwPG51bWJlciwgQ29tcGxldGlvbj4oKSxcbiAgICBjaGlsZFdvcmtmbG93U3RhcnQ6IG5ldyBNYXA8bnVtYmVyLCBDb21wbGV0aW9uPigpLFxuICAgIGNoaWxkV29ya2Zsb3dDb21wbGV0ZTogbmV3IE1hcDxudW1iZXIsIENvbXBsZXRpb24+KCksXG4gICAgc2lnbmFsV29ya2Zsb3c6IG5ldyBNYXA8bnVtYmVyLCBDb21wbGV0aW9uPigpLFxuICAgIGNhbmNlbFdvcmtmbG93OiBuZXcgTWFwPG51bWJlciwgQ29tcGxldGlvbj4oKSxcbiAgfTtcblxuICAvKipcbiAgICogSG9sZHMgYnVmZmVyZWQgc2lnbmFsIGNhbGxzIHVudGlsIGEgaGFuZGxlciBpcyByZWdpc3RlcmVkXG4gICAqL1xuICByZWFkb25seSBidWZmZXJlZFNpZ25hbHMgPSBBcnJheTxjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVNpZ25hbFdvcmtmbG93PigpO1xuXG4gIC8qKlxuICAgKiBIb2xkcyBidWZmZXJlZCBxdWVyeSBjYWxscyB1bnRpbCBhIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogKipJTVBPUlRBTlQqKiBxdWVyaWVzIGFyZSBvbmx5IGJ1ZmZlcmVkIHVudGlsIHdvcmtmbG93IGlzIHN0YXJ0ZWQuXG4gICAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBhc3luYyBpbnRlcmNlcHRvcnMgbWlnaHQgYmxvY2sgd29ya2Zsb3cgZnVuY3Rpb24gaW52b2NhdGlvblxuICAgKiB3aGljaCBkZWxheXMgcXVlcnkgaGFuZGxlciByZWdpc3RyYXRpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYnVmZmVyZWRRdWVyaWVzID0gQXJyYXk8Y29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklRdWVyeVdvcmtmbG93PigpO1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIG9mIHNpZ25hbCBuYW1lIHRvIGhhbmRsZXJcbiAgICovXG4gIHJlYWRvbmx5IHNpZ25hbEhhbmRsZXJzID0gbmV3IE1hcDxzdHJpbmcsIFdvcmtmbG93U2lnbmFsVHlwZT4oKTtcblxuICAvKipcbiAgICogQSBzaWduYWwgaGFuZGxlciB0aGF0IGNhdGNoZXMgY2FsbHMgZm9yIG5vbi1yZWdpc3RlcmVkIHNpZ25hbCBuYW1lcy5cbiAgICovXG4gIGRlZmF1bHRTaWduYWxIYW5kbGVyPzogRGVmYXVsdFNpZ25hbEhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIFNvdXJjZSBtYXAgZmlsZSBmb3IgbG9va2luZyB1cCB0aGUgc291cmNlIGZpbGVzIGluIHJlc3BvbnNlIHRvIF9fZW5oYW5jZWRfc3RhY2tfdHJhY2VcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBzb3VyY2VNYXA6IFJhd1NvdXJjZU1hcDtcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdG8gc2VuZCB0aGUgc291cmNlcyBpbiBlbmhhbmNlZCBzdGFjayB0cmFjZSBxdWVyeSByZXNwb25zZXNcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBzaG93U3RhY2tUcmFjZVNvdXJjZXM7XG5cbiAgcmVhZG9ubHkgcHJvbWlzZVN0YWNrU3RvcmU6IFByb21pc2VTdGFja1N0b3JlID0ge1xuICAgIHByb21pc2VUb1N0YWNrOiBuZXcgTWFwKCksXG4gICAgY2hpbGRUb1BhcmVudDogbmV3IE1hcCgpLFxuICB9O1xuXG4gIHB1YmxpYyByZWFkb25seSByb290U2NvcGUgPSBuZXcgUm9vdENhbmNlbGxhdGlvblNjb3BlKCk7XG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgb2YgcXVlcnkgbmFtZSB0byBoYW5kbGVyXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcXVlcnlIYW5kbGVycyA9IG5ldyBNYXA8c3RyaW5nLCBXb3JrZmxvd1F1ZXJ5VHlwZT4oW1xuICAgIFtcbiAgICAgICdfX3N0YWNrX3RyYWNlJyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2tUcmFjZXMoKVxuICAgICAgICAgIC5tYXAoKHMpID0+IHMuZm9ybWF0dGVkKVxuICAgICAgICAgIC5qb2luKCdcXG5cXG4nKTtcbiAgICAgIH0sXG4gICAgXSxcbiAgICBbXG4gICAgICAnX19lbmhhbmNlZF9zdGFja190cmFjZScsXG4gICAgICAoKTogRW5oYW5jZWRTdGFja1RyYWNlID0+IHtcbiAgICAgICAgY29uc3QgeyBzb3VyY2VNYXAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNkazogU0RLSW5mbyA9IHsgbmFtZTogJ3R5cGVzY3JpcHQnLCB2ZXJzaW9uOiBwa2cudmVyc2lvbiB9O1xuICAgICAgICBjb25zdCBzdGFja3MgPSB0aGlzLmdldFN0YWNrVHJhY2VzKCkubWFwKCh7IHN0cnVjdHVyZWQ6IGxvY2F0aW9ucyB9KSA9PiAoeyBsb2NhdGlvbnMgfSkpO1xuICAgICAgICBjb25zdCBzb3VyY2VzOiBSZWNvcmQ8c3RyaW5nLCBGaWxlU2xpY2VbXT4gPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuc2hvd1N0YWNrVHJhY2VTb3VyY2VzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB7IGxvY2F0aW9ucyB9IG9mIHN0YWNrcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGZpbGVQYXRoIH0gb2YgbG9jYXRpb25zKSB7XG4gICAgICAgICAgICAgIGlmICghZmlsZVBhdGgpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gc291cmNlTWFwPy5zb3VyY2VzQ29udGVudD8uW3NvdXJjZU1hcD8uc291cmNlcy5pbmRleE9mKGZpbGVQYXRoKV07XG4gICAgICAgICAgICAgIGlmICghY29udGVudCkgY29udGludWU7XG4gICAgICAgICAgICAgIHNvdXJjZXNbZmlsZVBhdGhdID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNkaywgc3RhY2tzLCBzb3VyY2VzIH07XG4gICAgICB9LFxuICAgIF0sXG4gIF0pO1xuXG4gIC8qKlxuICAgKiBMb2FkZWQgaW4ge0BsaW5rIGluaXRSdW50aW1lfVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGludGVyY2VwdG9yczogUmVxdWlyZWQ8V29ya2Zsb3dJbnRlcmNlcHRvcnM+ID0geyBpbmJvdW5kOiBbXSwgb3V0Ym91bmQ6IFtdLCBpbnRlcm5hbHM6IFtdIH07XG5cbiAgLyoqXG4gICAqIEJ1ZmZlciB0aGF0IHN0b3JlcyBhbGwgZ2VuZXJhdGVkIGNvbW1hbmRzLCByZXNldCBhZnRlciBlYWNoIGFjdGl2YXRpb25cbiAgICovXG4gIHByb3RlY3RlZCBjb21tYW5kczogY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5JV29ya2Zsb3dDb21tYW5kW10gPSBbXTtcblxuICAvKipcbiAgICogU3RvcmVzIGFsbCB7QGxpbmsgY29uZGl0aW9ufXMgdGhhdCBoYXZlbid0IGJlZW4gdW5ibG9ja2VkIHlldFxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGJsb2NrZWRDb25kaXRpb25zID0gbmV3IE1hcDxudW1iZXIsIENvbmRpdGlvbj4oKTtcblxuICAvKipcbiAgICogSXMgdGhpcyBXb3JrZmxvdyBjb21wbGV0ZWQ/XG4gICAqXG4gICAqIEEgV29ya2Zsb3cgd2lsbCBiZSBjb25zaWRlcmVkIGNvbXBsZXRlZCBpZiBpdCBnZW5lcmF0ZXMgYSBjb21tYW5kIHRoYXQgdGhlXG4gICAqIHN5c3RlbSBjb25zaWRlcnMgYXMgYSBmaW5hbCBXb3JrZmxvdyBjb21tYW5kIChlLmcuXG4gICAqIGNvbXBsZXRlV29ya2Zsb3dFeGVjdXRpb24gb3IgZmFpbFdvcmtmbG93RXhlY3V0aW9uKS5cbiAgICovXG4gIHB1YmxpYyBjb21wbGV0ZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogV2FzIHRoaXMgV29ya2Zsb3cgY2FuY2VsbGVkP1xuICAgKi9cbiAgcHJvdGVjdGVkIGNhbmNlbGxlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRyYWNrZWQgdG8gYWxsb3cgYnVmZmVyaW5nIHF1ZXJpZXMgdW50aWwgYSB3b3JrZmxvdyBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAqIFRPRE8oYmVyZ3VuZHkpOiBJIGRvbid0IHRoaW5rIHRoaXMgbWFrZXMgc2Vuc2Ugc2luY2UgcXVlcmllcyBydW4gbGFzdCBpbiBhbiBhY3RpdmF0aW9uIGFuZCBtdXN0IGJlIHJlc3BvbmRlZCB0byBpblxuICAgKiB0aGUgc2FtZSBhY3RpdmF0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIHdvcmtmbG93RnVuY3Rpb25XYXNDYWxsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIG5leHQgKGluY3JlbWVudGFsKSBzZXF1ZW5jZSB0byBhc3NpZ24gd2hlbiBnZW5lcmF0aW5nIGNvbXBsZXRhYmxlIGNvbW1hbmRzXG4gICAqL1xuICBwdWJsaWMgbmV4dFNlcXMgPSB7XG4gICAgdGltZXI6IDEsXG4gICAgYWN0aXZpdHk6IDEsXG4gICAgY2hpbGRXb3JrZmxvdzogMSxcbiAgICBzaWduYWxXb3JrZmxvdzogMSxcbiAgICBjYW5jZWxXb3JrZmxvdzogMSxcbiAgICBjb25kaXRpb246IDEsXG4gICAgLy8gVXNlZCBpbnRlcm5hbGx5IHRvIGtlZXAgdHJhY2sgb2YgYWN0aXZlIHN0YWNrIHRyYWNlc1xuICAgIHN0YWNrOiAxLFxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHNldCBldmVyeSB0aW1lIHRoZSB3b3JrZmxvdyBleGVjdXRlcyBhbiBhY3RpdmF0aW9uXG4gICAqL1xuICBub3c6IG51bWJlcjtcblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IFdvcmtmbG93LCBpbml0aWFsaXplZCB3aGVuIGEgV29ya2Zsb3cgaXMgc3RhcnRlZFxuICAgKi9cbiAgcHVibGljIHdvcmtmbG93PzogV29ya2Zsb3c7XG5cbiAgLyoqXG4gICAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IFdvcmtmbG93XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaW5mbzogV29ya2Zsb3dJbmZvO1xuXG4gIC8qKlxuICAgKiBBIGRldGVybWluaXN0aWMgUk5HLCB1c2VkIGJ5IHRoZSBpc29sYXRlJ3Mgb3ZlcnJpZGRlbiBNYXRoLnJhbmRvbVxuICAgKi9cbiAgcHVibGljIHJhbmRvbTogUk5HO1xuXG4gIHB1YmxpYyBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyID0gZGVmYXVsdFBheWxvYWRDb252ZXJ0ZXI7XG4gIHB1YmxpYyBmYWlsdXJlQ29udmVydGVyOiBGYWlsdXJlQ29udmVydGVyID0gZGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXI7XG5cbiAgLyoqXG4gICAqIFBhdGNoZXMgd2Uga25vdyB0aGUgc3RhdHVzIG9mIGZvciB0aGlzIHdvcmtmbG93LCBhcyBpbiB7QGxpbmsgcGF0Y2hlZH1cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBrbm93blByZXNlbnRQYXRjaGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgLyoqXG4gICAqIFBhdGNoZXMgd2Ugc2VudCB0byBjb3JlIHtAbGluayBwYXRjaGVkfVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHNlbnRQYXRjaGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgLyoqXG4gICAqIEJ1ZmZlcmVkIHNpbmsgY2FsbHMgcGVyIGFjdGl2YXRpb25cbiAgICovXG4gIHNpbmtDYWxscyA9IEFycmF5PFNpbmtDYWxsPigpO1xuXG4gIC8qKlxuICAgKiBBIG5hbm9zZWNvbmQgcmVzb2x1dGlvbiB0aW1lIGZ1bmN0aW9uLCBleHRlcm5hbGx5IGluamVjdGVkXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZ2V0VGltZU9mRGF5OiAoKSA9PiBiaWdpbnQ7XG5cbiAgcHVibGljIHJlYWRvbmx5IHJlZ2lzdGVyZWRBY3Rpdml0eU5hbWVzOiBTZXQ8c3RyaW5nPjtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgaW5mbyxcbiAgICBub3csXG4gICAgc2hvd1N0YWNrVHJhY2VTb3VyY2VzLFxuICAgIHNvdXJjZU1hcCxcbiAgICBnZXRUaW1lT2ZEYXksXG4gICAgcmFuZG9tbmVzc1NlZWQsXG4gICAgcGF0Y2hlcyxcbiAgICByZWdpc3RlcmVkQWN0aXZpdHlOYW1lcyxcbiAgfTogV29ya2Zsb3dDcmVhdGVPcHRpb25zSW50ZXJuYWwpIHtcbiAgICB0aGlzLmdldFRpbWVPZkRheSA9IGdldFRpbWVPZkRheTtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgIHRoaXMubm93ID0gbm93O1xuICAgIHRoaXMuc2hvd1N0YWNrVHJhY2VTb3VyY2VzID0gc2hvd1N0YWNrVHJhY2VTb3VyY2VzO1xuICAgIHRoaXMuc291cmNlTWFwID0gc291cmNlTWFwO1xuICAgIHRoaXMucmFuZG9tID0gYWxlYShyYW5kb21uZXNzU2VlZCk7XG4gICAgdGhpcy5yZWdpc3RlcmVkQWN0aXZpdHlOYW1lcyA9IHJlZ2lzdGVyZWRBY3Rpdml0eU5hbWVzO1xuXG4gICAgaWYgKGluZm8udW5zYWZlLmlzUmVwbGF5aW5nKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhdGNoSWQgb2YgcGF0Y2hlcykge1xuICAgICAgICB0aGlzLm5vdGlmeUhhc1BhdGNoKHsgcGF0Y2hJZCB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0U3RhY2tUcmFjZXMoKTogU3RhY2tbXSB7XG4gICAgY29uc3QgeyBjaGlsZFRvUGFyZW50LCBwcm9taXNlVG9TdGFjayB9ID0gdGhpcy5wcm9taXNlU3RhY2tTdG9yZTtcbiAgICBjb25zdCBpbnRlcm5hbE5vZGVzID0gWy4uLmNoaWxkVG9QYXJlbnQudmFsdWVzKCldLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHAgb2YgY3Vycikge1xuICAgICAgICBhY2MuYWRkKHApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBuZXcgU2V0KCkpO1xuICAgIGNvbnN0IHN0YWNrcyA9IG5ldyBNYXA8c3RyaW5nLCBTdGFjaz4oKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkVG9QYXJlbnQua2V5cygpKSB7XG4gICAgICBpZiAoIWludGVybmFsTm9kZXMuaGFzKGNoaWxkKSkge1xuICAgICAgICBjb25zdCBzdGFjayA9IHByb21pc2VUb1N0YWNrLmdldChjaGlsZCk7XG4gICAgICAgIGlmICghc3RhY2sgfHwgIXN0YWNrLmZvcm1hdHRlZCkgY29udGludWU7XG4gICAgICAgIHN0YWNrcy5zZXQoc3RhY2suZm9ybWF0dGVkLCBzdGFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE5vdCAxMDAlIHN1cmUgd2hlcmUgdGhpcyBjb21lcyBmcm9tLCBqdXN0IGZpbHRlciBpdCBvdXRcbiAgICBzdGFja3MuZGVsZXRlKCcgICAgYXQgUHJvbWlzZS50aGVuICg8YW5vbnltb3VzPiknKTtcbiAgICBzdGFja3MuZGVsZXRlKCcgICAgYXQgUHJvbWlzZS50aGVuICg8YW5vbnltb3VzPilcXG4nKTtcbiAgICByZXR1cm4gWy4uLnN0YWNrc10ubWFwKChbXywgc3RhY2tdKSA9PiBzdGFjayk7XG4gIH1cblxuICBnZXRBbmRSZXNldFNpbmtDYWxscygpOiBTaW5rQ2FsbFtdIHtcbiAgICBjb25zdCB7IHNpbmtDYWxscyB9ID0gdGhpcztcbiAgICB0aGlzLnNpbmtDYWxscyA9IFtdO1xuICAgIHJldHVybiBzaW5rQ2FsbHM7XG4gIH1cblxuICAvKipcbiAgICogQnVmZmVyIGEgV29ya2Zsb3cgY29tbWFuZCB0byBiZSBjb2xsZWN0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBhY3RpdmF0aW9uLlxuICAgKlxuICAgKiBQcmV2ZW50cyBjb21tYW5kcyBmcm9tIGJlaW5nIGFkZGVkIGFmdGVyIFdvcmtmbG93IGNvbXBsZXRpb24uXG4gICAqL1xuICBwdXNoQ29tbWFuZChjbWQ6IGNvcmVzZGsud29ya2Zsb3dfY29tbWFuZHMuSVdvcmtmbG93Q29tbWFuZCwgY29tcGxldGUgPSBmYWxzZSk6IHZvaWQge1xuICAgIC8vIE9ubHkgcXVlcnkgcmVzcG9uc2VzIG1heSBiZSBzZW50IGFmdGVyIGNvbXBsZXRpb25cbiAgICBpZiAodGhpcy5jb21wbGV0ZWQgJiYgIWNtZC5yZXNwb25kVG9RdWVyeSkgcmV0dXJuO1xuICAgIHRoaXMuY29tbWFuZHMucHVzaChjbWQpO1xuICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGdldEFuZFJlc2V0Q29tbWFuZHMoKTogY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5JV29ya2Zsb3dDb21tYW5kW10ge1xuICAgIGNvbnN0IGNvbW1hbmRzID0gdGhpcy5jb21tYW5kcztcbiAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgcmV0dXJuIGNvbW1hbmRzO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHN0YXJ0V29ya2Zsb3dOZXh0SGFuZGxlcih7IGFyZ3MgfTogV29ya2Zsb3dFeGVjdXRlSW5wdXQpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHsgd29ya2Zsb3cgfSA9IHRoaXM7XG4gICAgaWYgKHdvcmtmbG93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFcnJvcignV29ya2Zsb3cgdW5pbml0aWFsaXplZCcpO1xuICAgIH1cbiAgICBsZXQgcHJvbWlzZTogUHJvbWlzZTxhbnk+O1xuICAgIHRyeSB7XG4gICAgICBwcm9taXNlID0gd29ya2Zsb3coLi4uYXJncyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIEd1YXJhbnRlZSB0aGlzIHJ1bnMgZXZlbiBpZiB0aGVyZSB3YXMgYW4gZXhjZXB0aW9uIHdoZW4gaW52b2tpbmcgdGhlIFdvcmtmbG93IGZ1bmN0aW9uXG4gICAgICAvLyBPdGhlcndpc2UgdGhpcyBXb3JrZmxvdyB3aWxsIG5vdyBiZSBxdWVyeWFibGUuXG4gICAgICB0aGlzLndvcmtmbG93RnVuY3Rpb25XYXNDYWxsZWQgPSB0cnVlO1xuICAgICAgLy8gRW1wdHkgdGhlIGJ1ZmZlclxuICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXJlZFF1ZXJpZXMuc3BsaWNlKDApO1xuICAgICAgZm9yIChjb25zdCBhY3RpdmF0aW9uIG9mIGJ1ZmZlcikge1xuICAgICAgICB0aGlzLnF1ZXJ5V29ya2Zsb3coYWN0aXZhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICB9XG5cbiAgcHVibGljIHN0YXJ0V29ya2Zsb3coYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklTdGFydFdvcmtmbG93KTogdm9pZCB7XG4gICAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnModGhpcy5pbnRlcmNlcHRvcnMuaW5ib3VuZCwgJ2V4ZWN1dGUnLCB0aGlzLnN0YXJ0V29ya2Zsb3dOZXh0SGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICB1bnRyYWNrUHJvbWlzZShcbiAgICAgIGV4ZWN1dGUoe1xuICAgICAgICBoZWFkZXJzOiBhY3RpdmF0aW9uLmhlYWRlcnMgPz8ge30sXG4gICAgICAgIGFyZ3M6IGFycmF5RnJvbVBheWxvYWRzKHRoaXMucGF5bG9hZENvbnZlcnRlciwgYWN0aXZhdGlvbi5hcmd1bWVudHMpLFxuICAgICAgfSkudGhlbih0aGlzLmNvbXBsZXRlV29ya2Zsb3cuYmluZCh0aGlzKSwgdGhpcy5oYW5kbGVXb3JrZmxvd0ZhaWx1cmUuYmluZCh0aGlzKSlcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGNhbmNlbFdvcmtmbG93KF9hY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSUNhbmNlbFdvcmtmbG93KTogdm9pZCB7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIHRoaXMucm9vdFNjb3BlLmNhbmNlbCgpO1xuICB9XG5cbiAgcHVibGljIGZpcmVUaW1lcihhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSUZpcmVUaW1lcik6IHZvaWQge1xuICAgIC8vIFRpbWVycyBhcmUgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlaXIgY29tcGxldGlvbiBtaWdodCBub3QgYmUgaW4gV29ya2Zsb3cgc3RhdGUsXG4gICAgLy8gdGhpcyBpcyBkdWUgdG8gaW1tZWRpYXRlIHRpbWVyIGNhbmNlbGxhdGlvbiB0aGF0IGRvZXNuJ3QgZ28gd2FpdCBmb3IgQ29yZS5cbiAgICBjb25zdCBjb21wbGV0aW9uID0gdGhpcy5tYXliZUNvbnN1bWVDb21wbGV0aW9uKCd0aW1lcicsIGdldFNlcShhY3RpdmF0aW9uKSk7XG4gICAgY29tcGxldGlvbj8ucmVzb2x2ZSh1bmRlZmluZWQpO1xuICB9XG5cbiAgcHVibGljIHJlc29sdmVBY3Rpdml0eShhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVJlc29sdmVBY3Rpdml0eSk6IHZvaWQge1xuICAgIGlmICghYWN0aXZhdGlvbi5yZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBSZXNvbHZlQWN0aXZpdHkgYWN0aXZhdGlvbiB3aXRoIG5vIHJlc3VsdCcpO1xuICAgIH1cbiAgICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCB9ID0gdGhpcy5jb25zdW1lQ29tcGxldGlvbignYWN0aXZpdHknLCBnZXRTZXEoYWN0aXZhdGlvbikpO1xuICAgIGlmIChhY3RpdmF0aW9uLnJlc3VsdC5jb21wbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IGFjdGl2YXRpb24ucmVzdWx0LmNvbXBsZXRlZDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBsZXRlZC5yZXN1bHQgPyB0aGlzLnBheWxvYWRDb252ZXJ0ZXIuZnJvbVBheWxvYWQoY29tcGxldGVkLnJlc3VsdCkgOiB1bmRlZmluZWQ7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBlbHNlIGlmIChhY3RpdmF0aW9uLnJlc3VsdC5mYWlsZWQpIHtcbiAgICAgIGNvbnN0IHsgZmFpbHVyZSB9ID0gYWN0aXZhdGlvbi5yZXN1bHQuZmFpbGVkO1xuICAgICAgY29uc3QgZXJyID0gZmFpbHVyZSA/IHRoaXMuZmFpbHVyZVRvRXJyb3IoZmFpbHVyZSkgOiB1bmRlZmluZWQ7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24ucmVzdWx0LmNhbmNlbGxlZCkge1xuICAgICAgY29uc3QgeyBmYWlsdXJlIH0gPSBhY3RpdmF0aW9uLnJlc3VsdC5jYW5jZWxsZWQ7XG4gICAgICBjb25zdCBlcnIgPSBmYWlsdXJlID8gdGhpcy5mYWlsdXJlVG9FcnJvcihmYWlsdXJlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZhdGlvbi5yZXN1bHQuYmFja29mZikge1xuICAgICAgcmVqZWN0KG5ldyBMb2NhbEFjdGl2aXR5RG9CYWNrb2ZmKGFjdGl2YXRpb24ucmVzdWx0LmJhY2tvZmYpKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVzb2x2ZUNoaWxkV29ya2Zsb3dFeGVjdXRpb25TdGFydChcbiAgICBhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVJlc29sdmVDaGlsZFdvcmtmbG93RXhlY3V0aW9uU3RhcnRcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IHRoaXMuY29uc3VtZUNvbXBsZXRpb24oJ2NoaWxkV29ya2Zsb3dTdGFydCcsIGdldFNlcShhY3RpdmF0aW9uKSk7XG4gICAgaWYgKGFjdGl2YXRpb24uc3VjY2VlZGVkKSB7XG4gICAgICByZXNvbHZlKGFjdGl2YXRpb24uc3VjY2VlZGVkLnJ1bklkKTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24uZmFpbGVkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGFjdGl2YXRpb24uZmFpbGVkLmNhdXNlICE9PVxuICAgICAgICBTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZS5TVEFSVF9DSElMRF9XT1JLRkxPV19FWEVDVVRJT05fRkFJTEVEX0NBVVNFX1dPUktGTE9XX0FMUkVBRFlfRVhJU1RTXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUVycm9yKCdHb3QgdW5rbm93biBTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZScpO1xuICAgICAgfVxuICAgICAgaWYgKCEoYWN0aXZhdGlvbi5zZXEgJiYgYWN0aXZhdGlvbi5mYWlsZWQud29ya2Zsb3dJZCAmJiBhY3RpdmF0aW9uLmZhaWxlZC53b3JrZmxvd1R5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgYXR0cmlidXRlcyBpbiBhY3RpdmF0aW9uIGpvYicpO1xuICAgICAgfVxuICAgICAgcmVqZWN0KFxuICAgICAgICBuZXcgV29ya2Zsb3dFeGVjdXRpb25BbHJlYWR5U3RhcnRlZEVycm9yKFxuICAgICAgICAgICdXb3JrZmxvdyBleGVjdXRpb24gYWxyZWFkeSBzdGFydGVkJyxcbiAgICAgICAgICBhY3RpdmF0aW9uLmZhaWxlZC53b3JrZmxvd0lkLFxuICAgICAgICAgIGFjdGl2YXRpb24uZmFpbGVkLndvcmtmbG93VHlwZVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZhdGlvbi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmICghYWN0aXZhdGlvbi5jYW5jZWxsZWQuZmFpbHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHb3Qgbm8gZmFpbHVyZSBpbiBjYW5jZWxsZWQgdmFyaWFudCcpO1xuICAgICAgfVxuICAgICAgcmVqZWN0KHRoaXMuZmFpbHVyZVRvRXJyb3IoYWN0aXZhdGlvbi5jYW5jZWxsZWQuZmFpbHVyZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHb3QgUmVzb2x2ZUNoaWxkV29ya2Zsb3dFeGVjdXRpb25TdGFydCB3aXRoIG5vIHN0YXR1cycpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvbihhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVJlc29sdmVDaGlsZFdvcmtmbG93RXhlY3V0aW9uKTogdm9pZCB7XG4gICAgaWYgKCFhY3RpdmF0aW9uLnJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IFJlc29sdmVDaGlsZFdvcmtmbG93RXhlY3V0aW9uIGFjdGl2YXRpb24gd2l0aCBubyByZXN1bHQnKTtcbiAgICB9XG4gICAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IHRoaXMuY29uc3VtZUNvbXBsZXRpb24oJ2NoaWxkV29ya2Zsb3dDb21wbGV0ZScsIGdldFNlcShhY3RpdmF0aW9uKSk7XG4gICAgaWYgKGFjdGl2YXRpb24ucmVzdWx0LmNvbXBsZXRlZCkge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gYWN0aXZhdGlvbi5yZXN1bHQuY29tcGxldGVkO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGxldGVkLnJlc3VsdCA/IHRoaXMucGF5bG9hZENvbnZlcnRlci5mcm9tUGF5bG9hZChjb21wbGV0ZWQucmVzdWx0KSA6IHVuZGVmaW5lZDtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24ucmVzdWx0LmZhaWxlZCkge1xuICAgICAgY29uc3QgeyBmYWlsdXJlIH0gPSBhY3RpdmF0aW9uLnJlc3VsdC5mYWlsZWQ7XG4gICAgICBpZiAoZmFpbHVyZSA9PT0gdW5kZWZpbmVkIHx8IGZhaWx1cmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IGZhaWxlZCByZXN1bHQgd2l0aCBubyBmYWlsdXJlIGF0dHJpYnV0ZScpO1xuICAgICAgfVxuICAgICAgcmVqZWN0KHRoaXMuZmFpbHVyZVRvRXJyb3IoZmFpbHVyZSkpO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZhdGlvbi5yZXN1bHQuY2FuY2VsbGVkKSB7XG4gICAgICBjb25zdCB7IGZhaWx1cmUgfSA9IGFjdGl2YXRpb24ucmVzdWx0LmNhbmNlbGxlZDtcbiAgICAgIGlmIChmYWlsdXJlID09PSB1bmRlZmluZWQgfHwgZmFpbHVyZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHb3QgY2FuY2VsbGVkIHJlc3VsdCB3aXRoIG5vIGZhaWx1cmUgYXR0cmlidXRlJyk7XG4gICAgICB9XG4gICAgICByZWplY3QodGhpcy5mYWlsdXJlVG9FcnJvcihmYWlsdXJlKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW50ZW50aW9uYWxseSBub3QgbWFkZSBmdW5jdGlvbiBhc3luYyBzbyB0aGlzIGhhbmRsZXIgZG9lc24ndCBzaG93IHVwIGluIHRoZSBzdGFjayB0cmFjZVxuICBwcm90ZWN0ZWQgcXVlcnlXb3JrZmxvd05leHRIYW5kbGVyKHsgcXVlcnlOYW1lLCBhcmdzIH06IFF1ZXJ5SW5wdXQpOiBQcm9taXNlPHVua25vd24+IHtcbiAgICBjb25zdCBmbiA9IHRoaXMucXVlcnlIYW5kbGVycy5nZXQocXVlcnlOYW1lKTtcbiAgICBpZiAoZm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3Qga25vd25RdWVyeVR5cGVzID0gWy4uLnRoaXMucXVlcnlIYW5kbGVycy5rZXlzKCldLmpvaW4oJyAnKTtcbiAgICAgIC8vIEZhaWwgdGhlIHF1ZXJ5XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgICBgV29ya2Zsb3cgZGlkIG5vdCByZWdpc3RlciBhIGhhbmRsZXIgZm9yICR7cXVlcnlOYW1lfS4gUmVnaXN0ZXJlZCBxdWVyaWVzOiBbJHtrbm93blF1ZXJ5VHlwZXN9XWBcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJldCA9IGZuKC4uLmFyZ3MpO1xuICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBEZXRlcm1pbmlzbVZpb2xhdGlvbkVycm9yKCdRdWVyeSBoYW5kbGVycyBzaG91bGQgbm90IHJldHVybiBhIFByb21pc2UnKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJldCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcXVlcnlXb3JrZmxvdyhhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVF1ZXJ5V29ya2Zsb3cpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMud29ya2Zsb3dGdW5jdGlvbldhc0NhbGxlZCkge1xuICAgICAgdGhpcy5idWZmZXJlZFF1ZXJpZXMucHVzaChhY3RpdmF0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IHF1ZXJ5VHlwZSwgcXVlcnlJZCwgaGVhZGVycyB9ID0gYWN0aXZhdGlvbjtcbiAgICBpZiAoIShxdWVyeVR5cGUgJiYgcXVlcnlJZCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgcXVlcnkgYWN0aXZhdGlvbiBhdHRyaWJ1dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoXG4gICAgICB0aGlzLmludGVyY2VwdG9ycy5pbmJvdW5kLFxuICAgICAgJ2hhbmRsZVF1ZXJ5JyxcbiAgICAgIHRoaXMucXVlcnlXb3JrZmxvd05leHRIYW5kbGVyLmJpbmQodGhpcylcbiAgICApO1xuICAgIGV4ZWN1dGUoe1xuICAgICAgcXVlcnlOYW1lOiBxdWVyeVR5cGUsXG4gICAgICBhcmdzOiBhcnJheUZyb21QYXlsb2Fkcyh0aGlzLnBheWxvYWRDb252ZXJ0ZXIsIGFjdGl2YXRpb24uYXJndW1lbnRzKSxcbiAgICAgIHF1ZXJ5SWQsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzID8/IHt9LFxuICAgIH0pLnRoZW4oXG4gICAgICAocmVzdWx0KSA9PiB0aGlzLmNvbXBsZXRlUXVlcnkocXVlcnlJZCwgcmVzdWx0KSxcbiAgICAgIChyZWFzb24pID0+IHRoaXMuZmFpbFF1ZXJ5KHF1ZXJ5SWQsIHJlYXNvbilcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHNpZ25hbFdvcmtmbG93TmV4dEhhbmRsZXIoeyBzaWduYWxOYW1lLCBhcmdzIH06IFNpZ25hbElucHV0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZm4gPSB0aGlzLnNpZ25hbEhhbmRsZXJzLmdldChzaWduYWxOYW1lKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJldHVybiBhd2FpdCBmbiguLi5hcmdzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdFNpZ25hbEhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRlZmF1bHRTaWduYWxIYW5kbGVyKHNpZ25hbE5hbWUsIC4uLmFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXJyb3IoYE5vIHJlZ2lzdGVyZWQgc2lnbmFsIGhhbmRsZXIgZm9yIHNpZ25hbCAke3NpZ25hbE5hbWV9YCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNpZ25hbFdvcmtmbG93KGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JU2lnbmFsV29ya2Zsb3cpOiB2b2lkIHtcbiAgICBjb25zdCB7IHNpZ25hbE5hbWUsIGhlYWRlcnMgfSA9IGFjdGl2YXRpb247XG4gICAgaWYgKCFzaWduYWxOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGFjdGl2YXRpb24gc2lnbmFsTmFtZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zaWduYWxIYW5kbGVycy5oYXMoc2lnbmFsTmFtZSkgJiYgIXRoaXMuZGVmYXVsdFNpZ25hbEhhbmRsZXIpIHtcbiAgICAgIHRoaXMuYnVmZmVyZWRTaWduYWxzLnB1c2goYWN0aXZhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoXG4gICAgICB0aGlzLmludGVyY2VwdG9ycy5pbmJvdW5kLFxuICAgICAgJ2hhbmRsZVNpZ25hbCcsXG4gICAgICB0aGlzLnNpZ25hbFdvcmtmbG93TmV4dEhhbmRsZXIuYmluZCh0aGlzKVxuICAgICk7XG4gICAgZXhlY3V0ZSh7XG4gICAgICBhcmdzOiBhcnJheUZyb21QYXlsb2Fkcyh0aGlzLnBheWxvYWRDb252ZXJ0ZXIsIGFjdGl2YXRpb24uaW5wdXQpLFxuICAgICAgc2lnbmFsTmFtZSxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMgPz8ge30sXG4gICAgfSkuY2F0Y2godGhpcy5oYW5kbGVXb3JrZmxvd0ZhaWx1cmUuYmluZCh0aGlzKSk7XG4gIH1cblxuICBwdWJsaWMgZGlzcGF0Y2hCdWZmZXJlZFNpZ25hbHMoKTogdm9pZCB7XG4gICAgY29uc3QgYnVmZmVyZWRTaWduYWxzID0gdGhpcy5idWZmZXJlZFNpZ25hbHM7XG4gICAgd2hpbGUgKGJ1ZmZlcmVkU2lnbmFscy5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLmRlZmF1bHRTaWduYWxIYW5kbGVyKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYSBkZWZhdWx0IHNpZ25hbCBoYW5kbGVyLCBzbyBhbGwgc2lnbmFscyBhcmUgZGlzcGF0Y2hhYmxlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHRoaXMuc2lnbmFsV29ya2Zsb3coYnVmZmVyZWRTaWduYWxzLnNoaWZ0KCkhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZvdW5kSW5kZXggPSBidWZmZXJlZFNpZ25hbHMuZmluZEluZGV4KChzaWduYWwpID0+IHRoaXMuc2lnbmFsSGFuZGxlcnMuaGFzKHNpZ25hbC5zaWduYWxOYW1lID8/ICcnKSk7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgYnJlYWs7XG4gICAgICAgIGNvbnN0IFtzaWduYWxdID0gYnVmZmVyZWRTaWduYWxzLnNwbGljZShmb3VuZEluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5zaWduYWxXb3JrZmxvdyhzaWduYWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlU2lnbmFsRXh0ZXJuYWxXb3JrZmxvdyhhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVJlc29sdmVTaWduYWxFeHRlcm5hbFdvcmtmbG93KTogdm9pZCB7XG4gICAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IHRoaXMuY29uc3VtZUNvbXBsZXRpb24oJ3NpZ25hbFdvcmtmbG93JywgZ2V0U2VxKGFjdGl2YXRpb24pKTtcbiAgICBpZiAoYWN0aXZhdGlvbi5mYWlsdXJlKSB7XG4gICAgICByZWplY3QodGhpcy5mYWlsdXJlVG9FcnJvcihhY3RpdmF0aW9uLmZhaWx1cmUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlUmVxdWVzdENhbmNlbEV4dGVybmFsV29ya2Zsb3coXG4gICAgYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklSZXNvbHZlUmVxdWVzdENhbmNlbEV4dGVybmFsV29ya2Zsb3dcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IHRoaXMuY29uc3VtZUNvbXBsZXRpb24oJ2NhbmNlbFdvcmtmbG93JywgZ2V0U2VxKGFjdGl2YXRpb24pKTtcbiAgICBpZiAoYWN0aXZhdGlvbi5mYWlsdXJlKSB7XG4gICAgICByZWplY3QodGhpcy5mYWlsdXJlVG9FcnJvcihhY3RpdmF0aW9uLmZhaWx1cmUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVSYW5kb21TZWVkKGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JVXBkYXRlUmFuZG9tU2VlZCk6IHZvaWQge1xuICAgIGlmICghYWN0aXZhdGlvbi5yYW5kb21uZXNzU2VlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWN0aXZhdGlvbiB3aXRoIHJhbmRvbW5lc3NTZWVkIGF0dHJpYnV0ZScpO1xuICAgIH1cbiAgICB0aGlzLnJhbmRvbSA9IGFsZWEoYWN0aXZhdGlvbi5yYW5kb21uZXNzU2VlZC50b0J5dGVzKCkpO1xuICB9XG5cbiAgcHVibGljIG5vdGlmeUhhc1BhdGNoKGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JTm90aWZ5SGFzUGF0Y2gpOiB2b2lkIHtcbiAgICBpZiAoIWFjdGl2YXRpb24ucGF0Y2hJZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90aWZ5IGhhcyBwYXRjaCBtaXNzaW5nIHBhdGNoIG5hbWUnKTtcbiAgICB9XG4gICAgdGhpcy5rbm93blByZXNlbnRQYXRjaGVzLmFkZChhY3RpdmF0aW9uLnBhdGNoSWQpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUZyb21DYWNoZSgpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXJyb3IoJ3JlbW92ZUZyb21DYWNoZSBhY3RpdmF0aW9uIGpvYiBzaG91bGQgbm90IHJlYWNoIHdvcmtmbG93Jyk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBmYWlsdXJlcyBpbnRvIGEgY29tbWFuZCB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAqIFVzZWQgdG8gaGFuZGxlIGFueSBmYWlsdXJlIGVtaXR0ZWQgYnkgdGhlIFdvcmtmbG93LlxuICAgKi9cbiAgYXN5bmMgaGFuZGxlV29ya2Zsb3dGYWlsdXJlKGVycm9yOiB1bmtub3duKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkICYmIGlzQ2FuY2VsbGF0aW9uKGVycm9yKSkge1xuICAgICAgdGhpcy5wdXNoQ29tbWFuZCh7IGNhbmNlbFdvcmtmbG93RXhlY3V0aW9uOiB7fSB9LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29udGludWVBc05ldykge1xuICAgICAgdGhpcy5wdXNoQ29tbWFuZCh7IGNvbnRpbnVlQXNOZXdXb3JrZmxvd0V4ZWN1dGlvbjogZXJyb3IuY29tbWFuZCB9LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBUZW1wb3JhbEZhaWx1cmUpKSB7XG4gICAgICAgIC8vIFRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uIHdoaWNoIHdpbGwgZmFpbCB0aGUgYWN0aXZhdGlvblxuICAgICAgICAvLyBwcmV2ZW50aW5nIGl0IGZyb20gY29tcGxldGluZy5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaENvbW1hbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBmYWlsV29ya2Zsb3dFeGVjdXRpb246IHtcbiAgICAgICAgICAgIGZhaWx1cmU6IHRoaXMuZXJyb3JUb0ZhaWx1cmUoZXJyb3IpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb21wbGV0ZVF1ZXJ5KHF1ZXJ5SWQ6IHN0cmluZywgcmVzdWx0OiB1bmtub3duKTogdm9pZCB7XG4gICAgdGhpcy5wdXNoQ29tbWFuZCh7XG4gICAgICByZXNwb25kVG9RdWVyeTogeyBxdWVyeUlkLCBzdWNjZWVkZWQ6IHsgcmVzcG9uc2U6IHRoaXMucGF5bG9hZENvbnZlcnRlci50b1BheWxvYWQocmVzdWx0KSB9IH0sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGZhaWxRdWVyeShxdWVyeUlkOiBzdHJpbmcsIGVycm9yOiB1bmtub3duKTogdm9pZCB7XG4gICAgdGhpcy5wdXNoQ29tbWFuZCh7XG4gICAgICByZXNwb25kVG9RdWVyeToge1xuICAgICAgICBxdWVyeUlkLFxuICAgICAgICBmYWlsZWQ6IHRoaXMuZXJyb3JUb0ZhaWx1cmUoZW5zdXJlVGVtcG9yYWxGYWlsdXJlKGVycm9yKSksXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIENvbnN1bWUgYSBjb21wbGV0aW9uIGlmIGl0IGV4aXN0cyBpbiBXb3JrZmxvdyBzdGF0ZSAqL1xuICBwcml2YXRlIG1heWJlQ29uc3VtZUNvbXBsZXRpb24odHlwZToga2V5b2YgQWN0aXZhdG9yWydjb21wbGV0aW9ucyddLCB0YXNrU2VxOiBudW1iZXIpOiBDb21wbGV0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBjb21wbGV0aW9uID0gdGhpcy5jb21wbGV0aW9uc1t0eXBlXS5nZXQodGFza1NlcSk7XG4gICAgaWYgKGNvbXBsZXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jb21wbGV0aW9uc1t0eXBlXS5kZWxldGUodGFza1NlcSk7XG4gICAgfVxuICAgIHJldHVybiBjb21wbGV0aW9uO1xuICB9XG5cbiAgLyoqIENvbnN1bWUgYSBjb21wbGV0aW9uIGlmIGl0IGV4aXN0cyBpbiBXb3JrZmxvdyBzdGF0ZSwgdGhyb3dzIGlmIGl0IGRvZXNuJ3QgKi9cbiAgcHJpdmF0ZSBjb25zdW1lQ29tcGxldGlvbih0eXBlOiBrZXlvZiBBY3RpdmF0b3JbJ2NvbXBsZXRpb25zJ10sIHRhc2tTZXE6IG51bWJlcik6IENvbXBsZXRpb24ge1xuICAgIGNvbnN0IGNvbXBsZXRpb24gPSB0aGlzLm1heWJlQ29uc3VtZUNvbXBsZXRpb24odHlwZSwgdGFza1NlcSk7XG4gICAgaWYgKGNvbXBsZXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUVycm9yKGBObyBjb21wbGV0aW9uIGZvciB0YXNrU2VxICR7dGFza1NlcX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBsZXRpb247XG4gIH1cblxuICBwcml2YXRlIGNvbXBsZXRlV29ya2Zsb3cocmVzdWx0OiB1bmtub3duKTogdm9pZCB7XG4gICAgdGhpcy5wdXNoQ29tbWFuZChcbiAgICAgIHtcbiAgICAgICAgY29tcGxldGVXb3JrZmxvd0V4ZWN1dGlvbjoge1xuICAgICAgICAgIHJlc3VsdDogdGhpcy5wYXlsb2FkQ29udmVydGVyLnRvUGF5bG9hZChyZXN1bHQpLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgZXJyb3JUb0ZhaWx1cmUoZXJyOiB1bmtub3duKTogUHJvdG9GYWlsdXJlIHtcbiAgICByZXR1cm4gdGhpcy5mYWlsdXJlQ29udmVydGVyLmVycm9yVG9GYWlsdXJlKGVyciwgdGhpcy5wYXlsb2FkQ29udmVydGVyKTtcbiAgfVxuXG4gIGZhaWx1cmVUb0Vycm9yKGZhaWx1cmU6IFByb3RvRmFpbHVyZSk6IEVycm9yIHtcbiAgICByZXR1cm4gdGhpcy5mYWlsdXJlQ29udmVydGVyLmZhaWx1cmVUb0Vycm9yKGZhaWx1cmUsIHRoaXMucGF5bG9hZENvbnZlcnRlcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlR2V0QWN0aXZhdG9yKCk6IEFjdGl2YXRvciB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBtYXliZUdldEFjdGl2YXRvclVudHlwZWQoKSBhcyBBY3RpdmF0b3IgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3RpdmF0b3IoKTogQWN0aXZhdG9yIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gbWF5YmVHZXRBY3RpdmF0b3IoKTtcbiAgaWYgKGFjdGl2YXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUVycm9yKCdXb3JrZmxvdyB1bmluaXRpYWxpemVkJyk7XG4gIH1cbiAgcmV0dXJuIGFjdGl2YXRvcjtcbn1cblxuZnVuY3Rpb24gZ2V0U2VxPFQgZXh0ZW5kcyB7IHNlcT86IG51bWJlciB8IG51bGwgfT4oYWN0aXZhdGlvbjogVCk6IG51bWJlciB7XG4gIGNvbnN0IHNlcSA9IGFjdGl2YXRpb24uc2VxO1xuICBpZiAoc2VxID09PSB1bmRlZmluZWQgfHwgc2VxID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgR290IGFjdGl2YXRpb24gd2l0aCBubyBzZXEgYXR0cmlidXRlYCk7XG4gIH1cbiAgcmV0dXJuIHNlcTtcbn1cbiIsIi8vIC4uL3BhY2thZ2UuanNvbiBpcyBvdXRzaWRlIG9mIHRoZSBUUyBwcm9qZWN0IHJvb3REaXIgd2hpY2ggY2F1c2VzIFRTIHRvIGNvbXBsYWluIGFib3V0IHRoaXMgaW1wb3J0LlxuLy8gV2UgZG8gbm90IHdhbnQgdG8gY2hhbmdlIHRoZSByb290RGlyIGJlY2F1c2UgaXQgbWVzc2VzIHVwIHRoZSBvdXRwdXQgc3RydWN0dXJlLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHBrZyBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xuXG5leHBvcnQgZGVmYXVsdCBwa2cgYXMgeyBuYW1lOiBzdHJpbmc7IHZlcnNpb246IHN0cmluZyB9O1xuIiwiaW1wb3J0IHsgbWF5YmVHZXRBY3RpdmF0b3JVbnR5cGVkIH0gZnJvbSAnLi9nbG9iYWwtYXR0cmlidXRlcyc7XG5pbXBvcnQgdHlwZSB7IFByb21pc2VTdGFja1N0b3JlIH0gZnJvbSAnLi9pbnRlcm5hbHMnO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byByZW1vdmUgYSBwcm9taXNlIGZyb20gYmVpbmcgdHJhY2tlZCBmb3Igc3RhY2sgdHJhY2UgcXVlcnkgcHVycG9zZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVudHJhY2tQcm9taXNlKHByb21pc2U6IFByb21pc2U8dW5rbm93bj4pOiB2b2lkIHtcbiAgY29uc3Qgc3RvcmUgPSAobWF5YmVHZXRBY3RpdmF0b3JVbnR5cGVkKCkgYXMgYW55KT8ucHJvbWlzZVN0YWNrU3RvcmUgYXMgUHJvbWlzZVN0YWNrU3RvcmUgfCB1bmRlZmluZWQ7XG4gIGlmICghc3RvcmUpIHJldHVybjtcbiAgc3RvcmUuY2hpbGRUb1BhcmVudC5kZWxldGUocHJvbWlzZSk7XG4gIHN0b3JlLnByb21pc2VUb1N0YWNrLmRlbGV0ZShwcm9taXNlKTtcbn1cbiIsImltcG9ydCB7IENhbmNlbGxhdGlvblNjb3BlIH0gZnJvbSAnLi9jYW5jZWxsYXRpb24tc2NvcGUnO1xuaW1wb3J0IHsgdW50cmFja1Byb21pc2UgfSBmcm9tICcuL3N0YWNrLWhlbHBlcnMnO1xuXG4vKipcbiAqIEEgYFByb21pc2VMaWtlYCBoZWxwZXIgd2hpY2ggZXhwb3NlcyBpdHMgYHJlc29sdmVgIGFuZCBgcmVqZWN0YCBtZXRob2RzLlxuICpcbiAqIFRyaWdnZXIgaXMgQ2FuY2VsbGF0aW9uU2NvcGUtYXdhcmU6IGl0IGlzIGxpbmtlZCB0byB0aGUgY3VycmVudCBzY29wZSBvblxuICogY29uc3RydWN0aW9uIGFuZCB0aHJvd3Mgd2hlbiB0aGF0IHNjb3BlIGlzIGNhbmNlbGxlZC5cbiAqXG4gKiBVc2VmdWwgZm9yIGUuZy4gd2FpdGluZyBmb3IgdW5ibG9ja2luZyBhIFdvcmtmbG93IGZyb20gYSBTaWduYWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIDwhLS1TTklQU1RBUlQgdHlwZXNjcmlwdC10cmlnZ2VyLXdvcmtmbG93LS0+XG4gKiA8IS0tU05JUEVORC0tPlxuICovXG5leHBvcnQgY2xhc3MgVHJpZ2dlcjxUPiBpbXBsZW1lbnRzIFByb21pc2VMaWtlPFQ+IHtcbiAgLy8gVHlwZXNjcmlwdCBkb2VzIG5vdCByZWFsaXplIHRoYXQgdGhlIHByb21pc2UgZXhlY3V0b3IgaXMgcnVuIHN5bmNocm9ub3VzbHkgaW4gdGhlIGNvbnN0cnVjdG9yXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICBwdWJsaWMgcmVhZG9ubHkgcmVzb2x2ZTogKHZhbHVlOiBUIHwgUHJvbWlzZUxpa2U8VD4pID0+IHZvaWQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICBwdWJsaWMgcmVhZG9ubHkgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcHJvbWlzZTogUHJvbWlzZTxUPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzY29wZSA9IENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKTtcbiAgICAgIGlmIChzY29wZS5jb25zaWRlcmVkQ2FuY2VsbGVkIHx8IHNjb3BlLmNhbmNlbGxhYmxlKSB7XG4gICAgICAgIHVudHJhY2tQcm9taXNlKHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaChyZWplY3QpKTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICAvLyBBdm9pZCB1bmhhbmRsZWQgcmVqZWN0aW9uc1xuICAgIHVudHJhY2tQcm9taXNlKHRoaXMucHJvbWlzZS5jYXRjaCgoKSA9PiB1bmRlZmluZWQpKTtcbiAgfVxuXG4gIHRoZW48VFJlc3VsdDEgPSBULCBUUmVzdWx0MiA9IG5ldmVyPihcbiAgICBvbmZ1bGZpbGxlZD86ICgodmFsdWU6IFQpID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+KSB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgb25yZWplY3RlZD86ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQyIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDI+KSB8IHVuZGVmaW5lZCB8IG51bGxcbiAgKTogUHJvbWlzZUxpa2U8VFJlc3VsdDEgfCBUUmVzdWx0Mj4ge1xuICAgIHJldHVybiB0aGlzLnByb21pc2UudGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCk7XG4gIH1cbn1cbiIsIi8qKlxuICogRXhwb3J0ZWQgZnVuY3Rpb25zIGZvciB0aGUgV29ya2VyIHRvIGludGVyYWN0IHdpdGggdGhlIFdvcmtmbG93IGlzb2xhdGVcbiAqXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IElsbGVnYWxTdGF0ZUVycm9yIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uJztcbmltcG9ydCB7IG1zVG9UcywgdHNUb01zIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi90aW1lJztcbmltcG9ydCB7IGNvbXBvc2VJbnRlcmNlcHRvcnMgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL2ludGVyY2VwdG9ycyc7XG5pbXBvcnQgdHlwZSB7IGNvcmVzZGsgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQgeyBkaXNhYmxlU3RvcmFnZSB9IGZyb20gJy4vY2FuY2VsbGF0aW9uLXNjb3BlJztcbmltcG9ydCB7IERldGVybWluaXNtVmlvbGF0aW9uRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBXb3JrZmxvd0ludGVyY2VwdG9yc0ZhY3RvcnkgfSBmcm9tICcuL2ludGVyY2VwdG9ycyc7XG5pbXBvcnQgeyBXb3JrZmxvd0NyZWF0ZU9wdGlvbnNJbnRlcm5hbCwgV29ya2Zsb3dJbmZvIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IEFjdGl2YXRvciwgZ2V0QWN0aXZhdG9yIH0gZnJvbSAnLi9pbnRlcm5hbHMnO1xuaW1wb3J0IHsgU2lua0NhbGwgfSBmcm9tICcuL3NpbmtzJztcbmltcG9ydCB7IHNldEFjdGl2YXRvclVudHlwZWQgfSBmcm9tICcuL2dsb2JhbC1hdHRyaWJ1dGVzJztcblxuLy8gRXhwb3J0IHRoZSB0eXBlIGZvciB1c2Ugb24gdGhlIFwid29ya2VyXCIgc2lkZVxuZXhwb3J0IHsgUHJvbWlzZVN0YWNrU3RvcmUgfSBmcm9tICcuL2ludGVybmFscyc7XG5cbmNvbnN0IGdsb2JhbCA9IGdsb2JhbFRoaXMgYXMgYW55O1xuY29uc3QgT3JpZ2luYWxEYXRlID0gZ2xvYmFsVGhpcy5EYXRlO1xuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcnJpZGVHbG9iYWxzKCk6IHZvaWQge1xuICAvLyBNb2NrIGFueSB3ZWFrIHJlZmVyZW5jZSBiZWNhdXNlIEdDIGlzIG5vbi1kZXRlcm1pbmlzdGljIGFuZCB0aGUgZWZmZWN0IGlzIG9ic2VydmFibGUgZnJvbSB0aGUgV29ya2Zsb3cuXG4gIC8vIFdvcmtmbG93IGRldmVsb3BlciB3aWxsIGdldCBhIG1lYW5pbmdmdWwgZXhjZXB0aW9uIGlmIHRoZXkgdHJ5IHRvIHVzZSB0aGVzZS5cbiAgZ2xvYmFsLldlYWtSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IERldGVybWluaXNtVmlvbGF0aW9uRXJyb3IoJ1dlYWtSZWYgY2Fubm90IGJlIHVzZWQgaW4gV29ya2Zsb3dzIGJlY2F1c2UgdjggR0MgaXMgbm9uLWRldGVybWluaXN0aWMnKTtcbiAgfTtcbiAgZ2xvYmFsLkZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBEZXRlcm1pbmlzbVZpb2xhdGlvbkVycm9yKFxuICAgICAgJ0ZpbmFsaXphdGlvblJlZ2lzdHJ5IGNhbm5vdCBiZSB1c2VkIGluIFdvcmtmbG93cyBiZWNhdXNlIHY4IEdDIGlzIG5vbi1kZXRlcm1pbmlzdGljJ1xuICAgICk7XG4gIH07XG5cbiAgZ2xvYmFsLkRhdGUgPSBmdW5jdGlvbiAoLi4uYXJnczogdW5rbm93bltdKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyAoT3JpZ2luYWxEYXRlIGFzIGFueSkoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JpZ2luYWxEYXRlKGdldEFjdGl2YXRvcigpLm5vdyk7XG4gIH07XG5cbiAgZ2xvYmFsLkRhdGUubm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRBY3RpdmF0b3IoKS5ub3c7XG4gIH07XG5cbiAgZ2xvYmFsLkRhdGUucGFyc2UgPSBPcmlnaW5hbERhdGUucGFyc2UuYmluZChPcmlnaW5hbERhdGUpO1xuICBnbG9iYWwuRGF0ZS5VVEMgPSBPcmlnaW5hbERhdGUuVVRDLmJpbmQoT3JpZ2luYWxEYXRlKTtcblxuICBnbG9iYWwuRGF0ZS5wcm90b3R5cGUgPSBPcmlnaW5hbERhdGUucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gbXMgc2xlZXAgZHVyYXRpb24gLSAgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gSWYgZ2l2ZW4gYSBuZWdhdGl2ZSBudW1iZXIsIHZhbHVlIHdpbGwgYmUgc2V0IHRvIDEuXG4gICAqL1xuICBnbG9iYWwuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChjYjogKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIG1zOiBudW1iZXIsIC4uLmFyZ3M6IGFueVtdKTogbnVtYmVyIHtcbiAgICBjb25zdCBhY3RpdmF0b3IgPSBnZXRBY3RpdmF0b3IoKTtcbiAgICBtcyA9IE1hdGgubWF4KDEsIG1zKTtcbiAgICBjb25zdCBzZXEgPSBhY3RpdmF0b3IubmV4dFNlcXMudGltZXIrKztcbiAgICAvLyBDcmVhdGUgYSBQcm9taXNlIGZvciBBc3luY0xvY2FsU3RvcmFnZSB0byBiZSBhYmxlIHRvIHRyYWNrIHRoaXMgY29tcGxldGlvbiB1c2luZyBwcm9taXNlIGhvb2tzLlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGFjdGl2YXRvci5jb21wbGV0aW9ucy50aW1lci5zZXQoc2VxLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICAgIHN0YXJ0VGltZXI6IHtcbiAgICAgICAgICBzZXEsXG4gICAgICAgICAgc3RhcnRUb0ZpcmVUaW1lb3V0OiBtc1RvVHMobXMpLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSkudGhlbihcbiAgICAgICgpID0+IGNiKC4uLmFyZ3MpLFxuICAgICAgKCkgPT4gdW5kZWZpbmVkIC8qIGlnbm9yZSBjYW5jZWxsYXRpb24gKi9cbiAgICApO1xuICAgIHJldHVybiBzZXE7XG4gIH07XG5cbiAgZ2xvYmFsLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIChoYW5kbGU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICAgIGFjdGl2YXRvci5uZXh0U2Vxcy50aW1lcisrO1xuICAgIGFjdGl2YXRvci5jb21wbGV0aW9ucy50aW1lci5kZWxldGUoaGFuZGxlKTtcbiAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgICAgY2FuY2VsVGltZXI6IHtcbiAgICAgICAgc2VxOiBoYW5kbGUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xuXG4gIC8vIGFjdGl2YXRvci5yYW5kb20gaXMgbXV0YWJsZSwgZG9uJ3QgaGFyZGNvZGUgaXRzIHJlZmVyZW5jZVxuICBNYXRoLnJhbmRvbSA9ICgpID0+IGdldEFjdGl2YXRvcigpLnJhbmRvbSgpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGlzb2xhdGUgcnVudGltZS5cbiAqXG4gKiBTZXRzIHJlcXVpcmVkIGludGVybmFsIHN0YXRlIGFuZCBpbnN0YW50aWF0ZXMgdGhlIHdvcmtmbG93IGFuZCBpbnRlcmNlcHRvcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0UnVudGltZShvcHRpb25zOiBXb3JrZmxvd0NyZWF0ZU9wdGlvbnNJbnRlcm5hbCk6IHZvaWQge1xuICBjb25zdCBpbmZvOiBXb3JrZmxvd0luZm8gPSBmaXhQcm90b3R5cGVzKG9wdGlvbnMuaW5mbyk7XG4gIGluZm8udW5zYWZlLm5vdyA9IE9yaWdpbmFsRGF0ZS5ub3c7XG4gIGNvbnN0IGFjdGl2YXRvciA9IG5ldyBBY3RpdmF0b3IoeyAuLi5vcHRpb25zLCBpbmZvIH0pO1xuICAvLyBUaGVyZSdzIG9uIGFjdGl2YXRvciBwZXIgd29ya2Zsb3cgaW5zdGFuY2UsIHNldCBpdCBnbG9iYWxseSBvbiB0aGUgY29udGV4dC5cbiAgLy8gV2UgZG8gdGhpcyBiZWZvcmUgaW1wb3J0aW5nIGFueSB1c2VyIGNvZGUgc28gdXNlciBjb2RlIGNhbiBzdGF0aWNhbGx5IHJlZmVyZW5jZSBAdGVtcG9yYWxpby93b3JrZmxvdyBmdW5jdGlvbnNcbiAgLy8gYXMgd2VsbCBhcyBEYXRlIGFuZCBNYXRoLnJhbmRvbS5cbiAgc2V0QWN0aXZhdG9yVW50eXBlZChhY3RpdmF0b3IpO1xuXG4gIC8vIHdlYnBhY2sgYWxpYXMgdG8gcGF5bG9hZENvbnZlcnRlclBhdGhcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgY29uc3QgY3VzdG9tUGF5bG9hZENvbnZlcnRlciA9IHJlcXVpcmUoJ19fdGVtcG9yYWxfY3VzdG9tX3BheWxvYWRfY29udmVydGVyJykucGF5bG9hZENvbnZlcnRlcjtcbiAgLy8gVGhlIGBwYXlsb2FkQ29udmVydGVyYCBleHBvcnQgaXMgdmFsaWRhdGVkIGluIHRoZSBXb3JrZXJcbiAgaWYgKGN1c3RvbVBheWxvYWRDb252ZXJ0ZXIgIT0gbnVsbCkge1xuICAgIGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyID0gY3VzdG9tUGF5bG9hZENvbnZlcnRlcjtcbiAgfVxuICAvLyB3ZWJwYWNrIGFsaWFzIHRvIGZhaWx1cmVDb252ZXJ0ZXJQYXRoXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gIGNvbnN0IGN1c3RvbUZhaWx1cmVDb252ZXJ0ZXIgPSByZXF1aXJlKCdfX3RlbXBvcmFsX2N1c3RvbV9mYWlsdXJlX2NvbnZlcnRlcicpLmZhaWx1cmVDb252ZXJ0ZXI7XG4gIC8vIFRoZSBgZmFpbHVyZUNvbnZlcnRlcmAgZXhwb3J0IGlzIHZhbGlkYXRlZCBpbiB0aGUgV29ya2VyXG4gIGlmIChjdXN0b21GYWlsdXJlQ29udmVydGVyICE9IG51bGwpIHtcbiAgICBhY3RpdmF0b3IuZmFpbHVyZUNvbnZlcnRlciA9IGN1c3RvbUZhaWx1cmVDb252ZXJ0ZXI7XG4gIH1cblxuICBjb25zdCB7IGltcG9ydFdvcmtmbG93cywgaW1wb3J0SW50ZXJjZXB0b3JzIH0gPSBnbG9iYWwuX19URU1QT1JBTF9fO1xuICBpZiAoaW1wb3J0V29ya2Zsb3dzID09PSB1bmRlZmluZWQgfHwgaW1wb3J0SW50ZXJjZXB0b3JzID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXJyb3IoJ1dvcmtmbG93IGJ1bmRsZSBkaWQgbm90IHJlZ2lzdGVyIGltcG9ydCBob29rcycpO1xuICB9XG5cbiAgY29uc3QgaW50ZXJjZXB0b3JzID0gaW1wb3J0SW50ZXJjZXB0b3JzKCk7XG4gIGZvciAoY29uc3QgbW9kIG9mIGludGVyY2VwdG9ycykge1xuICAgIGNvbnN0IGZhY3Rvcnk6IFdvcmtmbG93SW50ZXJjZXB0b3JzRmFjdG9yeSA9IG1vZC5pbnRlcmNlcHRvcnM7XG4gICAgaWYgKGZhY3RvcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIHdvcmtmbG93cyBpbnRlcmNlcHRvcnM6IGV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCBnb3Q6ICcke2ZhY3Rvcnl9J2ApO1xuICAgICAgfVxuICAgICAgY29uc3QgaW50ZXJjZXB0b3JzID0gZmFjdG9yeSgpO1xuICAgICAgYWN0aXZhdG9yLmludGVyY2VwdG9ycy5pbmJvdW5kLnB1c2goLi4uKGludGVyY2VwdG9ycy5pbmJvdW5kID8/IFtdKSk7XG4gICAgICBhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLm91dGJvdW5kLnB1c2goLi4uKGludGVyY2VwdG9ycy5vdXRib3VuZCA/PyBbXSkpO1xuICAgICAgYWN0aXZhdG9yLmludGVyY2VwdG9ycy5pbnRlcm5hbHMucHVzaCguLi4oaW50ZXJjZXB0b3JzLmludGVybmFscyA/PyBbXSkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1vZCA9IGltcG9ydFdvcmtmbG93cygpO1xuICBjb25zdCB3b3JrZmxvd0ZuID0gbW9kW2luZm8ud29ya2Zsb3dUeXBlXTtcbiAgY29uc3QgZGVmYXVsdFdvcmtmbG93Rm4gPSBtb2RbJ2RlZmF1bHQnXTtcblxuICBpZiAodHlwZW9mIHdvcmtmbG93Rm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICBhY3RpdmF0b3Iud29ya2Zsb3cgPSB3b3JrZmxvd0ZuO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZhdWx0V29ya2Zsb3dGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFjdGl2YXRvci53b3JrZmxvdyA9IGRlZmF1bHRXb3JrZmxvd0ZuO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRldGFpbHMgPVxuICAgICAgd29ya2Zsb3dGbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gJ25vIHN1Y2ggZnVuY3Rpb24gaXMgZXhwb3J0ZWQgYnkgdGhlIHdvcmtmbG93IGJ1bmRsZSdcbiAgICAgICAgOiBgZXhwZWN0ZWQgYSBmdW5jdGlvbiwgYnV0IGdvdDogJyR7dHlwZW9mIHdvcmtmbG93Rm59J2A7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGluaXRpYWxpemUgd29ya2Zsb3cgb2YgdHlwZSAnJHtpbmZvLndvcmtmbG93VHlwZX0nOiAke2RldGFpbHN9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBPYmplY3RzIHRyYW5zZmVyZWQgdG8gdGhlIFZNIGZyb20gb3V0c2lkZSBoYXZlIHByb3RvdHlwZXMgYmVsb25naW5nIHRvIHRoZVxuICogb3V0ZXIgY29udGV4dCwgd2hpY2ggbWVhbnMgdGhhdCBpbnN0YW5jZW9mIHdvbid0IHdvcmsgaW5zaWRlIHRoZSBWTS4gVGhpc1xuICogZnVuY3Rpb24gcmVjdXJzaXZlbHkgd2Fsa3Mgb3ZlciB0aGUgY29udGVudCBvZiBhbiBvYmplY3QsIGFuZCByZWNyZWF0ZSBzb21lXG4gKiBvZiB0aGVzZSBvYmplY3RzIChub3RhYmx5IEFycmF5LCBEYXRlIGFuZCBPYmplY3RzKS5cbiAqL1xuZnVuY3Rpb24gZml4UHJvdG90eXBlczxYPihvYmo6IFgpOiBYIHtcbiAgaWYgKG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKT8uY29uc3RydWN0b3I/Lm5hbWUpIHtcbiAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oKG9iaiBhcyBBcnJheTx1bmtub3duPikubWFwKGZpeFByb3RvdHlwZXMpKSBhcyBYO1xuICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmogYXMgdW5rbm93biBhcyBEYXRlKSBhcyBYO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvYmopLm1hcCgoW2ssIHZdKTogW3N0cmluZywgYW55XSA9PiBbaywgZml4UHJvdG90eXBlcyh2KV0pKSBhcyBYO1xuICAgIH1cbiAgfSBlbHNlIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUnVuIGEgY2h1bmsgb2YgYWN0aXZhdGlvbiBqb2JzXG4gKiBAcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGpvYiB3YXMgcHJvY2Vzc2VkIG9yIGlnbm9yZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFjdGl2YXRlKGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5Xb3JrZmxvd0FjdGl2YXRpb24sIGJhdGNoSW5kZXg6IG51bWJlcik6IHZvaWQge1xuICBjb25zdCBhY3RpdmF0b3IgPSBnZXRBY3RpdmF0b3IoKTtcbiAgY29uc3QgaW50ZXJjZXB0ID0gY29tcG9zZUludGVyY2VwdG9ycyhhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLmludGVybmFscywgJ2FjdGl2YXRlJywgKHsgYWN0aXZhdGlvbiwgYmF0Y2hJbmRleCB9KSA9PiB7XG4gICAgaWYgKGJhdGNoSW5kZXggPT09IDApIHtcbiAgICAgIGlmICghYWN0aXZhdGlvbi5qb2JzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBhY3RpdmF0aW9uIHdpdGggbm8gam9icycpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGl2YXRpb24udGltZXN0YW1wICE9IG51bGwpIHtcbiAgICAgICAgLy8gdGltZXN0YW1wIHdpbGwgbm90IGJlIHVwZGF0ZWQgZm9yIGFjdGl2YXRpb24gdGhhdCBjb250YWluIG9ubHkgcXVlcmllc1xuICAgICAgICBhY3RpdmF0b3Iubm93ID0gdHNUb01zKGFjdGl2YXRpb24udGltZXN0YW1wKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIFJ1c3QgQ29yZSBlbnN1cmVzIHRoYXQgdGhlc2UgYWN0aXZhdGlvbiBmaWVsZHMgYXJlIG5vdCBudWxsXG4gICAgICBhY3RpdmF0b3IuaW5mby51bnNhZmUuaXNSZXBsYXlpbmcgPSBhY3RpdmF0aW9uLmlzUmVwbGF5aW5nID8/IGZhbHNlO1xuICAgICAgYWN0aXZhdG9yLmluZm8uaGlzdG9yeUxlbmd0aCA9IGFjdGl2YXRpb24uaGlzdG9yeUxlbmd0aCBhcyBudW1iZXI7XG4gICAgICAvLyBFeGFjdCB0cnVuY2F0aW9uIGZvciBtdWx0aS1wZXRhYnl0ZSBoaXN0b3JpZXNcbiAgICAgIC8vIGhpc3RvcnlTaXplID09PSAwIG1lYW5zIFdGVCB3YXMgZ2VuZXJhdGVkIGJ5IHByZS0xLjIwLjAgc2VydmVyLCBhbmQgdGhlIGhpc3Rvcnkgc2l6ZSBpcyB1bmtub3duXG4gICAgICBhY3RpdmF0b3IuaW5mby5oaXN0b3J5U2l6ZSA9IGFjdGl2YXRpb24uaGlzdG9yeVNpemVCeXRlcz8udG9OdW1iZXIoKSB8fCAwO1xuICAgICAgYWN0aXZhdG9yLmluZm8uY29udGludWVBc05ld1N1Z2dlc3RlZCA9IGFjdGl2YXRpb24uY29udGludWVBc05ld1N1Z2dlc3RlZCA/PyBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYXN0IGZyb20gdGhlIGludGVyZmFjZSB0byB0aGUgY2xhc3Mgd2hpY2ggaGFzIHRoZSBgdmFyaWFudGAgYXR0cmlidXRlLlxuICAgIC8vIFRoaXMgaXMgc2FmZSBiZWNhdXNlIHdlIGtub3cgdGhhdCBhY3RpdmF0aW9uIGlzIGEgcHJvdG8gY2xhc3MuXG4gICAgY29uc3Qgam9icyA9IGFjdGl2YXRpb24uam9icyBhcyBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uV29ya2Zsb3dBY3RpdmF0aW9uSm9iW107XG5cbiAgICBmb3IgKGNvbnN0IGpvYiBvZiBqb2JzKSB7XG4gICAgICBpZiAoam9iLnZhcmlhbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBqb2IudmFyaWFudCB0byBiZSBkZWZpbmVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhcmlhbnQgPSBqb2Jbam9iLnZhcmlhbnRdO1xuICAgICAgaWYgKCF2YXJpYW50KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGpvYi4ke2pvYi52YXJpYW50fSB0byBiZSBzZXRgKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBvbmx5IGpvYiB0aGF0IGNhbiBiZSBleGVjdXRlZCBvbiBhIGNvbXBsZXRlZCB3b3JrZmxvdyBpcyBhIHF1ZXJ5LlxuICAgICAgLy8gV2UgbWlnaHQgZ2V0IG90aGVyIGpvYnMgYWZ0ZXIgY29tcGxldGlvbiBmb3IgaW5zdGFuY2Ugd2hlbiBhIHNpbmdsZVxuICAgICAgLy8gYWN0aXZhdGlvbiBjb250YWlucyBtdWx0aXBsZSBqb2JzIGFuZCB0aGUgZmlyc3Qgb25lIGNvbXBsZXRlcyB0aGUgd29ya2Zsb3cuXG4gICAgICBpZiAoYWN0aXZhdG9yLmNvbXBsZXRlZCAmJiBqb2IudmFyaWFudCAhPT0gJ3F1ZXJ5V29ya2Zsb3cnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFjdGl2YXRvcltqb2IudmFyaWFudF0odmFyaWFudCBhcyBhbnkgLyogVFMgY2FuJ3QgaW5mZXIgdGhpcyB0eXBlICovKTtcbiAgICAgIGlmIChzaG91bGRVbmJsb2NrQ29uZGl0aW9ucyhqb2IpKSB7XG4gICAgICAgIHRyeVVuYmxvY2tDb25kaXRpb25zKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaW50ZXJjZXB0KHtcbiAgICBhY3RpdmF0aW9uLFxuICAgIGJhdGNoSW5kZXgsXG4gIH0pO1xufVxuXG4vKipcbiAqIENvbmNsdWRlIGEgc2luZ2xlIGFjdGl2YXRpb24uXG4gKiBTaG91bGQgYmUgY2FsbGVkIGFmdGVyIHByb2Nlc3NpbmcgYWxsIGFjdGl2YXRpb24gam9icyBhbmQgcXVldWVkIG1pY3JvdGFza3MuXG4gKlxuICogQWN0aXZhdGlvbiBmYWlsdXJlcyBhcmUgaGFuZGxlZCBpbiB0aGUgbWFpbiBOb2RlLmpzIGlzb2xhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jbHVkZUFjdGl2YXRpb24oKTogY29yZXNkay53b3JrZmxvd19jb21wbGV0aW9uLklXb3JrZmxvd0FjdGl2YXRpb25Db21wbGV0aW9uIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gZ2V0QWN0aXZhdG9yKCk7XG4gIGNvbnN0IGludGVyY2VwdCA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoYWN0aXZhdG9yLmludGVyY2VwdG9ycy5pbnRlcm5hbHMsICdjb25jbHVkZUFjdGl2YXRpb24nLCAoaW5wdXQpID0+IGlucHV0KTtcbiAgY29uc3QgeyBpbmZvIH0gPSBhY3RpdmF0b3I7XG4gIGNvbnN0IHsgY29tbWFuZHMgfSA9IGludGVyY2VwdCh7IGNvbW1hbmRzOiBhY3RpdmF0b3IuZ2V0QW5kUmVzZXRDb21tYW5kcygpIH0pO1xuICByZXR1cm4ge1xuICAgIHJ1bklkOiBpbmZvLnJ1bklkLFxuICAgIHN1Y2Nlc3NmdWw6IHsgY29tbWFuZHMgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuZFJlc2V0U2lua0NhbGxzKCk6IFNpbmtDYWxsW10ge1xuICByZXR1cm4gZ2V0QWN0aXZhdG9yKCkuZ2V0QW5kUmVzZXRTaW5rQ2FsbHMoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRocm91Z2ggYWxsIGJsb2NrZWQgY29uZGl0aW9ucywgZXZhbHVhdGUgYW5kIHVuYmxvY2sgaWYgcG9zc2libGUuXG4gKlxuICogQHJldHVybnMgbnVtYmVyIG9mIHVuYmxvY2tlZCBjb25kaXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJ5VW5ibG9ja0NvbmRpdGlvbnMoKTogbnVtYmVyIHtcbiAgbGV0IG51bVVuYmxvY2tlZCA9IDA7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCBwcmV2VW5ibG9ja2VkID0gbnVtVW5ibG9ja2VkO1xuICAgIGZvciAoY29uc3QgW3NlcSwgY29uZF0gb2YgZ2V0QWN0aXZhdG9yKCkuYmxvY2tlZENvbmRpdGlvbnMuZW50cmllcygpKSB7XG4gICAgICBpZiAoY29uZC5mbigpKSB7XG4gICAgICAgIGNvbmQucmVzb2x2ZSgpO1xuICAgICAgICBudW1VbmJsb2NrZWQrKztcbiAgICAgICAgLy8gSXQgaXMgc2FmZSB0byBkZWxldGUgZWxlbWVudHMgZHVyaW5nIG1hcCBpdGVyYXRpb25cbiAgICAgICAgZ2V0QWN0aXZhdG9yKCkuYmxvY2tlZENvbmRpdGlvbnMuZGVsZXRlKHNlcSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2VW5ibG9ja2VkID09PSBudW1VbmJsb2NrZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtVW5ibG9ja2VkO1xufVxuXG4vKipcbiAqIFByZWRpY2F0ZSB1c2VkIHRvIHByZXZlbnQgdHJpZ2dlcmluZyBjb25kaXRpb25zIGZvciBub24tcXVlcnkgYW5kIG5vbi1wYXRjaCBqb2JzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkVW5ibG9ja0NvbmRpdGlvbnMoam9iOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVdvcmtmbG93QWN0aXZhdGlvbkpvYik6IGJvb2xlYW4ge1xuICByZXR1cm4gIWpvYi5xdWVyeVdvcmtmbG93ICYmICFqb2Iubm90aWZ5SGFzUGF0Y2g7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlKCk6IHZvaWQge1xuICBjb25zdCBkaXNwb3NlID0gY29tcG9zZUludGVyY2VwdG9ycyhnZXRBY3RpdmF0b3IoKS5pbnRlcmNlcHRvcnMuaW50ZXJuYWxzLCAnZGlzcG9zZScsIGFzeW5jICgpID0+IHtcbiAgICBkaXNhYmxlU3RvcmFnZSgpO1xuICB9KTtcbiAgZGlzcG9zZSh7fSk7XG59XG4iLCJpbXBvcnQge1xuICBBY3Rpdml0eUZ1bmN0aW9uLFxuICBBY3Rpdml0eU9wdGlvbnMsXG4gIGNvbXBpbGVSZXRyeVBvbGljeSxcbiAgZXh0cmFjdFdvcmtmbG93VHlwZSxcbiAgSWxsZWdhbFN0YXRlRXJyb3IsXG4gIExvY2FsQWN0aXZpdHlPcHRpb25zLFxuICBtYXBUb1BheWxvYWRzLFxuICBRdWVyeURlZmluaXRpb24sXG4gIHNlYXJjaEF0dHJpYnV0ZVBheWxvYWRDb252ZXJ0ZXIsXG4gIFNlYXJjaEF0dHJpYnV0ZXMsXG4gIFNpZ25hbERlZmluaXRpb24sXG4gIHRvUGF5bG9hZHMsXG4gIFVudHlwZWRBY3Rpdml0aWVzLFxuICBXaXRoV29ya2Zsb3dBcmdzLFxuICBXb3JrZmxvdyxcbiAgV29ya2Zsb3dSZXN1bHRUeXBlLFxuICBXb3JrZmxvd1JldHVyblR5cGUsXG59IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbic7XG5pbXBvcnQgeyB2ZXJzaW9uaW5nSW50ZW50VG9Qcm90byB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvdmVyc2lvbmluZy1pbnRlbnQtZW51bSc7XG5pbXBvcnQgeyBEdXJhdGlvbiwgbXNPcHRpb25hbFRvVHMsIG1zVG9OdW1iZXIsIG1zVG9UcywgdHNUb01zIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi90aW1lJztcbmltcG9ydCB7IGNvbXBvc2VJbnRlcmNlcHRvcnMgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL2ludGVyY2VwdG9ycyc7XG5pbXBvcnQgeyBDYW5jZWxsYXRpb25TY29wZSwgcmVnaXN0ZXJTbGVlcEltcGxlbWVudGF0aW9uIH0gZnJvbSAnLi9jYW5jZWxsYXRpb24tc2NvcGUnO1xuaW1wb3J0IHtcbiAgQWN0aXZpdHlJbnB1dCxcbiAgTG9jYWxBY3Rpdml0eUlucHV0LFxuICBTaWduYWxXb3JrZmxvd0lucHV0LFxuICBTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25JbnB1dCxcbiAgVGltZXJJbnB1dCxcbn0gZnJvbSAnLi9pbnRlcmNlcHRvcnMnO1xuaW1wb3J0IHtcbiAgQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUsXG4gIENoaWxkV29ya2Zsb3dPcHRpb25zLFxuICBDaGlsZFdvcmtmbG93T3B0aW9uc1dpdGhEZWZhdWx0cyxcbiAgQ29udGludWVBc05ldyxcbiAgQ29udGludWVBc05ld09wdGlvbnMsXG4gIERlZmF1bHRTaWduYWxIYW5kbGVyLFxuICBFbmhhbmNlZFN0YWNrVHJhY2UsXG4gIEhhbmRsZXIsXG4gIFdvcmtmbG93SW5mbyxcbn0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IEFjdGl2YXRvciwgTG9jYWxBY3Rpdml0eURvQmFja29mZiwgZ2V0QWN0aXZhdG9yLCBtYXliZUdldEFjdGl2YXRvciB9IGZyb20gJy4vaW50ZXJuYWxzJztcbmltcG9ydCB7IExvZ2dlclNpbmtzLCBTaW5rcyB9IGZyb20gJy4vc2lua3MnO1xuaW1wb3J0IHsgdW50cmFja1Byb21pc2UgfSBmcm9tICcuL3N0YWNrLWhlbHBlcnMnO1xuaW1wb3J0IHsgQ2hpbGRXb3JrZmxvd0hhbmRsZSwgRXh0ZXJuYWxXb3JrZmxvd0hhbmRsZSB9IGZyb20gJy4vd29ya2Zsb3ctaGFuZGxlJztcblxuLy8gQXZvaWQgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG5yZWdpc3RlclNsZWVwSW1wbGVtZW50YXRpb24oc2xlZXApO1xuXG4vKipcbiAqIEFkZHMgZGVmYXVsdCB2YWx1ZXMgdG8gYHdvcmtmbG93SWRgIGFuZCBgd29ya2Zsb3dJZFJldXNlUG9saWN5YCB0byBnaXZlbiB3b3JrZmxvdyBvcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRGVmYXVsdFdvcmtmbG93T3B0aW9uczxUIGV4dGVuZHMgV29ya2Zsb3c+KFxuICBvcHRzOiBXaXRoV29ya2Zsb3dBcmdzPFQsIENoaWxkV29ya2Zsb3dPcHRpb25zPlxuKTogQ2hpbGRXb3JrZmxvd09wdGlvbnNXaXRoRGVmYXVsdHMge1xuICBjb25zdCB7IGFyZ3MsIHdvcmtmbG93SWQsIC4uLnJlc3QgfSA9IG9wdHM7XG4gIHJldHVybiB7XG4gICAgd29ya2Zsb3dJZDogd29ya2Zsb3dJZCA/PyB1dWlkNCgpLFxuICAgIGFyZ3M6IGFyZ3MgPz8gW10sXG4gICAgY2FuY2VsbGF0aW9uVHlwZTogQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUuV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVELFxuICAgIC4uLnJlc3QsXG4gIH07XG59XG5cbi8qKlxuICogUHVzaCBhIHN0YXJ0VGltZXIgY29tbWFuZCBpbnRvIHN0YXRlIGFjY3VtdWxhdG9yIGFuZCByZWdpc3RlciBjb21wbGV0aW9uXG4gKi9cbmZ1bmN0aW9uIHRpbWVyTmV4dEhhbmRsZXIoaW5wdXQ6IFRpbWVySW5wdXQpIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gZ2V0QWN0aXZhdG9yKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBDYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCk7XG4gICAgaWYgKHNjb3BlLmNvbnNpZGVyZWRDYW5jZWxsZWQpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaChyZWplY3QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNjb3BlLmNhbmNlbGxhYmxlKSB7XG4gICAgICB1bnRyYWNrUHJvbWlzZShcbiAgICAgICAgc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIWFjdGl2YXRvci5jb21wbGV0aW9ucy50aW1lci5kZWxldGUoaW5wdXQuc2VxKSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBBbHJlYWR5IHJlc29sdmVkIG9yIG5ldmVyIHNjaGVkdWxlZFxuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgY2FuY2VsVGltZXI6IHtcbiAgICAgICAgICAgICAgc2VxOiBpbnB1dC5zZXEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHN0YXJ0VGltZXI6IHtcbiAgICAgICAgc2VxOiBpbnB1dC5zZXEsXG4gICAgICAgIHN0YXJ0VG9GaXJlVGltZW91dDogbXNUb1RzKGlucHV0LmR1cmF0aW9uTXMpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMudGltZXIuc2V0KGlucHV0LnNlcSwge1xuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdCxcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzIHNsZWVwLlxuICpcbiAqIFNjaGVkdWxlcyBhIHRpbWVyIG9uIHRoZSBUZW1wb3JhbCBzZXJ2aWNlLlxuICpcbiAqIEBwYXJhbSBtcyBzbGVlcCBkdXJhdGlvbiAtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ30uXG4gKiBJZiBnaXZlbiBhIG5lZ2F0aXZlIG51bWJlciBvciAwLCB2YWx1ZSB3aWxsIGJlIHNldCB0byAxLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xlZXAobXM6IER1cmF0aW9uKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KCdXb3JrZmxvdy5zbGVlcCguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbicpO1xuICBjb25zdCBzZXEgPSBhY3RpdmF0b3IubmV4dFNlcXMudGltZXIrKztcblxuICBjb25zdCBkdXJhdGlvbk1zID0gTWF0aC5tYXgoMSwgbXNUb051bWJlcihtcykpO1xuXG4gIGNvbnN0IGV4ZWN1dGUgPSBjb21wb3NlSW50ZXJjZXB0b3JzKGFjdGl2YXRvci5pbnRlcmNlcHRvcnMub3V0Ym91bmQsICdzdGFydFRpbWVyJywgdGltZXJOZXh0SGFuZGxlcik7XG5cbiAgcmV0dXJuIGV4ZWN1dGUoe1xuICAgIGR1cmF0aW9uTXMsXG4gICAgc2VxLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBY3Rpdml0eU9wdGlvbnMob3B0aW9uczogQWN0aXZpdHlPcHRpb25zKTogdm9pZCB7XG4gIGlmIChvcHRpb25zLnNjaGVkdWxlVG9DbG9zZVRpbWVvdXQgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnN0YXJ0VG9DbG9zZVRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVpcmVkIGVpdGhlciBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0IG9yIHN0YXJ0VG9DbG9zZVRpbWVvdXQnKTtcbiAgfVxufVxuXG4vLyBVc2Ugc2FtZSB2YWxpZGF0aW9uIHdlIHVzZSBmb3Igbm9ybWFsIGFjdGl2aXRpZXNcbmNvbnN0IHZhbGlkYXRlTG9jYWxBY3Rpdml0eU9wdGlvbnMgPSB2YWxpZGF0ZUFjdGl2aXR5T3B0aW9ucztcblxuLyoqXG4gKiBQdXNoIGEgc2NoZWR1bGVBY3Rpdml0eSBjb21tYW5kIGludG8gYWN0aXZhdG9yIGFjY3VtdWxhdG9yIGFuZCByZWdpc3RlciBjb21wbGV0aW9uXG4gKi9cbmZ1bmN0aW9uIHNjaGVkdWxlQWN0aXZpdHlOZXh0SGFuZGxlcih7IG9wdGlvbnMsIGFyZ3MsIGhlYWRlcnMsIHNlcSwgYWN0aXZpdHlUeXBlIH06IEFjdGl2aXR5SW5wdXQpOiBQcm9taXNlPHVua25vd24+IHtcbiAgY29uc3QgYWN0aXZhdG9yID0gZ2V0QWN0aXZhdG9yKCk7XG4gIHZhbGlkYXRlQWN0aXZpdHlPcHRpb25zKG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHNjb3BlID0gQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpO1xuICAgIGlmIChzY29wZS5jb25zaWRlcmVkQ2FuY2VsbGVkKSB7XG4gICAgICB1bnRyYWNrUHJvbWlzZShzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2gocmVqZWN0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzY29wZS5jYW5jZWxsYWJsZSkge1xuICAgICAgdW50cmFja1Byb21pc2UoXG4gICAgICAgIHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFhY3RpdmF0b3IuY29tcGxldGlvbnMuYWN0aXZpdHkuaGFzKHNlcSkpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gQWxyZWFkeSByZXNvbHZlZCBvciBuZXZlciBzY2hlZHVsZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgICAgICAgIHJlcXVlc3RDYW5jZWxBY3Rpdml0eToge1xuICAgICAgICAgICAgICBzZXEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHNjaGVkdWxlQWN0aXZpdHk6IHtcbiAgICAgICAgc2VxLFxuICAgICAgICBhY3Rpdml0eUlkOiBvcHRpb25zLmFjdGl2aXR5SWQgPz8gYCR7c2VxfWAsXG4gICAgICAgIGFjdGl2aXR5VHlwZSxcbiAgICAgICAgYXJndW1lbnRzOiB0b1BheWxvYWRzKGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyLCAuLi5hcmdzKSxcbiAgICAgICAgcmV0cnlQb2xpY3k6IG9wdGlvbnMucmV0cnkgPyBjb21waWxlUmV0cnlQb2xpY3kob3B0aW9ucy5yZXRyeSkgOiB1bmRlZmluZWQsXG4gICAgICAgIHRhc2tRdWV1ZTogb3B0aW9ucy50YXNrUXVldWUgfHwgYWN0aXZhdG9yLmluZm8/LnRhc2tRdWV1ZSxcbiAgICAgICAgaGVhcnRiZWF0VGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy5oZWFydGJlYXRUaW1lb3V0KSxcbiAgICAgICAgc2NoZWR1bGVUb0Nsb3NlVGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy5zY2hlZHVsZVRvQ2xvc2VUaW1lb3V0KSxcbiAgICAgICAgc3RhcnRUb0Nsb3NlVGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy5zdGFydFRvQ2xvc2VUaW1lb3V0KSxcbiAgICAgICAgc2NoZWR1bGVUb1N0YXJ0VGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy5zY2hlZHVsZVRvU3RhcnRUaW1lb3V0KSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgY2FuY2VsbGF0aW9uVHlwZTogb3B0aW9ucy5jYW5jZWxsYXRpb25UeXBlLFxuICAgICAgICBkb05vdEVhZ2VybHlFeGVjdXRlOiAhKG9wdGlvbnMuYWxsb3dFYWdlckRpc3BhdGNoID8/IHRydWUpLFxuICAgICAgICB2ZXJzaW9uaW5nSW50ZW50OiB2ZXJzaW9uaW5nSW50ZW50VG9Qcm90byhvcHRpb25zLnZlcnNpb25pbmdJbnRlbnQpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMuYWN0aXZpdHkuc2V0KHNlcSwge1xuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdCxcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUHVzaCBhIHNjaGVkdWxlQWN0aXZpdHkgY29tbWFuZCBpbnRvIHN0YXRlIGFjY3VtdWxhdG9yIGFuZCByZWdpc3RlciBjb21wbGV0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNjaGVkdWxlTG9jYWxBY3Rpdml0eU5leHRIYW5kbGVyKHtcbiAgb3B0aW9ucyxcbiAgYXJncyxcbiAgaGVhZGVycyxcbiAgc2VxLFxuICBhY3Rpdml0eVR5cGUsXG4gIGF0dGVtcHQsXG4gIG9yaWdpbmFsU2NoZWR1bGVUaW1lLFxufTogTG9jYWxBY3Rpdml0eUlucHV0KTogUHJvbWlzZTx1bmtub3duPiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICAvLyBFYWdlcmx5IGZhaWwgdGhlIGxvY2FsIGFjdGl2aXR5ICh3aGljaCB3aWxsIGluIHR1cm4gZmFpbCB0aGUgd29ya2Zsb3cgdGFzay5cbiAgLy8gRG8gbm90IGZhaWwgb24gcmVwbGF5IHdoZXJlIHRoZSBsb2NhbCBhY3Rpdml0aWVzIG1heSBub3QgYmUgcmVnaXN0ZXJlZCBvbiB0aGUgcmVwbGF5IHdvcmtlci5cbiAgaWYgKCF3b3JrZmxvd0luZm8oKS51bnNhZmUuaXNSZXBsYXlpbmcgJiYgIWFjdGl2YXRvci5yZWdpc3RlcmVkQWN0aXZpdHlOYW1lcy5oYXMoYWN0aXZpdHlUeXBlKSkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihgTG9jYWwgYWN0aXZpdHkgb2YgdHlwZSAnJHthY3Rpdml0eVR5cGV9JyBub3QgcmVnaXN0ZXJlZCBvbiB3b3JrZXJgKTtcbiAgfVxuICB2YWxpZGF0ZUxvY2FsQWN0aXZpdHlPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBDYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCk7XG4gICAgaWYgKHNjb3BlLmNvbnNpZGVyZWRDYW5jZWxsZWQpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaChyZWplY3QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNjb3BlLmNhbmNlbGxhYmxlKSB7XG4gICAgICB1bnRyYWNrUHJvbWlzZShcbiAgICAgICAgc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICBpZiAoIWFjdGl2YXRvci5jb21wbGV0aW9ucy5hY3Rpdml0eS5oYXMoc2VxKSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBBbHJlYWR5IHJlc29sdmVkIG9yIG5ldmVyIHNjaGVkdWxlZFxuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgcmVxdWVzdENhbmNlbExvY2FsQWN0aXZpdHk6IHtcbiAgICAgICAgICAgICAgc2VxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICBzY2hlZHVsZUxvY2FsQWN0aXZpdHk6IHtcbiAgICAgICAgc2VxLFxuICAgICAgICBhdHRlbXB0LFxuICAgICAgICBvcmlnaW5hbFNjaGVkdWxlVGltZSxcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBub3QgZXhwb3NpbmcgYWN0aXZpdHlJZCBhcyBhbiBvcHRpb25cbiAgICAgICAgYWN0aXZpdHlJZDogYCR7c2VxfWAsXG4gICAgICAgIGFjdGl2aXR5VHlwZSxcbiAgICAgICAgYXJndW1lbnRzOiB0b1BheWxvYWRzKGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyLCAuLi5hcmdzKSxcbiAgICAgICAgcmV0cnlQb2xpY3k6IG9wdGlvbnMucmV0cnkgPyBjb21waWxlUmV0cnlQb2xpY3kob3B0aW9ucy5yZXRyeSkgOiB1bmRlZmluZWQsXG4gICAgICAgIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMuc2NoZWR1bGVUb0Nsb3NlVGltZW91dCksXG4gICAgICAgIHN0YXJ0VG9DbG9zZVRpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMuc3RhcnRUb0Nsb3NlVGltZW91dCksXG4gICAgICAgIHNjaGVkdWxlVG9TdGFydFRpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMuc2NoZWR1bGVUb1N0YXJ0VGltZW91dCksXG4gICAgICAgIGxvY2FsUmV0cnlUaHJlc2hvbGQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMubG9jYWxSZXRyeVRocmVzaG9sZCksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGNhbmNlbGxhdGlvblR5cGU6IG9wdGlvbnMuY2FuY2VsbGF0aW9uVHlwZSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgYWN0aXZhdG9yLmNvbXBsZXRpb25zLmFjdGl2aXR5LnNldChzZXEsIHtcbiAgICAgIHJlc29sdmUsXG4gICAgICByZWplY3QsXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlIGFuIGFjdGl2aXR5IGFuZCBydW4gb3V0Ym91bmQgaW50ZXJjZXB0b3JzXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2hlZHVsZUFjdGl2aXR5PFI+KGFjdGl2aXR5VHlwZTogc3RyaW5nLCBhcmdzOiBhbnlbXSwgb3B0aW9uczogQWN0aXZpdHlPcHRpb25zKTogUHJvbWlzZTxSPiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFxuICAgICdXb3JrZmxvdy5zY2hlZHVsZUFjdGl2aXR5KC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uJ1xuICApO1xuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IGVtcHR5IGFjdGl2aXR5IG9wdGlvbnMnKTtcbiAgfVxuICBjb25zdCBzZXEgPSBhY3RpdmF0b3IubmV4dFNlcXMuYWN0aXZpdHkrKztcbiAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZCwgJ3NjaGVkdWxlQWN0aXZpdHknLCBzY2hlZHVsZUFjdGl2aXR5TmV4dEhhbmRsZXIpO1xuXG4gIHJldHVybiBleGVjdXRlKHtcbiAgICBhY3Rpdml0eVR5cGUsXG4gICAgaGVhZGVyczoge30sXG4gICAgb3B0aW9ucyxcbiAgICBhcmdzLFxuICAgIHNlcSxcbiAgfSkgYXMgUHJvbWlzZTxSPjtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZSBhbiBhY3Rpdml0eSBhbmQgcnVuIG91dGJvdW5kIGludGVyY2VwdG9yc1xuICogQGhpZGRlblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2NoZWR1bGVMb2NhbEFjdGl2aXR5PFI+KFxuICBhY3Rpdml0eVR5cGU6IHN0cmluZyxcbiAgYXJnczogYW55W10sXG4gIG9wdGlvbnM6IExvY2FsQWN0aXZpdHlPcHRpb25zXG4pOiBQcm9taXNlPFI+IHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoXG4gICAgJ1dvcmtmbG93LnNjaGVkdWxlTG9jYWxBY3Rpdml0eSguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbidcbiAgKTtcbiAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBlbXB0eSBhY3Rpdml0eSBvcHRpb25zJyk7XG4gIH1cblxuICBsZXQgYXR0ZW1wdCA9IDE7XG4gIGxldCBvcmlnaW5hbFNjaGVkdWxlVGltZSA9IHVuZGVmaW5lZDtcblxuICBmb3IgKDs7KSB7XG4gICAgY29uc3Qgc2VxID0gYWN0aXZhdG9yLm5leHRTZXFzLmFjdGl2aXR5Kys7XG4gICAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoXG4gICAgICBhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLm91dGJvdW5kLFxuICAgICAgJ3NjaGVkdWxlTG9jYWxBY3Rpdml0eScsXG4gICAgICBzY2hlZHVsZUxvY2FsQWN0aXZpdHlOZXh0SGFuZGxlclxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChhd2FpdCBleGVjdXRlKHtcbiAgICAgICAgYWN0aXZpdHlUeXBlLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgYXJncyxcbiAgICAgICAgc2VxLFxuICAgICAgICBhdHRlbXB0LFxuICAgICAgICBvcmlnaW5hbFNjaGVkdWxlVGltZSxcbiAgICAgIH0pKSBhcyBQcm9taXNlPFI+O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIExvY2FsQWN0aXZpdHlEb0JhY2tvZmYpIHtcbiAgICAgICAgYXdhaXQgc2xlZXAodHNUb01zKGVyci5iYWNrb2ZmLmJhY2tvZmZEdXJhdGlvbikpO1xuICAgICAgICBpZiAodHlwZW9mIGVyci5iYWNrb2ZmLmF0dGVtcHQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBiYWNrb2ZmIGF0dGVtcHQgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGF0dGVtcHQgPSBlcnIuYmFja29mZi5hdHRlbXB0O1xuICAgICAgICBvcmlnaW5hbFNjaGVkdWxlVGltZSA9IGVyci5iYWNrb2ZmLm9yaWdpbmFsU2NoZWR1bGVUaW1lID8/IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uTmV4dEhhbmRsZXIoe1xuICBvcHRpb25zLFxuICBoZWFkZXJzLFxuICB3b3JrZmxvd1R5cGUsXG4gIHNlcSxcbn06IFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbklucHV0KTogUHJvbWlzZTxbUHJvbWlzZTxzdHJpbmc+LCBQcm9taXNlPHVua25vd24+XT4ge1xuICBjb25zdCBhY3RpdmF0b3IgPSBnZXRBY3RpdmF0b3IoKTtcbiAgY29uc3Qgd29ya2Zsb3dJZCA9IG9wdGlvbnMud29ya2Zsb3dJZCA/PyB1dWlkNCgpO1xuICBjb25zdCBzdGFydFByb21pc2UgPSBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzY29wZSA9IENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKTtcbiAgICBpZiAoc2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCkge1xuICAgICAgdW50cmFja1Byb21pc2Uoc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKHJlamVjdCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKFxuICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbXBsZXRlID0gIWFjdGl2YXRvci5jb21wbGV0aW9ucy5jaGlsZFdvcmtmbG93Q29tcGxldGUuaGFzKHNlcSk7XG5cbiAgICAgICAgICBpZiAoIWNvbXBsZXRlKSB7XG4gICAgICAgICAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgICBjYW5jZWxDaGlsZFdvcmtmbG93RXhlY3V0aW9uOiB7IGNoaWxkV29ya2Zsb3dTZXE6IHNlcSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdGhpbmcgdG8gY2FuY2VsIG90aGVyd2lzZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbjoge1xuICAgICAgICBzZXEsXG4gICAgICAgIHdvcmtmbG93SWQsXG4gICAgICAgIHdvcmtmbG93VHlwZSxcbiAgICAgICAgaW5wdXQ6IHRvUGF5bG9hZHMoYWN0aXZhdG9yLnBheWxvYWRDb252ZXJ0ZXIsIC4uLm9wdGlvbnMuYXJncyksXG4gICAgICAgIHJldHJ5UG9saWN5OiBvcHRpb25zLnJldHJ5ID8gY29tcGlsZVJldHJ5UG9saWN5KG9wdGlvbnMucmV0cnkpIDogdW5kZWZpbmVkLFxuICAgICAgICB0YXNrUXVldWU6IG9wdGlvbnMudGFza1F1ZXVlIHx8IGFjdGl2YXRvci5pbmZvPy50YXNrUXVldWUsXG4gICAgICAgIHdvcmtmbG93RXhlY3V0aW9uVGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy53b3JrZmxvd0V4ZWN1dGlvblRpbWVvdXQpLFxuICAgICAgICB3b3JrZmxvd1J1blRpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMud29ya2Zsb3dSdW5UaW1lb3V0KSxcbiAgICAgICAgd29ya2Zsb3dUYXNrVGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy53b3JrZmxvd1Rhc2tUaW1lb3V0KSxcbiAgICAgICAgbmFtZXNwYWNlOiB3b3JrZmxvd0luZm8oKS5uYW1lc3BhY2UsIC8vIE5vdCBjb25maWd1cmFibGVcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgY2FuY2VsbGF0aW9uVHlwZTogb3B0aW9ucy5jYW5jZWxsYXRpb25UeXBlLFxuICAgICAgICB3b3JrZmxvd0lkUmV1c2VQb2xpY3k6IG9wdGlvbnMud29ya2Zsb3dJZFJldXNlUG9saWN5LFxuICAgICAgICBwYXJlbnRDbG9zZVBvbGljeTogb3B0aW9ucy5wYXJlbnRDbG9zZVBvbGljeSxcbiAgICAgICAgY3JvblNjaGVkdWxlOiBvcHRpb25zLmNyb25TY2hlZHVsZSxcbiAgICAgICAgc2VhcmNoQXR0cmlidXRlczogb3B0aW9ucy5zZWFyY2hBdHRyaWJ1dGVzXG4gICAgICAgICAgPyBtYXBUb1BheWxvYWRzKHNlYXJjaEF0dHJpYnV0ZVBheWxvYWRDb252ZXJ0ZXIsIG9wdGlvbnMuc2VhcmNoQXR0cmlidXRlcylcbiAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWVtbzogb3B0aW9ucy5tZW1vICYmIG1hcFRvUGF5bG9hZHMoYWN0aXZhdG9yLnBheWxvYWRDb252ZXJ0ZXIsIG9wdGlvbnMubWVtbyksXG4gICAgICAgIHZlcnNpb25pbmdJbnRlbnQ6IHZlcnNpb25pbmdJbnRlbnRUb1Byb3RvKG9wdGlvbnMudmVyc2lvbmluZ0ludGVudCksXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGFjdGl2YXRvci5jb21wbGV0aW9ucy5jaGlsZFdvcmtmbG93U3RhcnQuc2V0KHNlcSwge1xuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdCxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gV2UgY29uc3RydWN0IGEgUHJvbWlzZSBmb3IgdGhlIGNvbXBsZXRpb24gb2YgdGhlIGNoaWxkIFdvcmtmbG93IGJlZm9yZSB3ZSBrbm93XG4gIC8vIGlmIHRoZSBXb3JrZmxvdyBjb2RlIHdpbGwgYXdhaXQgaXQgdG8gY2FwdHVyZSB0aGUgcmVzdWx0IGluIGNhc2UgaXQgZG9lcy5cbiAgY29uc3QgY29tcGxldGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIENoYWluIHN0YXJ0IFByb21pc2UgcmVqZWN0aW9uIHRvIHRoZSBjb21wbGV0ZSBQcm9taXNlLlxuICAgIHVudHJhY2tQcm9taXNlKHN0YXJ0UHJvbWlzZS5jYXRjaChyZWplY3QpKTtcbiAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMuY2hpbGRXb3JrZmxvd0NvbXBsZXRlLnNldChzZXEsIHtcbiAgICAgIHJlc29sdmUsXG4gICAgICByZWplY3QsXG4gICAgfSk7XG4gIH0pO1xuICB1bnRyYWNrUHJvbWlzZShzdGFydFByb21pc2UpO1xuICB1bnRyYWNrUHJvbWlzZShjb21wbGV0ZVByb21pc2UpO1xuICAvLyBQcmV2ZW50IHVuaGFuZGxlZCByZWplY3Rpb24gYmVjYXVzZSB0aGUgY29tcGxldGlvbiBtaWdodCBub3QgYmUgYXdhaXRlZFxuICB1bnRyYWNrUHJvbWlzZShjb21wbGV0ZVByb21pc2UuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKSk7XG4gIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlPFtQcm9taXNlPHN0cmluZz4sIFByb21pc2U8dW5rbm93bj5dPigocmVzb2x2ZSkgPT4gcmVzb2x2ZShbc3RhcnRQcm9taXNlLCBjb21wbGV0ZVByb21pc2VdKSk7XG4gIHVudHJhY2tQcm9taXNlKHJldCk7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNpZ25hbFdvcmtmbG93TmV4dEhhbmRsZXIoeyBzZXEsIHNpZ25hbE5hbWUsIGFyZ3MsIHRhcmdldCwgaGVhZGVycyB9OiBTaWduYWxXb3JrZmxvd0lucHV0KSB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICByZXR1cm4gbmV3IFByb21pc2U8YW55PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBDYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCk7XG4gICAgaWYgKHNjb3BlLmNvbnNpZGVyZWRDYW5jZWxsZWQpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaChyZWplY3QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKFxuICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIGlmICghYWN0aXZhdG9yLmNvbXBsZXRpb25zLnNpZ25hbFdvcmtmbG93LmhhcyhzZXEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7IGNhbmNlbFNpZ25hbFdvcmtmbG93OiB7IHNlcSB9IH0pO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHNpZ25hbEV4dGVybmFsV29ya2Zsb3dFeGVjdXRpb246IHtcbiAgICAgICAgc2VxLFxuICAgICAgICBhcmdzOiB0b1BheWxvYWRzKGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyLCAuLi5hcmdzKSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc2lnbmFsTmFtZSxcbiAgICAgICAgLi4uKHRhcmdldC50eXBlID09PSAnZXh0ZXJuYWwnXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIHdvcmtmbG93RXhlY3V0aW9uOiB7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBhY3RpdmF0b3IuaW5mby5uYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgLi4udGFyZ2V0LndvcmtmbG93RXhlY3V0aW9uLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICBjaGlsZFdvcmtmbG93SWQ6IHRhcmdldC5jaGlsZFdvcmtmbG93SWQsXG4gICAgICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMuc2lnbmFsV29ya2Zsb3cuc2V0KHNlcSwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN5bWJvbCB1c2VkIGluIHRoZSByZXR1cm4gdHlwZSBvZiBwcm94eSBtZXRob2RzIHRvIG1hcmsgdGhhdCBhbiBhdHRyaWJ1dGUgb24gdGhlIHNvdXJjZSB0eXBlIGlzIG5vdCBhIG1ldGhvZC5cbiAqXG4gKiBAc2VlIHtAbGluayBBY3Rpdml0eUludGVyZmFjZUZvcn1cbiAqIEBzZWUge0BsaW5rIHByb3h5QWN0aXZpdGllc31cbiAqIEBzZWUge0BsaW5rIHByb3h5TG9jYWxBY3Rpdml0aWVzfVxuICovXG5leHBvcnQgY29uc3QgTm90QW5BY3Rpdml0eU1ldGhvZCA9IFN5bWJvbC5mb3IoJ19fVEVNUE9SQUxfTk9UX0FOX0FDVElWSVRZX01FVEhPRCcpO1xuXG4vKipcbiAqIFR5cGUgaGVscGVyIHRoYXQgdGFrZXMgYSB0eXBlIGBUYCBhbmQgdHJhbnNmb3JtcyBhdHRyaWJ1dGVzIHRoYXQgYXJlIG5vdCB7QGxpbmsgQWN0aXZpdHlGdW5jdGlvbn0gdG9cbiAqIHtAbGluayBOb3RBbkFjdGl2aXR5TWV0aG9kfS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZWQgYnkge0BsaW5rIHByb3h5QWN0aXZpdGllc30gdG8gZ2V0IHRoaXMgY29tcGlsZS10aW1lIGVycm9yOlxuICpcbiAqIGBgYHRzXG4gKiBpbnRlcmZhY2UgTXlBY3Rpdml0aWVzIHtcbiAqICAgdmFsaWQoaW5wdXQ6IG51bWJlcik6IFByb21pc2U8bnVtYmVyPjtcbiAqICAgaW52YWxpZChpbnB1dDogbnVtYmVyKTogbnVtYmVyO1xuICogfVxuICpcbiAqIGNvbnN0IGFjdCA9IHByb3h5QWN0aXZpdGllczxNeUFjdGl2aXRpZXM+KHsgc3RhcnRUb0Nsb3NlVGltZW91dDogJzVtJyB9KTtcbiAqXG4gKiBhd2FpdCBhY3QudmFsaWQodHJ1ZSk7XG4gKiBhd2FpdCBhY3QuaW52YWxpZCgpO1xuICogLy8gXiBUUyBjb21wbGFpbnMgd2l0aDpcbiAqIC8vIChwcm9wZXJ0eSkgaW52YWxpZERlZmluaXRpb246IHR5cGVvZiBOb3RBbkFjdGl2aXR5TWV0aG9kXG4gKiAvLyBUaGlzIGV4cHJlc3Npb24gaXMgbm90IGNhbGxhYmxlLlxuICogLy8gVHlwZSAnU3ltYm9sJyBoYXMgbm8gY2FsbCBzaWduYXR1cmVzLigyMzQ5KVxuICogYGBgXG4gKi9cbmV4cG9ydCB0eXBlIEFjdGl2aXR5SW50ZXJmYWNlRm9yPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXTogVFtLXSBleHRlbmRzIEFjdGl2aXR5RnVuY3Rpb24gPyBUW0tdIDogdHlwZW9mIE5vdEFuQWN0aXZpdHlNZXRob2Q7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyZSBBY3Rpdml0eSBmdW5jdGlvbnMgd2l0aCBnaXZlbiB7QGxpbmsgQWN0aXZpdHlPcHRpb25zfS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHNldHVwIEFjdGl2aXRpZXMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIGEge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5IHwgUHJveHl9IGZvclxuICogICAgICAgICB3aGljaCBlYWNoIGF0dHJpYnV0ZSBpcyBhIGNhbGxhYmxlIEFjdGl2aXR5IGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwcm94eUFjdGl2aXRpZXMgfSBmcm9tICdAdGVtcG9yYWxpby93b3JrZmxvdyc7XG4gKiBpbXBvcnQgKiBhcyBhY3Rpdml0aWVzIGZyb20gJy4uL2FjdGl2aXRpZXMnO1xuICpcbiAqIC8vIFNldHVwIEFjdGl2aXRpZXMgZnJvbSBtb2R1bGUgZXhwb3J0c1xuICogY29uc3QgeyBodHRwR2V0LCBvdGhlckFjdGl2aXR5IH0gPSBwcm94eUFjdGl2aXRpZXM8dHlwZW9mIGFjdGl2aXRpZXM+KHtcbiAqICAgc3RhcnRUb0Nsb3NlVGltZW91dDogJzMwIG1pbnV0ZXMnLFxuICogfSk7XG4gKlxuICogLy8gU2V0dXAgQWN0aXZpdGllcyBmcm9tIGFuIGV4cGxpY2l0IGludGVyZmFjZSAoZS5nLiB3aGVuIGRlZmluZWQgYnkgYW5vdGhlciBTREspXG4gKiBpbnRlcmZhY2UgSmF2YUFjdGl2aXRpZXMge1xuICogICBodHRwR2V0RnJvbUphdmEodXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz5cbiAqICAgc29tZU90aGVySmF2YUFjdGl2aXR5KGFyZzE6IG51bWJlciwgYXJnMjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+O1xuICogfVxuICpcbiAqIGNvbnN0IHtcbiAqICAgaHR0cEdldEZyb21KYXZhLFxuICogICBzb21lT3RoZXJKYXZhQWN0aXZpdHlcbiAqIH0gPSBwcm94eUFjdGl2aXRpZXM8SmF2YUFjdGl2aXRpZXM+KHtcbiAqICAgdGFza1F1ZXVlOiAnamF2YS13b3JrZXItdGFza1F1ZXVlJyxcbiAqICAgc3RhcnRUb0Nsb3NlVGltZW91dDogJzVtJyxcbiAqIH0pO1xuICpcbiAqIGV4cG9ydCBmdW5jdGlvbiBleGVjdXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICogICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHBHZXQoXCJodHRwOi8vZXhhbXBsZS5jb21cIik7XG4gKiAgIC8vIC4uLlxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm94eUFjdGl2aXRpZXM8QSA9IFVudHlwZWRBY3Rpdml0aWVzPihvcHRpb25zOiBBY3Rpdml0eU9wdGlvbnMpOiBBY3Rpdml0eUludGVyZmFjZUZvcjxBPiB7XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG4gIC8vIFZhbGlkYXRlIGFzIGVhcmx5IGFzIHBvc3NpYmxlIGZvciBpbW1lZGlhdGUgdXNlciBmZWVkYmFja1xuICB2YWxpZGF0ZUFjdGl2aXR5T3B0aW9ucyhvcHRpb25zKTtcbiAgcmV0dXJuIG5ldyBQcm94eShcbiAgICB7fSxcbiAgICB7XG4gICAgICBnZXQoXywgYWN0aXZpdHlUeXBlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aXZpdHlUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBBY3Rpdml0eSB0eXBlcywgZ290OiAke1N0cmluZyhhY3Rpdml0eVR5cGUpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhY3Rpdml0eVByb3h5RnVuY3Rpb24oLi4uYXJnczogdW5rbm93bltdKTogUHJvbWlzZTx1bmtub3duPiB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aXZpdHkoYWN0aXZpdHlUeXBlLCBhcmdzLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgfVxuICApIGFzIGFueTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmUgTG9jYWwgQWN0aXZpdHkgZnVuY3Rpb25zIHdpdGggZ2l2ZW4ge0BsaW5rIExvY2FsQWN0aXZpdHlPcHRpb25zfS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHNldHVwIEFjdGl2aXRpZXMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIGEge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5IHwgUHJveHl9XG4gKiAgICAgICAgIGZvciB3aGljaCBlYWNoIGF0dHJpYnV0ZSBpcyBhIGNhbGxhYmxlIEFjdGl2aXR5IGZ1bmN0aW9uXG4gKlxuICogQHNlZSB7QGxpbmsgcHJveHlBY3Rpdml0aWVzfSBmb3IgZXhhbXBsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3h5TG9jYWxBY3Rpdml0aWVzPEEgPSBVbnR5cGVkQWN0aXZpdGllcz4ob3B0aW9uczogTG9jYWxBY3Rpdml0eU9wdGlvbnMpOiBBY3Rpdml0eUludGVyZmFjZUZvcjxBPiB7XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG4gIC8vIFZhbGlkYXRlIGFzIGVhcmx5IGFzIHBvc3NpYmxlIGZvciBpbW1lZGlhdGUgdXNlciBmZWVkYmFja1xuICB2YWxpZGF0ZUxvY2FsQWN0aXZpdHlPcHRpb25zKG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IFByb3h5KFxuICAgIHt9LFxuICAgIHtcbiAgICAgIGdldChfLCBhY3Rpdml0eVR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpdml0eVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgT25seSBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIEFjdGl2aXR5IHR5cGVzLCBnb3Q6ICR7U3RyaW5nKGFjdGl2aXR5VHlwZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvY2FsQWN0aXZpdHlQcm94eUZ1bmN0aW9uKC4uLmFyZ3M6IHVua25vd25bXSkge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUxvY2FsQWN0aXZpdHkoYWN0aXZpdHlUeXBlLCBhcmdzLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgfVxuICApIGFzIGFueTtcbn1cblxuLy8gVE9ETzogZGVwcmVjYXRlIHRoaXMgcGF0Y2ggYWZ0ZXIgXCJlbm91Z2hcIiB0aW1lIGhhcyBwYXNzZWRcbmNvbnN0IEVYVEVSTkFMX1dGX0NBTkNFTF9QQVRDSCA9ICdfX3RlbXBvcmFsX2ludGVybmFsX2Nvbm5lY3RfZXh0ZXJuYWxfaGFuZGxlX2NhbmNlbF90b19zY29wZSc7XG4vLyBUaGUgbmFtZSBvZiB0aGlzIHBhdGNoIGNvbWVzIGZyb20gYW4gYXR0ZW1wdCB0byBidWlsZCBhIGdlbmVyaWMgaW50ZXJuYWwgcGF0Y2hpbmcgbWVjaGFuaXNtLlxuLy8gVGhhdCBlZmZvcnQgaGFzIGJlZW4gYWJhbmRvbmVkIGluIGZhdm9yIG9mIGEgbmV3ZXIgV29ya2Zsb3dUYXNrQ29tcGxldGVkTWV0YWRhdGEgYmFzZWQgbWVjaGFuaXNtLlxuY29uc3QgQ09ORElUSU9OXzBfUEFUQ0ggPSAnX19zZGtfaW50ZXJuYWxfcGF0Y2hfbnVtYmVyOjEnO1xuXG4vKipcbiAqIFJldHVybnMgYSBjbGllbnQtc2lkZSBoYW5kbGUgdGhhdCBjYW4gYmUgdXNlZCB0byBzaWduYWwgYW5kIGNhbmNlbCBhbiBleGlzdGluZyBXb3JrZmxvdyBleGVjdXRpb24uXG4gKiBJdCB0YWtlcyBhIFdvcmtmbG93IElEIGFuZCBvcHRpb25hbCBydW4gSUQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlcm5hbFdvcmtmbG93SGFuZGxlKHdvcmtmbG93SWQ6IHN0cmluZywgcnVuSWQ/OiBzdHJpbmcpOiBFeHRlcm5hbFdvcmtmbG93SGFuZGxlIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoXG4gICAgJ1dvcmtmbG93LmdldEV4dGVybmFsV29ya2Zsb3dIYW5kbGUoLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uIENvbnNpZGVyIHVzaW5nIENsaWVudC53b3JrZmxvdy5nZXRIYW5kbGUoLi4uKSBpbnN0ZWFkLiknXG4gICk7XG4gIHJldHVybiB7XG4gICAgd29ya2Zsb3dJZCxcbiAgICBydW5JZCxcbiAgICBjYW5jZWwoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBDb25uZWN0IHRoaXMgY2FuY2VsIG9wZXJhdGlvbiB0byB0aGUgY3VycmVudCBjYW5jZWxsYXRpb24gc2NvcGUuXG4gICAgICAgIC8vIFRoaXMgaXMgYmVoYXZpb3Igd2FzIGludHJvZHVjZWQgYWZ0ZXIgdjAuMjIuMCBhbmQgaXMgaW5jb21wYXRpYmxlXG4gICAgICAgIC8vIHdpdGggaGlzdG9yaWVzIGdlbmVyYXRlZCB3aXRoIHByZXZpb3VzIFNESyB2ZXJzaW9ucyBhbmQgdGh1cyByZXF1aXJlc1xuICAgICAgICAvLyBwYXRjaGluZy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgdHJ5IHRvIGRlbGF5IHBhdGNoaW5nIGFzIG11Y2ggYXMgcG9zc2libGUgdG8gYXZvaWQgcG9sbHV0aW5nXG4gICAgICAgIC8vIGhpc3RvcmllcyB1bmxlc3Mgc3RyaWN0bHkgcmVxdWlyZWQuXG4gICAgICAgIGNvbnN0IHNjb3BlID0gQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpO1xuICAgICAgICBpZiAoc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgICAgICB1bnRyYWNrUHJvbWlzZShcbiAgICAgICAgICAgIHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChwYXRjaGVkKEVYVEVSTkFMX1dGX0NBTkNFTF9QQVRDSCkpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY29wZS5jb25zaWRlcmVkQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgaWYgKHBhdGNoZWQoRVhURVJOQUxfV0ZfQ0FOQ0VMX1BBVENIKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlcSA9IGFjdGl2YXRvci5uZXh0U2Vxcy5jYW5jZWxXb3JrZmxvdysrO1xuICAgICAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgICAgICAgIHJlcXVlc3RDYW5jZWxFeHRlcm5hbFdvcmtmbG93RXhlY3V0aW9uOiB7XG4gICAgICAgICAgICBzZXEsXG4gICAgICAgICAgICB3b3JrZmxvd0V4ZWN1dGlvbjoge1xuICAgICAgICAgICAgICBuYW1lc3BhY2U6IGFjdGl2YXRvci5pbmZvLm5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgd29ya2Zsb3dJZCxcbiAgICAgICAgICAgICAgcnVuSWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMuY2FuY2VsV29ya2Zsb3cuc2V0KHNlcSwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNpZ25hbDxBcmdzIGV4dGVuZHMgYW55W10+KGRlZjogU2lnbmFsRGVmaW5pdGlvbjxBcmdzPiB8IHN0cmluZywgLi4uYXJnczogQXJncyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgcmV0dXJuIGNvbXBvc2VJbnRlcmNlcHRvcnMoXG4gICAgICAgIGFjdGl2YXRvci5pbnRlcmNlcHRvcnMub3V0Ym91bmQsXG4gICAgICAgICdzaWduYWxXb3JrZmxvdycsXG4gICAgICAgIHNpZ25hbFdvcmtmbG93TmV4dEhhbmRsZXJcbiAgICAgICkoe1xuICAgICAgICBzZXE6IGFjdGl2YXRvci5uZXh0U2Vxcy5zaWduYWxXb3JrZmxvdysrLFxuICAgICAgICBzaWduYWxOYW1lOiB0eXBlb2YgZGVmID09PSAnc3RyaW5nJyA/IGRlZiA6IGRlZi5uYW1lLFxuICAgICAgICBhcmdzLFxuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICB0eXBlOiAnZXh0ZXJuYWwnLFxuICAgICAgICAgIHdvcmtmbG93RXhlY3V0aW9uOiB7IHdvcmtmbG93SWQsIHJ1bklkIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn1cblxuLyoqXG4gKiBTdGFydCBhIGNoaWxkIFdvcmtmbG93IGV4ZWN1dGlvblxuICpcbiAqIC0gUmV0dXJucyBhIGNsaWVudC1zaWRlIGhhbmRsZSB0aGF0IGltcGxlbWVudHMgYSBjaGlsZCBXb3JrZmxvdyBpbnRlcmZhY2UuXG4gKiAtIEJ5IGRlZmF1bHQsIGEgY2hpbGQgd2lsbCBiZSBzY2hlZHVsZWQgb24gdGhlIHNhbWUgdGFzayBxdWV1ZSBhcyBpdHMgcGFyZW50LlxuICpcbiAqIEEgY2hpbGQgV29ya2Zsb3cgaGFuZGxlIHN1cHBvcnRzIGF3YWl0aW5nIGNvbXBsZXRpb24sIHNpZ25hbGluZyBhbmQgY2FuY2VsbGF0aW9uIHZpYSB7QGxpbmsgQ2FuY2VsbGF0aW9uU2NvcGV9cy5cbiAqIEluIG9yZGVyIHRvIHF1ZXJ5IHRoZSBjaGlsZCwgdXNlIGEge0BsaW5rIFdvcmtmbG93Q2xpZW50fSBmcm9tIGFuIEFjdGl2aXR5LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnRDaGlsZDxUIGV4dGVuZHMgV29ya2Zsb3c+KFxuICB3b3JrZmxvd1R5cGU6IHN0cmluZyxcbiAgb3B0aW9uczogV2l0aFdvcmtmbG93QXJnczxULCBDaGlsZFdvcmtmbG93T3B0aW9ucz5cbik6IFByb21pc2U8Q2hpbGRXb3JrZmxvd0hhbmRsZTxUPj47XG5cbi8qKlxuICogU3RhcnQgYSBjaGlsZCBXb3JrZmxvdyBleGVjdXRpb25cbiAqXG4gKiAtIFJldHVybnMgYSBjbGllbnQtc2lkZSBoYW5kbGUgdGhhdCBpbXBsZW1lbnRzIGEgY2hpbGQgV29ya2Zsb3cgaW50ZXJmYWNlLlxuICogLSBEZWR1Y2VzIHRoZSBXb3JrZmxvdyB0eXBlIGFuZCBzaWduYXR1cmUgZnJvbSBwcm92aWRlZCBXb3JrZmxvdyBmdW5jdGlvbi5cbiAqIC0gQnkgZGVmYXVsdCwgYSBjaGlsZCB3aWxsIGJlIHNjaGVkdWxlZCBvbiB0aGUgc2FtZSB0YXNrIHF1ZXVlIGFzIGl0cyBwYXJlbnQuXG4gKlxuICogQSBjaGlsZCBXb3JrZmxvdyBoYW5kbGUgc3VwcG9ydHMgYXdhaXRpbmcgY29tcGxldGlvbiwgc2lnbmFsaW5nIGFuZCBjYW5jZWxsYXRpb24gdmlhIHtAbGluayBDYW5jZWxsYXRpb25TY29wZX1zLlxuICogSW4gb3JkZXIgdG8gcXVlcnkgdGhlIGNoaWxkLCB1c2UgYSB7QGxpbmsgV29ya2Zsb3dDbGllbnR9IGZyb20gYW4gQWN0aXZpdHkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydENoaWxkPFQgZXh0ZW5kcyBXb3JrZmxvdz4oXG4gIHdvcmtmbG93RnVuYzogVCxcbiAgb3B0aW9uczogV2l0aFdvcmtmbG93QXJnczxULCBDaGlsZFdvcmtmbG93T3B0aW9ucz5cbik6IFByb21pc2U8Q2hpbGRXb3JrZmxvd0hhbmRsZTxUPj47XG5cbi8qKlxuICogU3RhcnQgYSBjaGlsZCBXb3JrZmxvdyBleGVjdXRpb25cbiAqXG4gKiAqKk92ZXJyaWRlIGZvciBXb3JrZmxvd3MgdGhhdCBhY2NlcHQgbm8gYXJndW1lbnRzKiouXG4gKlxuICogLSBSZXR1cm5zIGEgY2xpZW50LXNpZGUgaGFuZGxlIHRoYXQgaW1wbGVtZW50cyBhIGNoaWxkIFdvcmtmbG93IGludGVyZmFjZS5cbiAqIC0gVGhlIGNoaWxkIHdpbGwgYmUgc2NoZWR1bGVkIG9uIHRoZSBzYW1lIHRhc2sgcXVldWUgYXMgaXRzIHBhcmVudC5cbiAqXG4gKiBBIGNoaWxkIFdvcmtmbG93IGhhbmRsZSBzdXBwb3J0cyBhd2FpdGluZyBjb21wbGV0aW9uLCBzaWduYWxpbmcgYW5kIGNhbmNlbGxhdGlvbiB2aWEge0BsaW5rIENhbmNlbGxhdGlvblNjb3BlfXMuXG4gKiBJbiBvcmRlciB0byBxdWVyeSB0aGUgY2hpbGQsIHVzZSBhIHtAbGluayBXb3JrZmxvd0NsaWVudH0gZnJvbSBhbiBBY3Rpdml0eS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0Q2hpbGQ8VCBleHRlbmRzICgpID0+IFByb21pc2U8YW55Pj4od29ya2Zsb3dUeXBlOiBzdHJpbmcpOiBQcm9taXNlPENoaWxkV29ya2Zsb3dIYW5kbGU8VD4+O1xuXG4vKipcbiAqIFN0YXJ0IGEgY2hpbGQgV29ya2Zsb3cgZXhlY3V0aW9uXG4gKlxuICogKipPdmVycmlkZSBmb3IgV29ya2Zsb3dzIHRoYXQgYWNjZXB0IG5vIGFyZ3VtZW50cyoqLlxuICpcbiAqIC0gUmV0dXJucyBhIGNsaWVudC1zaWRlIGhhbmRsZSB0aGF0IGltcGxlbWVudHMgYSBjaGlsZCBXb3JrZmxvdyBpbnRlcmZhY2UuXG4gKiAtIERlZHVjZXMgdGhlIFdvcmtmbG93IHR5cGUgYW5kIHNpZ25hdHVyZSBmcm9tIHByb3ZpZGVkIFdvcmtmbG93IGZ1bmN0aW9uLlxuICogLSBUaGUgY2hpbGQgd2lsbCBiZSBzY2hlZHVsZWQgb24gdGhlIHNhbWUgdGFzayBxdWV1ZSBhcyBpdHMgcGFyZW50LlxuICpcbiAqIEEgY2hpbGQgV29ya2Zsb3cgaGFuZGxlIHN1cHBvcnRzIGF3YWl0aW5nIGNvbXBsZXRpb24sIHNpZ25hbGluZyBhbmQgY2FuY2VsbGF0aW9uIHZpYSB7QGxpbmsgQ2FuY2VsbGF0aW9uU2NvcGV9cy5cbiAqIEluIG9yZGVyIHRvIHF1ZXJ5IHRoZSBjaGlsZCwgdXNlIGEge0BsaW5rIFdvcmtmbG93Q2xpZW50fSBmcm9tIGFuIEFjdGl2aXR5LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnRDaGlsZDxUIGV4dGVuZHMgKCkgPT4gUHJvbWlzZTxhbnk+Pih3b3JrZmxvd0Z1bmM6IFQpOiBQcm9taXNlPENoaWxkV29ya2Zsb3dIYW5kbGU8VD4+O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnRDaGlsZDxUIGV4dGVuZHMgV29ya2Zsb3c+KFxuICB3b3JrZmxvd1R5cGVPckZ1bmM6IHN0cmluZyB8IFQsXG4gIG9wdGlvbnM/OiBXaXRoV29ya2Zsb3dBcmdzPFQsIENoaWxkV29ya2Zsb3dPcHRpb25zPlxuKTogUHJvbWlzZTxDaGlsZFdvcmtmbG93SGFuZGxlPFQ+PiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFxuICAgICdXb3JrZmxvdy5zdGFydENoaWxkKC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLiBDb25zaWRlciB1c2luZyBDbGllbnQud29ya2Zsb3cuc3RhcnQoLi4uKSBpbnN0ZWFkLiknXG4gICk7XG4gIGNvbnN0IG9wdGlvbnNXaXRoRGVmYXVsdHMgPSBhZGREZWZhdWx0V29ya2Zsb3dPcHRpb25zKG9wdGlvbnMgPz8gKHt9IGFzIGFueSkpO1xuICBjb25zdCB3b3JrZmxvd1R5cGUgPSBleHRyYWN0V29ya2Zsb3dUeXBlKHdvcmtmbG93VHlwZU9yRnVuYyk7XG4gIGNvbnN0IGV4ZWN1dGUgPSBjb21wb3NlSW50ZXJjZXB0b3JzKFxuICAgIGFjdGl2YXRvci5pbnRlcmNlcHRvcnMub3V0Ym91bmQsXG4gICAgJ3N0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbicsXG4gICAgc3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uTmV4dEhhbmRsZXJcbiAgKTtcbiAgY29uc3QgW3N0YXJ0ZWQsIGNvbXBsZXRlZF0gPSBhd2FpdCBleGVjdXRlKHtcbiAgICBzZXE6IGFjdGl2YXRvci5uZXh0U2Vxcy5jaGlsZFdvcmtmbG93KyssXG4gICAgb3B0aW9uczogb3B0aW9uc1dpdGhEZWZhdWx0cyxcbiAgICBoZWFkZXJzOiB7fSxcbiAgICB3b3JrZmxvd1R5cGUsXG4gIH0pO1xuICBjb25zdCBmaXJzdEV4ZWN1dGlvblJ1bklkID0gYXdhaXQgc3RhcnRlZDtcblxuICByZXR1cm4ge1xuICAgIHdvcmtmbG93SWQ6IG9wdGlvbnNXaXRoRGVmYXVsdHMud29ya2Zsb3dJZCxcbiAgICBmaXJzdEV4ZWN1dGlvblJ1bklkLFxuICAgIGFzeW5jIHJlc3VsdCgpOiBQcm9taXNlPFdvcmtmbG93UmVzdWx0VHlwZTxUPj4ge1xuICAgICAgcmV0dXJuIChhd2FpdCBjb21wbGV0ZWQpIGFzIGFueTtcbiAgICB9LFxuICAgIGFzeW5jIHNpZ25hbDxBcmdzIGV4dGVuZHMgYW55W10+KGRlZjogU2lnbmFsRGVmaW5pdGlvbjxBcmdzPiB8IHN0cmluZywgLi4uYXJnczogQXJncyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgcmV0dXJuIGNvbXBvc2VJbnRlcmNlcHRvcnMoXG4gICAgICAgIGFjdGl2YXRvci5pbnRlcmNlcHRvcnMub3V0Ym91bmQsXG4gICAgICAgICdzaWduYWxXb3JrZmxvdycsXG4gICAgICAgIHNpZ25hbFdvcmtmbG93TmV4dEhhbmRsZXJcbiAgICAgICkoe1xuICAgICAgICBzZXE6IGFjdGl2YXRvci5uZXh0U2Vxcy5zaWduYWxXb3JrZmxvdysrLFxuICAgICAgICBzaWduYWxOYW1lOiB0eXBlb2YgZGVmID09PSAnc3RyaW5nJyA/IGRlZiA6IGRlZi5uYW1lLFxuICAgICAgICBhcmdzLFxuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICB0eXBlOiAnY2hpbGQnLFxuICAgICAgICAgIGNoaWxkV29ya2Zsb3dJZDogb3B0aW9uc1dpdGhEZWZhdWx0cy53b3JrZmxvd0lkLFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIH0pO1xuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogU3RhcnQgYSBjaGlsZCBXb3JrZmxvdyBleGVjdXRpb24gYW5kIGF3YWl0IGl0cyBjb21wbGV0aW9uLlxuICpcbiAqIC0gQnkgZGVmYXVsdCwgYSBjaGlsZCB3aWxsIGJlIHNjaGVkdWxlZCBvbiB0aGUgc2FtZSB0YXNrIHF1ZXVlIGFzIGl0cyBwYXJlbnQuXG4gKiAtIFRoaXMgb3BlcmF0aW9uIGlzIGNhbmNlbGxhYmxlIHVzaW5nIHtAbGluayBDYW5jZWxsYXRpb25TY29wZX1zLlxuICpcbiAqIEByZXR1cm4gVGhlIHJlc3VsdCBvZiB0aGUgY2hpbGQgV29ya2Zsb3cuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjdXRlQ2hpbGQ8VCBleHRlbmRzIFdvcmtmbG93PihcbiAgd29ya2Zsb3dUeXBlOiBzdHJpbmcsXG4gIG9wdGlvbnM6IFdpdGhXb3JrZmxvd0FyZ3M8VCwgQ2hpbGRXb3JrZmxvd09wdGlvbnM+XG4pOiBQcm9taXNlPFdvcmtmbG93UmVzdWx0VHlwZTxUPj47XG5cbi8qKlxuICogU3RhcnQgYSBjaGlsZCBXb3JrZmxvdyBleGVjdXRpb24gYW5kIGF3YWl0IGl0cyBjb21wbGV0aW9uLlxuICpcbiAqIC0gQnkgZGVmYXVsdCwgYSBjaGlsZCB3aWxsIGJlIHNjaGVkdWxlZCBvbiB0aGUgc2FtZSB0YXNrIHF1ZXVlIGFzIGl0cyBwYXJlbnQuXG4gKiAtIERlZHVjZXMgdGhlIFdvcmtmbG93IHR5cGUgYW5kIHNpZ25hdHVyZSBmcm9tIHByb3ZpZGVkIFdvcmtmbG93IGZ1bmN0aW9uLlxuICogLSBUaGlzIG9wZXJhdGlvbiBpcyBjYW5jZWxsYWJsZSB1c2luZyB7QGxpbmsgQ2FuY2VsbGF0aW9uU2NvcGV9cy5cbiAqXG4gKiBAcmV0dXJuIFRoZSByZXN1bHQgb2YgdGhlIGNoaWxkIFdvcmtmbG93LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUNoaWxkPFQgZXh0ZW5kcyBXb3JrZmxvdz4oXG4gIHdvcmtmbG93RnVuYzogVCxcbiAgb3B0aW9uczogV2l0aFdvcmtmbG93QXJnczxULCBDaGlsZFdvcmtmbG93T3B0aW9ucz5cbik6IFByb21pc2U8V29ya2Zsb3dSZXN1bHRUeXBlPFQ+PjtcblxuLyoqXG4gKiBTdGFydCBhIGNoaWxkIFdvcmtmbG93IGV4ZWN1dGlvbiBhbmQgYXdhaXQgaXRzIGNvbXBsZXRpb24uXG4gKlxuICogKipPdmVycmlkZSBmb3IgV29ya2Zsb3dzIHRoYXQgYWNjZXB0IG5vIGFyZ3VtZW50cyoqLlxuICpcbiAqIC0gVGhlIGNoaWxkIHdpbGwgYmUgc2NoZWR1bGVkIG9uIHRoZSBzYW1lIHRhc2sgcXVldWUgYXMgaXRzIHBhcmVudC5cbiAqIC0gVGhpcyBvcGVyYXRpb24gaXMgY2FuY2VsbGFibGUgdXNpbmcge0BsaW5rIENhbmNlbGxhdGlvblNjb3BlfXMuXG4gKlxuICogQHJldHVybiBUaGUgcmVzdWx0IG9mIHRoZSBjaGlsZCBXb3JrZmxvdy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVDaGlsZDxUIGV4dGVuZHMgKCkgPT4gV29ya2Zsb3dSZXR1cm5UeXBlPihcbiAgd29ya2Zsb3dUeXBlOiBzdHJpbmdcbik6IFByb21pc2U8V29ya2Zsb3dSZXN1bHRUeXBlPFQ+PjtcblxuLyoqXG4gKiBTdGFydCBhIGNoaWxkIFdvcmtmbG93IGV4ZWN1dGlvbiBhbmQgYXdhaXQgaXRzIGNvbXBsZXRpb24uXG4gKlxuICogKipPdmVycmlkZSBmb3IgV29ya2Zsb3dzIHRoYXQgYWNjZXB0IG5vIGFyZ3VtZW50cyoqLlxuICpcbiAqIC0gVGhlIGNoaWxkIHdpbGwgYmUgc2NoZWR1bGVkIG9uIHRoZSBzYW1lIHRhc2sgcXVldWUgYXMgaXRzIHBhcmVudC5cbiAqIC0gRGVkdWNlcyB0aGUgV29ya2Zsb3cgdHlwZSBhbmQgc2lnbmF0dXJlIGZyb20gcHJvdmlkZWQgV29ya2Zsb3cgZnVuY3Rpb24uXG4gKiAtIFRoaXMgb3BlcmF0aW9uIGlzIGNhbmNlbGxhYmxlIHVzaW5nIHtAbGluayBDYW5jZWxsYXRpb25TY29wZX1zLlxuICpcbiAqIEByZXR1cm4gVGhlIHJlc3VsdCBvZiB0aGUgY2hpbGQgV29ya2Zsb3cuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjdXRlQ2hpbGQ8VCBleHRlbmRzICgpID0+IFdvcmtmbG93UmV0dXJuVHlwZT4od29ya2Zsb3dGdW5jOiBUKTogUHJvbWlzZTxXb3JrZmxvd1Jlc3VsdFR5cGU8VD4+O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUNoaWxkPFQgZXh0ZW5kcyBXb3JrZmxvdz4oXG4gIHdvcmtmbG93VHlwZU9yRnVuYzogc3RyaW5nIHwgVCxcbiAgb3B0aW9ucz86IFdpdGhXb3JrZmxvd0FyZ3M8VCwgQ2hpbGRXb3JrZmxvd09wdGlvbnM+XG4pOiBQcm9taXNlPFdvcmtmbG93UmVzdWx0VHlwZTxUPj4ge1xuICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dChcbiAgICAnV29ya2Zsb3cuZXhlY3V0ZUNoaWxkKC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLiBDb25zaWRlciB1c2luZyBDbGllbnQud29ya2Zsb3cuZXhlY3V0ZSguLi4pIGluc3RlYWQuJ1xuICApO1xuICBjb25zdCBvcHRpb25zV2l0aERlZmF1bHRzID0gYWRkRGVmYXVsdFdvcmtmbG93T3B0aW9ucyhvcHRpb25zID8/ICh7fSBhcyBhbnkpKTtcbiAgY29uc3Qgd29ya2Zsb3dUeXBlID0gZXh0cmFjdFdvcmtmbG93VHlwZSh3b3JrZmxvd1R5cGVPckZ1bmMpO1xuICBjb25zdCBleGVjdXRlID0gY29tcG9zZUludGVyY2VwdG9ycyhcbiAgICBhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLm91dGJvdW5kLFxuICAgICdzdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb24nLFxuICAgIHN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbk5leHRIYW5kbGVyXG4gICk7XG4gIGNvbnN0IGV4ZWNQcm9taXNlID0gZXhlY3V0ZSh7XG4gICAgc2VxOiBhY3RpdmF0b3IubmV4dFNlcXMuY2hpbGRXb3JrZmxvdysrLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNXaXRoRGVmYXVsdHMsXG4gICAgaGVhZGVyczoge30sXG4gICAgd29ya2Zsb3dUeXBlLFxuICB9KTtcbiAgdW50cmFja1Byb21pc2UoZXhlY1Byb21pc2UpO1xuICBjb25zdCBjb21wbGV0ZWRQcm9taXNlID0gZXhlY1Byb21pc2UudGhlbigoW19zdGFydGVkLCBjb21wbGV0ZWRdKSA9PiBjb21wbGV0ZWQpO1xuICB1bnRyYWNrUHJvbWlzZShjb21wbGV0ZWRQcm9taXNlKTtcbiAgcmV0dXJuIGNvbXBsZXRlZFByb21pc2UgYXMgUHJvbWlzZTxhbnk+O1xufVxuXG4vKipcbiAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBXb3JrZmxvdy5cbiAqXG4gKiDimqDvuI8gV2UgcmVjb21tZW5kIGNhbGxpbmcgYHdvcmtmbG93SW5mbygpYCB3aGVuZXZlciBhY2Nlc3Npbmcge0BsaW5rIFdvcmtmbG93SW5mb30gZmllbGRzLiBTb21lIFdvcmtmbG93SW5mbyBmaWVsZHNcbiAqIGNoYW5nZSBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIGFuIEV4ZWN1dGlvbuKAlGxpa2Uge0BsaW5rIFdvcmtmbG93SW5mby5oaXN0b3J5TGVuZ3RofSBhbmRcbiAqIHtAbGluayBXb3JrZmxvd0luZm8uc2VhcmNoQXR0cmlidXRlc33igJRhbmQgc29tZSBtYXkgYmUgY2hhbmdlYWJsZSBpbiB0aGUgZnV0dXJl4oCUbGlrZSB7QGxpbmsgV29ya2Zsb3dJbmZvLnRhc2tRdWV1ZX0uXG4gKlxuICogYGBgdHNcbiAqIC8vIEdPT0RcbiAqIGZ1bmN0aW9uIG15V29ya2Zsb3coKSB7XG4gKiAgIGRvU29tZXRoaW5nKHdvcmtmbG93SW5mbygpLnNlYXJjaEF0dHJpYnV0ZXMpXG4gKiAgIC4uLlxuICogICBkb1NvbWV0aGluZ0Vsc2Uod29ya2Zsb3dJbmZvKCkuc2VhcmNoQXR0cmlidXRlcylcbiAqIH1cbiAqIGBgYFxuICpcbiAqIGBgYHRzXG4gKiAvLyBCQURcbiAqIGZ1bmN0aW9uIG15V29ya2Zsb3coKSB7XG4gKiAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB3b3JrZmxvd0luZm8oKS5zZWFyY2hBdHRyaWJ1dGVzXG4gKiAgIGRvU29tZXRoaW5nKGF0dHJpYnV0ZXMpXG4gKiAgIC4uLlxuICogICBkb1NvbWV0aGluZ0Vsc2UoYXR0cmlidXRlcylcbiAqIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdvcmtmbG93SW5mbygpOiBXb3JrZmxvd0luZm8ge1xuICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dCgnV29ya2Zsb3cud29ya2Zsb3dJbmZvKC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLicpO1xuICByZXR1cm4gYWN0aXZhdG9yLmluZm87XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBjb2RlIGlzIGV4ZWN1dGluZyBpbiB3b3JrZmxvdyBjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbldvcmtmbG93Q29udGV4dCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIG1heWJlR2V0QWN0aXZhdG9yKCkgIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBHZXQgYSByZWZlcmVuY2UgdG8gU2lua3MgZm9yIGV4cG9ydGluZyBkYXRhIG91dCBvZiB0aGUgV29ya2Zsb3cuXG4gKlxuICogVGhlc2UgU2lua3MgKiptdXN0KiogYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBXb3JrZXIgaW4gb3JkZXIgZm9yIHRoaXNcbiAqIG1lY2hhbmlzbSB0byB3b3JrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcHJveHlTaW5rcywgU2lua3MgfSBmcm9tICdAdGVtcG9yYWxpby93b3JrZmxvdyc7XG4gKlxuICogaW50ZXJmYWNlIE15U2lua3MgZXh0ZW5kcyBTaW5rcyB7XG4gKiAgIGxvZ2dlcjoge1xuICogICAgIGluZm8obWVzc2FnZTogc3RyaW5nKTogdm9pZDtcbiAqICAgICBlcnJvcihtZXNzYWdlOiBzdHJpbmcpOiB2b2lkO1xuICogICB9O1xuICogfVxuICpcbiAqIGNvbnN0IHsgbG9nZ2VyIH0gPSBwcm94eVNpbmtzPE15RGVwZW5kZW5jaWVzPigpO1xuICogbG9nZ2VyLmluZm8oJ3NldHRpbmcgdXAnKTtcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gbXlXb3JrZmxvdygpIHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBhc3luYyBleGVjdXRlKCkge1xuICogICAgICAgbG9nZ2VyLmluZm8oXCJoZXkgaG9cIik7XG4gKiAgICAgICBsb2dnZXIuZXJyb3IoXCJsZXRzIGdvXCIpO1xuICogICAgIH1cbiAqICAgfTtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJveHlTaW5rczxUIGV4dGVuZHMgU2lua3M+KCk6IFQge1xuICByZXR1cm4gbmV3IFByb3h5KFxuICAgIHt9LFxuICAgIHtcbiAgICAgIGdldChfLCBpZmFjZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShcbiAgICAgICAgICB7fSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBnZXQoXywgZm5OYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dChcbiAgICAgICAgICAgICAgICAgICdQcm94aWVkIHNpbmtzIGZ1bmN0aW9ucyBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IHdvcmtmbG93SW5mbygpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRvci5zaW5rQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBpZmFjZU5hbWU6IGlmYWNlTmFtZSBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICBmbk5hbWU6IGZuTmFtZSBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAvLyBPbmx5IGF2YWlsYWJsZSBmcm9tIG5vZGUgMTcuXG4gICAgICAgICAgICAgICAgICBhcmdzOiAoZ2xvYmFsVGhpcyBhcyBhbnkpLnN0cnVjdHVyZWRDbG9uZSA/IChnbG9iYWxUaGlzIGFzIGFueSkuc3RydWN0dXJlZENsb25lKGFyZ3MpIDogYXJncyxcbiAgICAgICAgICAgICAgICAgIC8vIENsb25lIHRoZSB3b3JrZmxvd0luZm8gb2JqZWN0IHNvIHRoYXQgYW55IGZ1cnRoZXIgbXV0YXRpb25zIHRvIGl0IGRvZXMgbm90IGdldCByZWZsZWN0ZWQgaW4gc2lua1xuICAgICAgICAgICAgICAgICAgd29ya2Zsb3dJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmluZm8sXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBjbG9uZSBhbnkgc3ViLXByb3BlcnR5IHRoYXQgbWF5IGdldCBtdXRhdGVkIGR1cmluZyB0aGUgbGlmZXNwYW4gb2YgYW4gYWN0aXZhdGlvblxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hBdHRyaWJ1dGVzOiB7IC4uLmluZm8uc2VhcmNoQXR0cmlidXRlcyB9LFxuICAgICAgICAgICAgICAgICAgICBtZW1vOiBpbmZvLm1lbW8gPyB7IC4uLmluZm8ubWVtbyB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICB9XG4gICkgYXMgYW55O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiBgZmAgdGhhdCB3aWxsIGNhdXNlIHRoZSBjdXJyZW50IFdvcmtmbG93IHRvIENvbnRpbnVlQXNOZXcgd2hlbiBjYWxsZWQuXG4gKlxuICogYGZgIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB0aGUgV29ya2Zsb3cgZnVuY3Rpb24gc3VwcGxpZWQgdG8gdHlwZXBhcmFtIGBGYC5cbiAqXG4gKiBPbmNlIGBmYCBpcyBjYWxsZWQsIFdvcmtmbG93IEV4ZWN1dGlvbiBpbW1lZGlhdGVseSBjb21wbGV0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ29udGludWVBc05ld0Z1bmM8RiBleHRlbmRzIFdvcmtmbG93PihcbiAgb3B0aW9ucz86IENvbnRpbnVlQXNOZXdPcHRpb25zXG4pOiAoLi4uYXJnczogUGFyYW1ldGVyczxGPikgPT4gUHJvbWlzZTxuZXZlcj4ge1xuICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dChcbiAgICAnV29ya2Zsb3cuY29udGludWVBc05ldyguLi4pIGFuZCBXb3JrZmxvdy5tYWtlQ29udGludWVBc05ld0Z1bmMoLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJ1xuICApO1xuICBjb25zdCBpbmZvID0gYWN0aXZhdG9yLmluZm87XG4gIGNvbnN0IHsgd29ya2Zsb3dUeXBlLCB0YXNrUXVldWUsIC4uLnJlc3QgfSA9IG9wdGlvbnMgPz8ge307XG4gIGNvbnN0IHJlcXVpcmVkT3B0aW9ucyA9IHtcbiAgICB3b3JrZmxvd1R5cGU6IHdvcmtmbG93VHlwZSA/PyBpbmZvLndvcmtmbG93VHlwZSxcbiAgICB0YXNrUXVldWU6IHRhc2tRdWV1ZSA/PyBpbmZvLnRhc2tRdWV1ZSxcbiAgICAuLi5yZXN0LFxuICB9O1xuXG4gIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxGPik6IFByb21pc2U8bmV2ZXI+ID0+IHtcbiAgICBjb25zdCBmbiA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZCwgJ2NvbnRpbnVlQXNOZXcnLCBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgIGNvbnN0IHsgaGVhZGVycywgYXJncywgb3B0aW9ucyB9ID0gaW5wdXQ7XG4gICAgICB0aHJvdyBuZXcgQ29udGludWVBc05ldyh7XG4gICAgICAgIHdvcmtmbG93VHlwZTogb3B0aW9ucy53b3JrZmxvd1R5cGUsXG4gICAgICAgIGFyZ3VtZW50czogdG9QYXlsb2FkcyhhY3RpdmF0b3IucGF5bG9hZENvbnZlcnRlciwgLi4uYXJncyksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHRhc2tRdWV1ZTogb3B0aW9ucy50YXNrUXVldWUsXG4gICAgICAgIG1lbW86IG9wdGlvbnMubWVtbyAmJiBtYXBUb1BheWxvYWRzKGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyLCBvcHRpb25zLm1lbW8pLFxuICAgICAgICBzZWFyY2hBdHRyaWJ1dGVzOiBvcHRpb25zLnNlYXJjaEF0dHJpYnV0ZXNcbiAgICAgICAgICA/IG1hcFRvUGF5bG9hZHMoc2VhcmNoQXR0cmlidXRlUGF5bG9hZENvbnZlcnRlciwgb3B0aW9ucy5zZWFyY2hBdHRyaWJ1dGVzKVxuICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB3b3JrZmxvd1J1blRpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMud29ya2Zsb3dSdW5UaW1lb3V0KSxcbiAgICAgICAgd29ya2Zsb3dUYXNrVGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy53b3JrZmxvd1Rhc2tUaW1lb3V0KSxcbiAgICAgICAgdmVyc2lvbmluZ0ludGVudDogdmVyc2lvbmluZ0ludGVudFRvUHJvdG8ob3B0aW9ucy52ZXJzaW9uaW5nSW50ZW50KSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBmbih7XG4gICAgICBhcmdzLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgICBvcHRpb25zOiByZXF1aXJlZE9wdGlvbnMsXG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICoge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby9jb25jZXB0cy93aGF0LWlzLWNvbnRpbnVlLWFzLW5ldy8gfCBDb250aW51ZXMtQXMtTmV3fSB0aGUgY3VycmVudCBXb3JrZmxvdyBFeGVjdXRpb25cbiAqIHdpdGggZGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIFNob3J0aGFuZCBmb3IgYG1ha2VDb250aW51ZUFzTmV3RnVuYzxGPigpKC4uLmFyZ3MpYC4gKFNlZToge0BsaW5rIG1ha2VDb250aW51ZUFzTmV3RnVuY30uKVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICpgYGB0c1xuICppbXBvcnQgeyBjb250aW51ZUFzTmV3IH0gZnJvbSAnQHRlbXBvcmFsaW8vd29ya2Zsb3cnO1xuICpcbiAqZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG15V29ya2Zsb3cobjogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gKiAgLy8gLi4uIFdvcmtmbG93IGxvZ2ljXG4gKiAgYXdhaXQgY29udGludWVBc05ldzx0eXBlb2YgbXlXb3JrZmxvdz4obiArIDEpO1xuICp9XG4gKmBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGludWVBc05ldzxGIGV4dGVuZHMgV29ya2Zsb3c+KC4uLmFyZ3M6IFBhcmFtZXRlcnM8Rj4pOiBQcm9taXNlPG5ldmVyPiB7XG4gIHJldHVybiBtYWtlQ29udGludWVBc05ld0Z1bmMoKSguLi5hcmdzKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBSRkMgY29tcGxpYW50IFY0IHV1aWQuXG4gKiBVc2VzIHRoZSB3b3JrZmxvdydzIGRldGVybWluaXN0aWMgUFJORyBtYWtpbmcgaXQgc2FmZSBmb3IgdXNlIHdpdGhpbiBhIHdvcmtmbG93LlxuICogVGhpcyBmdW5jdGlvbiBpcyBjcnlwdG9ncmFwaGljYWxseSBpbnNlY3VyZS5cbiAqIFNlZSB0aGUge0BsaW5rIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkIHwgc3RhY2tvdmVyZmxvdyBkaXNjdXNzaW9ufS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV1aWQ0KCk6IHN0cmluZyB7XG4gIC8vIFJldHVybiB0aGUgaGV4YWRlY2ltYWwgdGV4dCByZXByZXNlbnRhdGlvbiBvZiBudW1iZXIgYG5gLCBwYWRkZWQgd2l0aCB6ZXJvZXMgdG8gYmUgb2YgbGVuZ3RoIGBwYFxuICBjb25zdCBobyA9IChuOiBudW1iZXIsIHA6IG51bWJlcikgPT4gbi50b1N0cmluZygxNikucGFkU3RhcnQocCwgJzAnKTtcbiAgLy8gQ3JlYXRlIGEgdmlldyBiYWNrZWQgYnkgYSAxNi1ieXRlIGJ1ZmZlclxuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxNikpO1xuICAvLyBGaWxsIGJ1ZmZlciB3aXRoIHJhbmRvbSB2YWx1ZXNcbiAgdmlldy5zZXRVaW50MzIoMCwgKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMCkgPj4+IDApO1xuICB2aWV3LnNldFVpbnQzMig0LCAoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gIHZpZXcuc2V0VWludDMyKDgsIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgdmlldy5zZXRVaW50MzIoMTIsIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgLy8gUGF0Y2ggdGhlIDZ0aCBieXRlIHRvIHJlZmxlY3QgYSB2ZXJzaW9uIDQgVVVJRFxuICB2aWV3LnNldFVpbnQ4KDYsICh2aWV3LmdldFVpbnQ4KDYpICYgMHhmKSB8IDB4NDApO1xuICAvLyBQYXRjaCB0aGUgOHRoIGJ5dGUgdG8gcmVmbGVjdCBhIHZhcmlhbnQgMSBVVUlEICh2ZXJzaW9uIDQgVVVJRHMgYXJlKVxuICB2aWV3LnNldFVpbnQ4KDgsICh2aWV3LmdldFVpbnQ4KDgpICYgMHgzZikgfCAweDgwKTtcbiAgLy8gQ29tcGlsZSB0aGUgY2Fub25pY2FsIHRleHR1YWwgZm9ybSBmcm9tIHRoZSBhcnJheSBkYXRhXG4gIHJldHVybiBgJHtobyh2aWV3LmdldFVpbnQzMigwKSwgOCl9LSR7aG8odmlldy5nZXRVaW50MTYoNCksIDQpfS0ke2hvKHZpZXcuZ2V0VWludDE2KDYpLCA0KX0tJHtobyhcbiAgICB2aWV3LmdldFVpbnQxNig4KSxcbiAgICA0XG4gICl9LSR7aG8odmlldy5nZXRVaW50MzIoMTApLCA4KX0ke2hvKHZpZXcuZ2V0VWludDE2KDE0KSwgNCl9YDtcbn1cblxuLyoqXG4gKiBQYXRjaCBvciB1cGdyYWRlIHdvcmtmbG93IGNvZGUgYnkgY2hlY2tpbmcgb3Igc3RhdGluZyB0aGF0IHRoaXMgd29ya2Zsb3cgaGFzIGEgY2VydGFpbiBwYXRjaC5cbiAqXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby90eXBlc2NyaXB0L3ZlcnNpb25pbmcgfCBkb2NzIHBhZ2V9IGZvciBpbmZvLlxuICpcbiAqIElmIHRoZSB3b3JrZmxvdyBpcyByZXBsYXlpbmcgYW4gZXhpc3RpbmcgaGlzdG9yeSwgdGhlbiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBpZiB0aGF0XG4gKiBoaXN0b3J5IHdhcyBwcm9kdWNlZCBieSBhIHdvcmtlciB3aGljaCBhbHNvIGhhZCBhIGBwYXRjaGVkYCBjYWxsIHdpdGggdGhlIHNhbWUgYHBhdGNoSWRgLlxuICogSWYgdGhlIGhpc3Rvcnkgd2FzIHByb2R1Y2VkIGJ5IGEgd29ya2VyICp3aXRob3V0KiBzdWNoIGEgY2FsbCwgdGhlbiBpdCB3aWxsIHJldHVybiBmYWxzZS5cbiAqXG4gKiBJZiB0aGUgd29ya2Zsb3cgaXMgbm90IGN1cnJlbnRseSByZXBsYXlpbmcsIHRoZW4gdGhpcyBjYWxsICphbHdheXMqIHJldHVybnMgdHJ1ZS5cbiAqXG4gKiBZb3VyIHdvcmtmbG93IGNvZGUgc2hvdWxkIHJ1biB0aGUgXCJuZXdcIiBjb2RlIGlmIHRoaXMgcmV0dXJucyB0cnVlLCBpZiBpdCByZXR1cm5zIGZhbHNlLCB5b3VcbiAqIHNob3VsZCBydW4gdGhlIFwib2xkXCIgY29kZS4gQnkgZG9pbmcgdGhpcywgeW91IGNhbiBtYWludGFpbiBkZXRlcm1pbmlzbS5cbiAqXG4gKiBAcGFyYW0gcGF0Y2hJZCBBbiBpZGVudGlmaWVyIHRoYXQgc2hvdWxkIGJlIHVuaXF1ZSB0byB0aGlzIHBhdGNoLiBJdCBpcyBPSyB0byB1c2UgbXVsdGlwbGVcbiAqIGNhbGxzIHdpdGggdGhlIHNhbWUgSUQsIHdoaWNoIG1lYW5zIGFsbCBzdWNoIGNhbGxzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoZWQocGF0Y2hJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBwYXRjaEludGVybmFsKHBhdGNoSWQsIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZSB0aGF0IGEgcGF0Y2ggaXMgYmVpbmcgcGhhc2VkIG91dC5cbiAqXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby90eXBlc2NyaXB0L3ZlcnNpb25pbmcgfCBkb2NzIHBhZ2V9IGZvciBpbmZvLlxuICpcbiAqIFdvcmtmbG93cyB3aXRoIHRoaXMgY2FsbCBtYXkgYmUgZGVwbG95ZWQgYWxvbmdzaWRlIHdvcmtmbG93cyB3aXRoIGEge0BsaW5rIHBhdGNoZWR9IGNhbGwsIGJ1dFxuICogdGhleSBtdXN0ICpub3QqIGJlIGRlcGxveWVkIHdoaWxlIGFueSB3b3JrZXJzIHN0aWxsIGV4aXN0IHJ1bm5pbmcgb2xkIGNvZGUgd2l0aG91dCBhXG4gKiB7QGxpbmsgcGF0Y2hlZH0gY2FsbCwgb3IgYW55IHJ1bnMgd2l0aCBoaXN0b3JpZXMgcHJvZHVjZWQgYnkgc3VjaCB3b3JrZXJzIGV4aXN0LiBJZiBlaXRoZXIga2luZFxuICogb2Ygd29ya2VyIGVuY291bnRlcnMgYSBoaXN0b3J5IHByb2R1Y2VkIGJ5IHRoZSBvdGhlciwgdGhlaXIgYmVoYXZpb3IgaXMgdW5kZWZpbmVkLlxuICpcbiAqIE9uY2UgYWxsIGxpdmUgd29ya2Zsb3cgcnVucyBoYXZlIGJlZW4gcHJvZHVjZWQgYnkgd29ya2VycyB3aXRoIHRoaXMgY2FsbCwgeW91IGNhbiBkZXBsb3kgd29ya2Vyc1xuICogd2hpY2ggYXJlIGZyZWUgb2YgZWl0aGVyIGtpbmQgb2YgcGF0Y2ggY2FsbCBmb3IgdGhpcyBJRC4gV29ya2VycyB3aXRoIGFuZCB3aXRob3V0IHRoaXMgY2FsbFxuICogbWF5IGNvZXhpc3QsIGFzIGxvbmcgYXMgdGhleSBhcmUgYm90aCBydW5uaW5nIHRoZSBcIm5ld1wiIGNvZGUuXG4gKlxuICogQHBhcmFtIHBhdGNoSWQgQW4gaWRlbnRpZmllciB0aGF0IHNob3VsZCBiZSB1bmlxdWUgdG8gdGhpcyBwYXRjaC4gSXQgaXMgT0sgdG8gdXNlIG11bHRpcGxlXG4gKiBjYWxscyB3aXRoIHRoZSBzYW1lIElELCB3aGljaCBtZWFucyBhbGwgc3VjaCBjYWxscyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGVQYXRjaChwYXRjaElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgcGF0Y2hJbnRlcm5hbChwYXRjaElkLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gcGF0Y2hJbnRlcm5hbChwYXRjaElkOiBzdHJpbmcsIGRlcHJlY2F0ZWQ6IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoXG4gICAgJ1dvcmtmbG93LnBhdGNoKC4uLikgYW5kIFdvcmtmbG93LmRlcHJlY2F0ZVBhdGNoIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4nXG4gICk7XG4gIC8vIFBhdGNoIG9wZXJhdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGludGVyY2VwdGlvbiBhdCB0aGUgbW9tZW50LCBpZiBpdCBkaWQsXG4gIC8vIHRoaXMgd291bGQgYmUgdGhlIHBsYWNlIHRvIHN0YXJ0IHRoZSBpbnRlcmNlcHRpb24gY2hhaW5cblxuICBpZiAoYWN0aXZhdG9yLndvcmtmbG93ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXJyb3IoJ1BhdGNoZXMgY2Fubm90IGJlIHVzZWQgYmVmb3JlIFdvcmtmbG93IHN0YXJ0cycpO1xuICB9XG4gIGNvbnN0IHVzZVBhdGNoID0gIWFjdGl2YXRvci5pbmZvLnVuc2FmZS5pc1JlcGxheWluZyB8fCBhY3RpdmF0b3Iua25vd25QcmVzZW50UGF0Y2hlcy5oYXMocGF0Y2hJZCk7XG4gIC8vIEF2b2lkIHNlbmRpbmcgY29tbWFuZHMgZm9yIHBhdGNoZXMgY29yZSBhbHJlYWR5IGtub3dzIGFib3V0LlxuICAvLyBUaGlzIG9wdGltaXphdGlvbiBlbmFibGVzIGRldmVsb3BtZW50IG9mIGF1dG9tYXRpYyBwYXRjaGluZyB0b29scy5cbiAgaWYgKHVzZVBhdGNoICYmICFhY3RpdmF0b3Iuc2VudFBhdGNoZXMuaGFzKHBhdGNoSWQpKSB7XG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHNldFBhdGNoTWFya2VyOiB7IHBhdGNoSWQsIGRlcHJlY2F0ZWQgfSxcbiAgICB9KTtcbiAgICBhY3RpdmF0b3Iuc2VudFBhdGNoZXMuYWRkKHBhdGNoSWQpO1xuICB9XG4gIHJldHVybiB1c2VQYXRjaDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYGZuYCBldmFsdWF0ZXMgdG8gYHRydWVgIG9yIGB0aW1lb3V0YCBleHBpcmVzLlxuICpcbiAqIEBwYXJhbSB0aW1lb3V0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAqXG4gKiBAcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb25kaXRpb24gd2FzIHRydWUgYmVmb3JlIHRoZSB0aW1lb3V0IGV4cGlyZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmRpdGlvbihmbjogKCkgPT4gYm9vbGVhbiwgdGltZW91dDogRHVyYXRpb24pOiBQcm9taXNlPGJvb2xlYW4+O1xuXG4vKipcbiAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBgZm5gIGV2YWx1YXRlcyB0byBgdHJ1ZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25kaXRpb24oZm46ICgpID0+IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29uZGl0aW9uKGZuOiAoKSA9PiBib29sZWFuLCB0aW1lb3V0PzogRHVyYXRpb24pOiBQcm9taXNlPHZvaWQgfCBib29sZWFuPiB7XG4gIGFzc2VydEluV29ya2Zsb3dDb250ZXh0KCdXb3JrZmxvdy5jb25kaXRpb24oLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJyk7XG4gIC8vIFByaW9yIHRvIDEuNS4wLCBgY29uZGl0aW9uKGZuLCAwKWAgd2FzIHRyZWF0ZWQgYXMgZXF1aXZhbGVudCB0byBgY29uZGl0aW9uKGZuLCB1bmRlZmluZWQpYFxuICBpZiAodGltZW91dCA9PT0gMCAmJiAhcGF0Y2hlZChDT05ESVRJT05fMF9QQVRDSCkpIHtcbiAgICByZXR1cm4gY29uZGl0aW9uSW5uZXIoZm4pO1xuICB9XG4gIGlmICh0eXBlb2YgdGltZW91dCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHRpbWVvdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIENhbmNlbGxhdGlvblNjb3BlLmNhbmNlbGxhYmxlKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJhY2UoW3NsZWVwKHRpbWVvdXQpLnRoZW4oKCkgPT4gZmFsc2UpLCBjb25kaXRpb25Jbm5lcihmbikudGhlbigoKSA9PiB0cnVlKV0pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb25kaXRpb25Jbm5lcihmbik7XG59XG5cbmZ1bmN0aW9uIGNvbmRpdGlvbklubmVyKGZuOiAoKSA9PiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHNjb3BlID0gQ2FuY2VsbGF0aW9uU2NvcGUuY3VycmVudCgpO1xuICAgIGlmIChzY29wZS5jb25zaWRlcmVkQ2FuY2VsbGVkKSB7XG4gICAgICB1bnRyYWNrUHJvbWlzZShzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2gocmVqZWN0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VxID0gYWN0aXZhdG9yLm5leHRTZXFzLmNvbmRpdGlvbisrO1xuICAgIGlmIChzY29wZS5jYW5jZWxsYWJsZSkge1xuICAgICAgdW50cmFja1Byb21pc2UoXG4gICAgICAgIHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgYWN0aXZhdG9yLmJsb2NrZWRDb25kaXRpb25zLmRlbGV0ZShzZXEpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBFYWdlciBldmFsdWF0aW9uXG4gICAgaWYgKGZuKCkpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhY3RpdmF0b3IuYmxvY2tlZENvbmRpdGlvbnMuc2V0KHNlcSwgeyBmbiwgcmVzb2x2ZSB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogRGVmaW5lIGEgc2lnbmFsIG1ldGhvZCBmb3IgYSBXb3JrZmxvdy5cbiAqXG4gKiBEZWZpbml0aW9ucyBhcmUgdXNlZCB0byByZWdpc3RlciBoYW5kbGVyIGluIHRoZSBXb3JrZmxvdyB2aWEge0BsaW5rIHNldEhhbmRsZXJ9IGFuZCB0byBzaWduYWwgV29ya2Zsb3dzIHVzaW5nIGEge0BsaW5rIFdvcmtmbG93SGFuZGxlfSwge0BsaW5rIENoaWxkV29ya2Zsb3dIYW5kbGV9IG9yIHtAbGluayBFeHRlcm5hbFdvcmtmbG93SGFuZGxlfS5cbiAqIERlZmluaXRpb25zIGNhbiBiZSByZXVzZWQgaW4gbXVsdGlwbGUgV29ya2Zsb3dzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lU2lnbmFsPEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdLCBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihcbiAgbmFtZTogTmFtZVxuKTogU2lnbmFsRGVmaW5pdGlvbjxBcmdzLCBOYW1lPiB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3NpZ25hbCcsXG4gICAgbmFtZSxcbiAgfSBhcyBTaWduYWxEZWZpbml0aW9uPEFyZ3MsIE5hbWU+O1xufVxuXG4vKipcbiAqIERlZmluZSBhIHF1ZXJ5IG1ldGhvZCBmb3IgYSBXb3JrZmxvdy5cbiAqXG4gKiBEZWZpbml0aW9ucyBhcmUgdXNlZCB0byByZWdpc3RlciBoYW5kbGVyIGluIHRoZSBXb3JrZmxvdyB2aWEge0BsaW5rIHNldEhhbmRsZXJ9IGFuZCB0byBxdWVyeSBXb3JrZmxvd3MgdXNpbmcgYSB7QGxpbmsgV29ya2Zsb3dIYW5kbGV9LlxuICogRGVmaW5pdGlvbnMgY2FuIGJlIHJldXNlZCBpbiBtdWx0aXBsZSBXb3JrZmxvd3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVRdWVyeTxSZXQsIEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdLCBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihcbiAgbmFtZTogTmFtZVxuKTogUXVlcnlEZWZpbml0aW9uPFJldCwgQXJncywgTmFtZT4ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdxdWVyeScsXG4gICAgbmFtZSxcbiAgfSBhcyBRdWVyeURlZmluaXRpb248UmV0LCBBcmdzLCBOYW1lPjtcbn1cblxuLyoqXG4gKiBTZXQgYSBoYW5kbGVyIGZ1bmN0aW9uIGZvciBhIFdvcmtmbG93IHF1ZXJ5IG9yIHNpZ25hbC5cbiAqXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgYSBnaXZlbiBzaWduYWwgb3IgcXVlcnkgbmFtZSB0aGUgbGFzdCBoYW5kbGVyIHdpbGwgb3ZlcndyaXRlIGFueSBwcmV2aW91cyBjYWxscy5cbiAqXG4gKiBAcGFyYW0gZGVmIGEge0BsaW5rIFNpZ25hbERlZmluaXRpb259IG9yIHtAbGluayBRdWVyeURlZmluaXRpb259IGFzIHJldHVybmVkIGJ5IHtAbGluayBkZWZpbmVTaWduYWx9IG9yIHtAbGluayBkZWZpbmVRdWVyeX0gcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGhhbmRsZXIgYSBjb21wYXRpYmxlIGhhbmRsZXIgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBkZWZpbml0aW9uIG9yIGB1bmRlZmluZWRgIHRvIHVuc2V0IHRoZSBoYW5kbGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0SGFuZGxlcjxSZXQsIEFyZ3MgZXh0ZW5kcyBhbnlbXSwgVCBleHRlbmRzIFNpZ25hbERlZmluaXRpb248QXJncz4gfCBRdWVyeURlZmluaXRpb248UmV0LCBBcmdzPj4oXG4gIGRlZjogVCxcbiAgaGFuZGxlcjogSGFuZGxlcjxSZXQsIEFyZ3MsIFQ+IHwgdW5kZWZpbmVkXG4pOiB2b2lkIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoJ1dvcmtmbG93LnNldEhhbmRsZXIoLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJyk7XG4gIGlmIChkZWYudHlwZSA9PT0gJ3NpZ25hbCcpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFjdGl2YXRvci5zaWduYWxIYW5kbGVycy5zZXQoZGVmLm5hbWUsIGhhbmRsZXIgYXMgYW55KTtcbiAgICAgIGFjdGl2YXRvci5kaXNwYXRjaEJ1ZmZlcmVkU2lnbmFscygpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9PSBudWxsKSB7XG4gICAgICBhY3RpdmF0b3Iuc2lnbmFsSGFuZGxlcnMuZGVsZXRlKGRlZi5uYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaGFuZGxlciB0byBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciAndW5kZWZpbmVkJy4gR290OiAnJHt0eXBlb2YgaGFuZGxlcn0nYCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRlZi50eXBlID09PSAncXVlcnknKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhY3RpdmF0b3IucXVlcnlIYW5kbGVycy5zZXQoZGVmLm5hbWUsIGhhbmRsZXIgYXMgYW55KTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPT0gbnVsbCkge1xuICAgICAgYWN0aXZhdG9yLnF1ZXJ5SGFuZGxlcnMuZGVsZXRlKGRlZi5uYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaGFuZGxlciB0byBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciAndW5kZWZpbmVkJy4gR290OiAnJHt0eXBlb2YgaGFuZGxlcn0nYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZGVmaW5pdGlvbiB0eXBlOiAkeyhkZWYgYXMgYW55KS50eXBlfWApO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGEgc2lnbmFsIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGhhbmRsZSBzaWduYWxzIGNhbGxzIGZvciBub24tcmVnaXN0ZXJlZCBzaWduYWwgbmFtZXMuXG4gKlxuICogU2lnbmFscyBhcmUgZGlzcGF0Y2hlZCB0byB0aGUgZGVmYXVsdCBzaWduYWwgaGFuZGxlciBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHdlcmUgYWNjZXB0ZWQgYnkgdGhlIHNlcnZlci5cbiAqXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgYSBnaXZlbiBzaWduYWwgb3IgcXVlcnkgbmFtZSB0aGUgbGFzdCBoYW5kbGVyIHdpbGwgb3ZlcndyaXRlIGFueSBwcmV2aW91cyBjYWxscy5cbiAqXG4gKiBAcGFyYW0gaGFuZGxlciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBoYW5kbGUgc2lnbmFscyBmb3Igbm9uLXJlZ2lzdGVyZWQgc2lnbmFsIG5hbWVzLCBvciBgdW5kZWZpbmVkYCB0byB1bnNldCB0aGUgaGFuZGxlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldERlZmF1bHRTaWduYWxIYW5kbGVyKGhhbmRsZXI6IERlZmF1bHRTaWduYWxIYW5kbGVyIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFxuICAgICdXb3JrZmxvdy5zZXREZWZhdWx0U2lnbmFsSGFuZGxlciguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4nXG4gICk7XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFjdGl2YXRvci5kZWZhdWx0U2lnbmFsSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgYWN0aXZhdG9yLmRpc3BhdGNoQnVmZmVyZWRTaWduYWxzKCk7XG4gIH0gZWxzZSBpZiAoaGFuZGxlciA9PSBudWxsKSB7XG4gICAgYWN0aXZhdG9yLmRlZmF1bHRTaWduYWxIYW5kbGVyID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGhhbmRsZXIgdG8gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgJ3VuZGVmaW5lZCcuIEdvdDogJyR7dHlwZW9mIGhhbmRsZXJ9J2ApO1xuICB9XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGlzIFdvcmtmbG93J3MgU2VhcmNoIEF0dHJpYnV0ZXMgYnkgbWVyZ2luZyB0aGUgcHJvdmlkZWQgYHNlYXJjaEF0dHJpYnV0ZXNgIHdpdGggdGhlIGV4aXN0aW5nIFNlYXJjaFxuICogQXR0cmlidXRlcywgYHdvcmtmbG93SW5mbygpLnNlYXJjaEF0dHJpYnV0ZXNgLlxuICpcbiAqIEZvciBleGFtcGxlLCB0aGlzIFdvcmtmbG93IGNvZGU6XG4gKlxuICogYGBgdHNcbiAqIHVwc2VydFNlYXJjaEF0dHJpYnV0ZXMoe1xuICogICBDdXN0b21JbnRGaWVsZDogWzFdLFxuICogICBDdXN0b21Cb29sRmllbGQ6IFt0cnVlXVxuICogfSk7XG4gKiB1cHNlcnRTZWFyY2hBdHRyaWJ1dGVzKHtcbiAqICAgQ3VzdG9tSW50RmllbGQ6IFs0Ml0sXG4gKiAgIEN1c3RvbUtleXdvcmRGaWVsZDogWydkdXJhYmxlIGNvZGUnLCAnaXMgZ3JlYXQnXVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiB3b3VsZCByZXN1bHQgaW4gdGhlIFdvcmtmbG93IGhhdmluZyB0aGVzZSBTZWFyY2ggQXR0cmlidXRlczpcbiAqXG4gKiBgYGB0c1xuICoge1xuICogICBDdXN0b21JbnRGaWVsZDogWzQyXSxcbiAqICAgQ3VzdG9tQm9vbEZpZWxkOiBbdHJ1ZV0sXG4gKiAgIEN1c3RvbUtleXdvcmRGaWVsZDogWydkdXJhYmxlIGNvZGUnLCAnaXMgZ3JlYXQnXVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNlYXJjaEF0dHJpYnV0ZXMgVGhlIFJlY29yZCB0byBtZXJnZS4gVXNlIGEgdmFsdWUgb2YgYFtdYCB0byBjbGVhciBhIFNlYXJjaCBBdHRyaWJ1dGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cHNlcnRTZWFyY2hBdHRyaWJ1dGVzKHNlYXJjaEF0dHJpYnV0ZXM6IFNlYXJjaEF0dHJpYnV0ZXMpOiB2b2lkIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoXG4gICAgJ1dvcmtmbG93LnVwc2VydFNlYXJjaEF0dHJpYnV0ZXMoLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJ1xuICApO1xuXG4gIGNvbnN0IG1lcmdlZFNlYXJjaEF0dHJpYnV0ZXMgPSB7IC4uLmFjdGl2YXRvci5pbmZvLnNlYXJjaEF0dHJpYnV0ZXMsIC4uLnNlYXJjaEF0dHJpYnV0ZXMgfTtcbiAgaWYgKCFtZXJnZWRTZWFyY2hBdHRyaWJ1dGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZWFyY2hBdHRyaWJ1dGVzIG11c3QgYmUgYSBub24tbnVsbCBTZWFyY2hBdHRyaWJ1dGVzJyk7XG4gIH1cblxuICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgIHVwc2VydFdvcmtmbG93U2VhcmNoQXR0cmlidXRlczoge1xuICAgICAgc2VhcmNoQXR0cmlidXRlczogbWFwVG9QYXlsb2FkcyhzZWFyY2hBdHRyaWJ1dGVQYXlsb2FkQ29udmVydGVyLCBzZWFyY2hBdHRyaWJ1dGVzKSxcbiAgICB9LFxuICB9KTtcblxuICBhY3RpdmF0b3IuaW5mby5zZWFyY2hBdHRyaWJ1dGVzID0gbWVyZ2VkU2VhcmNoQXR0cmlidXRlcztcbn1cblxuZXhwb3J0IGNvbnN0IHN0YWNrVHJhY2VRdWVyeSA9IGRlZmluZVF1ZXJ5PHN0cmluZz4oJ19fc3RhY2tfdHJhY2UnKTtcbmV4cG9ydCBjb25zdCBlbmhhbmNlZFN0YWNrVHJhY2VRdWVyeSA9IGRlZmluZVF1ZXJ5PEVuaGFuY2VkU3RhY2tUcmFjZT4oJ19fZW5oYW5jZWRfc3RhY2tfdHJhY2UnKTtcblxuY29uc3QgbG9nZ2VyU2lua3MgPSBwcm94eVNpbmtzPExvZ2dlclNpbmtzPigpO1xuXG4vKipcbiAqIFN5bWJvbCB1c2VkIGJ5IHRoZSBTREsgbG9nZ2VyIHRvIGV4dHJhY3QgYSB0aW1lc3RhbXAgZnJvbSBsb2cgYXR0cmlidXRlcy5cbiAqIEFsc28gZGVmaW5lZCBpbiBgd29ya2VyL2xvZ2dlci50c2AgLSBpbnRlbnRpb25hbGx5IG5vdCBzaGFyZWQuXG4gKi9cbmNvbnN0IExvZ1RpbWVzdGFtcCA9IFN5bWJvbC5mb3IoJ2xvZ190aW1lc3RhbXAnKTtcblxuLyoqXG4gKiBEZWZhdWx0IHdvcmtmbG93IGxvZ2dlci5cbiAqIFRoaXMgbG9nZ2VyIGlzIHJlcGxheS1hd2FyZSBhbmQgd2lsbCBvbWl0IGxvZyBtZXNzYWdlcyBvbiB3b3JrZmxvdyByZXBsYXkuXG4gKiBUaGUgbWVzc2FnZXMgZW1pdHRlZCBieSB0aGlzIGxvZ2dlciBhcmUgZnVubmVsbGVkIHRvIHRoZSB3b3JrZXIncyBgZGVmYXVsdFNpbmtzYCwgd2hpY2ggYXJlIGluc3RhbGxlZCBieSBkZWZhdWx0LlxuICpcbiAqIE5vdGUgdGhhdCBzaW5jZSBzaW5rcyBhcmUgdXNlZCB0byBwb3dlciB0aGlzIGxvZ2dlciwgYW55IGxvZyBhdHRyaWJ1dGVzIG11c3QgYmUgdHJhbnNmZXJhYmxlIHZpYSB0aGVcbiAqIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL3dvcmtlcl90aHJlYWRzLmh0bWwjd29ya2VyX3RocmVhZHNfcG9ydF9wb3N0bWVzc2FnZV92YWx1ZV90cmFuc2Zlcmxpc3QgfCBwb3N0TWVzc2FnZX1cbiAqIEFQSS5cbiAqXG4gKiBgZGVmYXVsdFNpbmtzYCBhY2NlcHRzIGEgdXNlciBsb2dnZXIgYW5kIGRlZmF1bHRzIHRvIHRoZSBgUnVudGltZWAncyBsb2dnZXIuXG4gKlxuICogU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBgV29ya2VyT3B0aW9uc2AsIGBkZWZhdWx0U2lua3NgLCBhbmQgYFJ1bnRpbWVgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgY29uc3QgbG9nOiBMb2dnZXJTaW5rc1snZGVmYXVsdFdvcmtlckxvZ2dlciddID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAoWyd0cmFjZScsICdkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXSBhcyBBcnJheTxrZXlvZiBMb2dnZXJTaW5rc1snZGVmYXVsdFdvcmtlckxvZ2dlciddPikubWFwKChsZXZlbCkgPT4ge1xuICAgIHJldHVybiBbXG4gICAgICBsZXZlbCxcbiAgICAgIChtZXNzYWdlOiBzdHJpbmcsIGF0dHJzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pID0+IHtcbiAgICAgICAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoJ1dvcmtmbG93LmxvZyguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4nKTtcbiAgICAgICAgY29uc3QgZ2V0TG9nQXR0cmlidXRlcyA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZCwgJ2dldExvZ0F0dHJpYnV0ZXMnLCAoYSkgPT4gYSk7XG4gICAgICAgIHJldHVybiBsb2dnZXJTaW5rcy5kZWZhdWx0V29ya2VyTG9nZ2VyW2xldmVsXShtZXNzYWdlLCB7XG4gICAgICAgICAgLy8gSW5qZWN0IHRoZSBjYWxsIHRpbWUgaW4gbmFub3NlY29uZCByZXNvbHV0aW9uIGFzIGV4cGVjdGVkIGJ5IHRoZSB3b3JrZXIgbG9nZ2VyLlxuICAgICAgICAgIFtMb2dUaW1lc3RhbXBdOiBhY3RpdmF0b3IuZ2V0VGltZU9mRGF5KCksXG4gICAgICAgICAgLi4uZ2V0TG9nQXR0cmlidXRlcyh7fSksXG4gICAgICAgICAgLi4uYXR0cnMsXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICBdO1xuICB9KVxuKSBhcyBhbnk7XG5cbmZ1bmN0aW9uIGFzc2VydEluV29ya2Zsb3dDb250ZXh0KG1lc3NhZ2U6IHN0cmluZyk6IEFjdGl2YXRvciB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IG1heWJlR2V0QWN0aXZhdG9yKCk7XG4gIGlmIChhY3RpdmF0b3IgPT0gbnVsbCkgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gYWN0aXZhdG9yO1xufVxuIiwiaW1wb3J0IHtwcm94eUFjdGl2aXRpZXN9IGZyb20gXCJAdGVtcG9yYWxpby93b3JrZmxvd1wiO1xuaW1wb3J0IHR5cGUgKiBhcyBhY3Rpdml0aWVzIGZyb20gJy4vYWN0aXZpdGllcydcbmNvbnN0IHtcbiAgaGVsbG9Xb3JsZCxcbiAgZ2V0R2FzUHJpY2Vcbn0gPSBwcm94eUFjdGl2aXRpZXM8dHlwZW9mIGFjdGl2aXRpZXM+KHtcbiAgcmV0cnk6IHtcbiAgICBpbml0aWFsSW50ZXJ2YWw6ICc1MCBtaWxsaXNlY29uZHMnLFxuICAgIG1heGltdW1BdHRlbXB0czogNSxcbiAgfSxcblxuICBzdGFydFRvQ2xvc2VUaW1lb3V0OiAnMTIwOTYwMCBzZWNvbmRzJywgLy8gNyoyNCBtaW51dGVzXG59KVxuXG5leHBvcnQgY29uc3QgZ2FzUHJpY2VXb3JrZmxvdyA9IGFzeW5jIChuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRHYXNQcmljZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBIZWxwZXJzLlxuY29uc3QgcyA9IDEwMDA7XG5jb25zdCBtID0gcyAqIDYwO1xuY29uc3QgaCA9IG0gKiA2MDtcbmNvbnN0IGQgPSBoICogMjQ7XG5jb25zdCB3ID0gZCAqIDc7XG5jb25zdCB5ID0gZCAqIDM2NS4yNTtcbmZ1bmN0aW9uIG1zKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM/LmxvbmcgPyBmbXRMb25nKHZhbHVlKSA6IGZtdFNob3J0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGlzIG5vdCBhIHN0cmluZyBvciBudW1iZXIuJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gaXNFcnJvcihlcnJvcilcbiAgICAgICAgICAgID8gYCR7ZXJyb3IubWVzc2FnZX0uIHZhbHVlPSR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWBcbiAgICAgICAgICAgIDogJ0FuIHVua25vd24gZXJyb3IgaGFzIG9jY3VyZWQuJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbn1cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICovXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGV4Y2VlZHMgdGhlIG1heGltdW0gbGVuZ3RoIG9mIDEwMCBjaGFyYWN0ZXJzLicpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3QgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgIGNvbnN0IHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgY2FzZSAneXJzJzpcbiAgICAgICAgY2FzZSAneXInOlxuICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgIHJldHVybiBuICogeTtcbiAgICAgICAgY2FzZSAnd2Vla3MnOlxuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICByZXR1cm4gbiAqIHc7XG4gICAgICAgIGNhc2UgJ2RheXMnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIHJldHVybiBuICogZDtcbiAgICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgY2FzZSAnaHJzJzpcbiAgICAgICAgY2FzZSAnaHInOlxuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIHJldHVybiBuICogaDtcbiAgICAgICAgY2FzZSAnbWludXRlcyc6XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgIGNhc2UgJ21pbnMnOlxuICAgICAgICBjYXNlICdtaW4nOlxuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIHJldHVybiBuICogbTtcbiAgICAgICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgIGNhc2UgJ3NlY3MnOlxuICAgICAgICBjYXNlICdzZWMnOlxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHJldHVybiBuICogcztcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICBjYXNlICdtc2Vjcyc6XG4gICAgICAgIGNhc2UgJ21zZWMnOlxuICAgICAgICBjYXNlICdtcyc6XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIG9jY3VyLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdW5pdCAke3R5cGV9IHdhcyBtYXRjaGVkLCBidXQgbm8gbWF0Y2hpbmcgY2FzZSBleGlzdHMuYCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gbXM7XG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqL1xuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgICBjb25zdCBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgICBpZiAobXNBYnMgPj0gZCkge1xuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChtcyAvIGQpfWRgO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gaCkge1xuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChtcyAvIGgpfWhgO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gbSkge1xuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChtcyAvIG0pfW1gO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gcykge1xuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChtcyAvIHMpfXNgO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bXN9bXNgO1xufVxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqL1xuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICAgIGNvbnN0IG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICAgIGlmIChtc0FicyA+PSBkKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gICAgfVxuICAgIGlmIChtc0FicyA+PSBoKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gbSkge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gcykge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bXN9IG1zYDtcbn1cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgICBjb25zdCBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gICAgcmV0dXJuIGAke01hdGgucm91bmQobXMgLyBuKX0gJHtuYW1lfSR7aXNQbHVyYWwgPyAncycgOiAnJ31gO1xufVxuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIGVycm9ycy5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcihlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdtZXNzYWdlJyBpbiBlcnJvcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbiIsIi8vIEdFTkVSQVRFRCBGSUxFLiBETyBOT1QgRURJVC5cbnZhciBMb25nID0gKGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuICBcbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9yc1xuICAgKiBDb3B5cmlnaHQgMjAyMCBEYW5pZWwgV2lydHogLyBUaGUgbG9uZy5qcyBBdXRob3JzLlxuICAgKlxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgKlxuICAgKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAqXG4gICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICpcbiAgICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAgICovXG4gIC8vIFdlYkFzc2VtYmx5IG9wdGltaXphdGlvbnMgdG8gZG8gbmF0aXZlIGk2NCBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aWRlXG4gIHZhciB3YXNtID0gbnVsbDtcbiAgXG4gIHRyeSB7XG4gICAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFswLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDEzLCAyLCA5NiwgMCwgMSwgMTI3LCA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsIDMsIDcsIDYsIDAsIDEsIDEsIDEsIDEsIDEsIDYsIDYsIDEsIDEyNywgMSwgNjUsIDAsIDExLCA3LCA1MCwgNiwgMywgMTA5LCAxMTcsIDEwOCwgMCwgMSwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMiwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMywgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNSwgMCwgNCwgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSwgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCwgMTAsIDE5MSwgMSwgNiwgNCwgMCwgMzUsIDAsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjYsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNywgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjksIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEzMCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMV0pKSwge30pLmV4cG9ydHM7XG4gIH0gY2F0Y2ggKGUpIHsvLyBubyB3YXNtIHN1cHBvcnQgOihcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIsIGdpdmVuIGl0cyBsb3cgYW5kIGhpZ2ggMzIgYml0IHZhbHVlcyBhcyAqc2lnbmVkKiBpbnRlZ2Vycy5cbiAgICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXG4gICAqIEBleHBvcnRzIExvbmdcbiAgICogQGNsYXNzIEEgTG9uZyBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgXG4gIFxuICBmdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvdyA9IGxvdyB8IDA7XG4gICAgLyoqXG4gICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICBcbiAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgXG4gICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gIH0gLy8gVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbG9uZyBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cbiAgLy8gV2UgdXNlIDMyLWJpdCBwaWVjZXMgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIHNpemUgb2YgaW50ZWdlcnMgb24gd2hpY2hcbiAgLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXG4gIC8vIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2IGJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcbiAgLy8gbXVsdGlwbGllZCB3aXRoaW4gSmF2YXNjcmlwdCdzIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgb3ZlcmZsb3dcbiAgLy8gb3IgY2hhbmdlIGluIHNpZ24uXG4gIC8vXG4gIC8vIEluIHRoZSBhbGdvcml0aG1zIGJlbG93LCB3ZSBmcmVxdWVudGx5IHJlZHVjZSB0aGUgbmVnYXRpdmUgY2FzZSB0byB0aGVcbiAgLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXG4gIC8vIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxuICAvLyAoLTJeNjMpIGJlY2F1c2UgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUUgKHNpbmNlIDJeNjMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzXG4gIC8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcbiAgLy8gY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvL1xuICAvLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcbiAgLy8gbWV0aG9kcyBvbiB3aGljaCB0aGV5IGRlcGVuZC5cbiAgXG4gIC8qKlxuICAgKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgTG9uZyBvciBub3QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAY29uc3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCBcIl9faXNMb25nX19cIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gaXNMb25nKG9iaikge1xuICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBudW1iZXJcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgXG4gIGZ1bmN0aW9uIGN0ejMyKHZhbHVlKSB7XG4gICAgdmFyIGMgPSBNYXRoLmNsejMyKHZhbHVlICYgLXZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWUgPyAzMSAtIGMgOiBjO1xuICB9XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIExvbmcuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmcuaXNMb25nID0gaXNMb25nO1xuICAvKipcbiAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXG4gICAqIEB0eXBlIHshT2JqZWN0fVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgSU5UX0NBQ0hFID0ge307XG4gIC8qKlxuICAgKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cbiAgICogQHR5cGUgeyFPYmplY3R9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBVSU5UX0NBQ0hFID0ge307XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICBmdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICAgIHZhciBvYmosIGNhY2hlZE9iaiwgY2FjaGU7XG4gIFxuICAgIGlmICh1bnNpZ25lZCkge1xuICAgICAgdmFsdWUgPj4+PSAwO1xuICBcbiAgICAgIGlmIChjYWNoZSA9IDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpIHtcbiAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgIGlmIChjYWNoZWRPYmopIHJldHVybiBjYWNoZWRPYmo7XG4gICAgICB9XG4gIFxuICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIDAsIHRydWUpO1xuICAgICAgaWYgKGNhY2hlKSBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlIHw9IDA7XG4gIFxuICAgICAgaWYgKGNhY2hlID0gLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkge1xuICAgICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgICBpZiAoY2FjaGVkT2JqKSByZXR1cm4gY2FjaGVkT2JqO1xuICAgICAgfVxuICBcbiAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcbiAgICAgIGlmIChjYWNoZSkgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21JbnQgPSBmcm9tSW50O1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICBpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gIFxuICAgIGlmICh1bnNpZ25lZCkge1xuICAgICAgaWYgKHZhbHVlIDwgMCkgcmV0dXJuIFVaRVJPO1xuICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKSByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKSByZXR1cm4gTUlOX1ZBTFVFO1xuICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTCkgcmV0dXJuIE1BWF9WQUxVRTtcbiAgICB9XG4gIFxuICAgIGlmICh2YWx1ZSA8IDApIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpO1xuICAgIHJldHVybiBmcm9tQml0cyh2YWx1ZSAlIFRXT19QV1JfMzJfREJMIHwgMCwgdmFsdWUgLyBUV09fUFdSXzMyX0RCTCB8IDAsIHVuc2lnbmVkKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHNcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICBmdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcbiAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXG4gICAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbUJpdHMgPSBmcm9tQml0cztcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIHBvd19kYmwgPSBNYXRoLnBvdzsgLy8gVXNlZCA0IHRpbWVzICg0KjggdG8gMTUrNClcbiAgXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHRocm93IEVycm9yKCdlbXB0eSBzdHJpbmcnKTtcbiAgXG4gICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XG4gICAgICByYWRpeCA9IHVuc2lnbmVkO1xuICAgICAgdW5zaWduZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5zaWduZWQgPSAhIXVuc2lnbmVkO1xuICAgIH1cbiAgXG4gICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKSByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XG4gICAgdmFyIHA7XG4gICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKSB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7ZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcbiAgICB9IC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xuICAgIHZhciByZXN1bHQgPSBaRVJPO1xuICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xuICBcbiAgICAgIGlmIChzaXplIDwgOCkge1xuICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICBcbiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXG4gICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXG4gICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHJldHVybiBmcm9tTnVtYmVyKHZhbCwgdW5zaWduZWQpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7IC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XG4gIFxuICAgIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAnYm9vbGVhbicgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBmcm9tKiBmdW5jdGlvbiBmb3IgaXRzIHR5cGUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7IC8vIE5PVEU6IHRoZSBjb21waWxlciBzaG91bGQgaW5saW5lIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiZWxvdyBhbmQgdGhlbiByZW1vdmUgdGhlc2UgdmFyaWFibGVzLCBzbyB0aGVyZSBzaG91bGQgYmVcbiAgLy8gbm8gcnVudGltZSBwZW5hbHR5IGZvciB0aGVzZS5cbiAgXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBjb25zdFxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgWkVSTyA9IGZyb21JbnQoMCk7XG4gIC8qKlxuICAgKiBTaWduZWQgemVyby5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuWkVSTyA9IFpFUk87XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XG4gIC8qKlxuICAgKiBVbnNpZ25lZCB6ZXJvLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5VWkVSTyA9IFVaRVJPO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgT05FID0gZnJvbUludCgxKTtcbiAgLyoqXG4gICAqIFNpZ25lZCBvbmUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLk9ORSA9IE9ORTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xuICAvKipcbiAgICogVW5zaWduZWQgb25lLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5VT05FID0gVU9ORTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcbiAgLyoqXG4gICAqIFNpZ25lZCBuZWdhdGl2ZSBvbmUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLk5FR19PTkUgPSBORUdfT05FO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4N0ZGRkZGRkYgfCAwLCBmYWxzZSk7XG4gIC8qKlxuICAgKiBNYXhpbXVtIHNpZ25lZCB2YWx1ZS5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4RkZGRkZGRkYgfCAwLCB0cnVlKTtcbiAgLyoqXG4gICAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDAgfCAwLCBmYWxzZSk7XG4gIC8qKlxuICAgKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xuICAvKipcbiAgICogQGFsaWFzIExvbmcucHJvdG90eXBlXG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIDMyIGJpdCBpbnRlZ2VyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkge1xuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcbiAgICBpZiAodGhpcy51bnNpZ25lZCkgcmV0dXJuICh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xuICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBvdmVycmlkZVxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHtcbiAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuICcwJztcbiAgXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcbiAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcbiAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxuICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXG4gICAgICAgICAgICBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLFxuICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XG4gICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgIH0gZWxzZSByZXR1cm4gJy0nICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgfSAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXG4gIFxuICBcbiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksXG4gICAgICAgIHJlbSA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICBcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSxcbiAgICAgICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcbiAgICAgICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xuICAgICAgcmVtID0gcmVtRGl2O1xuICAgICAgaWYgKHJlbS5pc1plcm8oKSkgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtlbHNlIHtcbiAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KSBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XG4gIFxuICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoO1xuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubG93O1xuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24gZ2V0TnVtQml0c0FicygpIHtcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxuICAgICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XG4gICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XG4gIFxuICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSkgaWYgKCh2YWwgJiAxIDw8IGJpdCkgIT0gMCkgYnJlYWs7XG4gIFxuICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjaXNaZXJvfS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZXF6ID0gTG9uZ1Byb3RvdHlwZS5pc1plcm87XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xuICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUgb3IgemVyby5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkge1xuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGV2ZW4uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgdGhpcy5oaWdoID4+PiAzMSA9PT0gMSAmJiBvdGhlci5oaWdoID4+PiAzMSA9PT0gMSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAhdGhpcy5lcShcbiAgICAvKiB2YWxpZGF0ZXMgKi9cbiAgICBvdGhlcik7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcChcbiAgICAvKiB2YWxpZGF0ZXMgKi9cbiAgICBvdGhlcikgPCAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpIDw9IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcChcbiAgICAvKiB2YWxpZGF0ZXMgKi9cbiAgICBvdGhlcikgPiAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpID49IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XG4gIC8qKlxuICAgKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcbiAgICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUob3RoZXIpIHtcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICBpZiAodGhpcy5lcShvdGhlcikpIHJldHVybiAwO1xuICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXG4gICAgICAgIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xuICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZykgcmV0dXJuIC0xO1xuICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykgcmV0dXJuIDE7IC8vIEF0IHRoaXMgcG9pbnQgdGhlIHNpZ24gYml0cyBhcmUgdGhlIHNhbWVcbiAgXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTsgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXG4gIFxuICAgIHJldHVybiBvdGhlci5oaWdoID4+PiAwID4gdGhpcy5oaWdoID4+PiAwIHx8IG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiBvdGhlci5sb3cgPj4+IDAgPiB0aGlzLmxvdyA+Pj4gMCA/IC0xIDogMTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXG4gICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlO1xuICAvKipcbiAgICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xuICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpIHJldHVybiBNSU5fVkFMVUU7XG4gICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7XG4gIH07XG4gIC8qKlxuICAgKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcbiAgICogQHJldHVybnMgeyFMb25nfSBTdW1cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHtcbiAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKSBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTsgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXG4gIFxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XG4gICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcbiAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XG4gICAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xuICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xuICAgIHZhciBjNDggPSAwLFxuICAgICAgICBjMzIgPSAwLFxuICAgICAgICBjMTYgPSAwLFxuICAgICAgICBjMDAgPSAwO1xuICAgIGMwMCArPSBhMDAgKyBiMDA7XG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgYzAwICY9IDB4RkZGRjtcbiAgICBjMTYgKz0gYTE2ICsgYjE2O1xuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgIGMxNiAmPSAweEZGRkY7XG4gICAgYzMyICs9IGEzMiArIGIzMjtcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICBjMzIgJj0gMHhGRkZGO1xuICAgIGM0OCArPSBhNDggKyBiNDg7XG4gICAgYzQ4ICY9IDB4RkZGRjtcbiAgICByZXR1cm4gZnJvbUJpdHMoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcbiAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XG4gICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XG4gICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcbiAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtdWx0aXBsaWVyKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiB0aGlzO1xuICAgIGlmICghaXNMb25nKG11bHRpcGxpZXIpKSBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpOyAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgXG4gICAgaWYgKHdhc20pIHtcbiAgICAgIHZhciBsb3cgPSB3YXNtW1wibXVsXCJdKHRoaXMubG93LCB0aGlzLmhpZ2gsIG11bHRpcGxpZXIubG93LCBtdWx0aXBsaWVyLmhpZ2gpO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgXG4gICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xuICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xuICBcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO2Vsc2UgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xuICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTsgLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxuICBcbiAgXG4gICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSkgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTsgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXG4gICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cbiAgXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcbiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcbiAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhGRkZGO1xuICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XG4gICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xuICAgIHZhciBjNDggPSAwLFxuICAgICAgICBjMzIgPSAwLFxuICAgICAgICBjMTYgPSAwLFxuICAgICAgICBjMDAgPSAwO1xuICAgIGMwMCArPSBhMDAgKiBiMDA7XG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgYzAwICY9IDB4RkZGRjtcbiAgICBjMTYgKz0gYTE2ICogYjAwO1xuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgIGMxNiAmPSAweEZGRkY7XG4gICAgYzE2ICs9IGEwMCAqIGIxNjtcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICBjMTYgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMzIgKiBiMDA7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjMzIgKz0gYTE2ICogYjE2O1xuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgIGMzMiAmPSAweEZGRkY7XG4gICAgYzMyICs9IGEwMCAqIGIzMjtcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICBjMzIgJj0gMHhGRkZGO1xuICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XG4gICAgYzQ4ICY9IDB4RkZGRjtcbiAgICByZXR1cm4gZnJvbUJpdHMoYzE2IDw8IDE2IHwgYzAwLCBjNDggPDwgMTYgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbXVsdGlwbHl9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcbiAgICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxuICAgKiAgdW5zaWduZWQgaWYgdGhpcyBMb25nIGlzIHVuc2lnbmVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XG4gICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7IC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICBcbiAgICBpZiAod2FzbSkge1xuICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzaWduZWQgZGl2aXNpb24gb3ZlcmZsb3c6IHRoZSBsYXJnZXN0XG4gICAgICAvLyBuZWdhdGl2ZSBudW1iZXIgLyAtMSB3b3VsZCBiZSAxIGxhcmdlciB0aGFuIHRoZSBsYXJnZXN0XG4gICAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxuICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiYgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHtcbiAgICAgICAgLy8gYmUgY29uc2lzdGVudCB3aXRoIG5vbi13YXNtIGNvZGUgcGF0aFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtW1wiZGl2X3VcIl0gOiB3YXNtW1wiZGl2X3NcIl0pKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xuICBcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcbiAgICAgIC8vIFRoaXMgc2VjdGlvbiBpcyBvbmx5IHJlbGV2YW50IGZvciBzaWduZWQgbG9uZ3MgYW5kIGlzIGRlcml2ZWQgZnJvbSB0aGVcbiAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxuICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xuICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpIHJldHVybiBNSU5fVkFMVUU7IC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXG4gICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIE9ORTtlbHNlIHtcbiAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXG4gICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XG4gICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcbiAgXG4gICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XG4gICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgXG4gICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTtcbiAgXG4gICAgICByZXMgPSBaRVJPO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcbiAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cbiAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZCkgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xuICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpIHJldHVybiBVWkVSTztcbiAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXG4gICAgICAgIHJldHVybiBVT05FO1xuICAgICAgcmVzID0gVVpFUk87XG4gICAgfSAvLyBSZXBlYXQgdGhlIGZvbGxvd2luZyB1bnRpbCB0aGUgcmVtYWluZGVyIGlzIGxlc3MgdGhhbiBvdGhlcjogIGZpbmQgYVxuICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcbiAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XG4gICAgLy8gdGhlIGFwcHJveGltYXRlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVhbCB2YWx1ZSBzbyB0aGF0IHRoZVxuICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxuICBcbiAgXG4gICAgcmVtID0gdGhpcztcbiAgXG4gICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHtcbiAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcbiAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxuICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpOyAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXG4gICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXG4gIFxuICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcbiAgICAgICAgICBkZWx0YSA9IGxvZzIgPD0gNDggPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxuICAgICAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxuICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXG4gICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXG4gICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgXG4gICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkge1xuICAgICAgICBhcHByb3ggLT0gZGVsdGE7XG4gICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgICAgIH0gLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXG4gICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cbiAgXG4gIFxuICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkgYXBwcm94UmVzID0gT05FO1xuICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xuICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7IC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICBcbiAgICBpZiAod2FzbSkge1xuICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcInJlbV91XCJdIDogd2FzbVtcInJlbV9zXCJdKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcbiAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgY291bnQgbGVhZGluZyB6ZXJvcyBvZiB0aGlzIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFudW1iZXJ9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuY291bnRMZWFkaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudExlYWRpbmdaZXJvcygpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoID8gTWF0aC5jbHozMih0aGlzLmhpZ2gpIDogTWF0aC5jbHozMih0aGlzLmxvdykgKyAzMjtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgY291bnQgbGVhZGluZyB6ZXJvcy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb3VudExlYWRpbmdaZXJvc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfVxuICAgKiBAcmV0dXJucyB7IW51bWJlcn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5jbHogPSBMb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zO1xuICAvKipcbiAgICogUmV0dXJucyBjb3VudCB0cmFpbGluZyB6ZXJvcyBvZiB0aGlzIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFudW1iZXJ9XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5jb3VudFRyYWlsaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubG93ID8gY3R6MzIodGhpcy5sb3cpIDogY3R6MzIodGhpcy5oaWdoKSArIDMyO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyBjb3VudCB0cmFpbGluZyB6ZXJvcy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb3VudFRyYWlsaW5nWmVyb3N9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFudW1iZXJ9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuY3R6ID0gTG9uZ1Byb3RvdHlwZS5jb3VudFRyYWlsaW5nWmVyb3M7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xuICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xuICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7ZWxzZSBpZiAobnVtQml0cyA8IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgdGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gMzIgLSBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtlbHNlIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCBudW1CaXRzIC0gMzIsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdExlZnR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztlbHNlIGlmIChudW1CaXRzIDwgMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtlbHNlIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4gbnVtQml0cyAtIDMyLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xuICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKG51bUJpdHMgPCAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ID4+PiBudW1CaXRzIHwgdGhpcy5oaWdoIDw8IDMyIC0gbnVtQml0cywgdGhpcy5oaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgICBpZiAobnVtQml0cyA9PT0gMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4+IG51bUJpdHMgLSAzMiwgMCwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiByb3RhdGVMZWZ0KG51bUJpdHMpIHtcbiAgICB2YXIgYjtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICAgIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpO1xuICBcbiAgICBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgICBiID0gMzIgLSBudW1CaXRzO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMgfCB0aGlzLmhpZ2ggPj4+IGIsIHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IGIsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgXG4gICAgbnVtQml0cyAtPSAzMjtcbiAgICBiID0gMzIgLSBudW1CaXRzO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiBiLCB0aGlzLmxvdyA8PCBudW1CaXRzIHwgdGhpcy5oaWdoID4+PiBiLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjcm90YXRlTGVmdH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnJvdGwgPSBMb25nUHJvdG90eXBlLnJvdGF0ZUxlZnQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUucm90YXRlUmlnaHQgPSBmdW5jdGlvbiByb3RhdGVSaWdodChudW1CaXRzKSB7XG4gICAgdmFyIGI7XG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgICBpZiAobnVtQml0cyA9PT0gMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIHRoaXMubG93LCB0aGlzLnVuc2lnbmVkKTtcbiAgXG4gICAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPDwgYiB8IHRoaXMubG93ID4+PiBudW1CaXRzLCB0aGlzLmxvdyA8PCBiIHwgdGhpcy5oaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIG51bUJpdHMgLT0gMzI7XG4gICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgYiB8IHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy5oaWdoIDw8IGIgfCB0aGlzLmxvdyA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNyb3RhdGVSaWdodH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnJvdHIgPSBMb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0O1xuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xuICAgIGlmICghdGhpcy51bnNpZ25lZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byB1bnNpZ25lZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcbiAgICBpZiAodGhpcy51bnNpZ25lZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XG4gICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7XG4gICAgdmFyIGhpID0gdGhpcy5oaWdoLFxuICAgICAgICBsbyA9IHRoaXMubG93O1xuICAgIHJldHVybiBbbG8gJiAweGZmLCBsbyA+Pj4gOCAmIDB4ZmYsIGxvID4+PiAxNiAmIDB4ZmYsIGxvID4+PiAyNCwgaGkgJiAweGZmLCBoaSA+Pj4gOCAmIDB4ZmYsIGhpID4+PiAxNiAmIDB4ZmYsIGhpID4+PiAyNF07XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7XG4gICAgdmFyIGhpID0gdGhpcy5oaWdoLFxuICAgICAgICBsbyA9IHRoaXMubG93O1xuICAgIHJldHVybiBbaGkgPj4+IDI0LCBoaSA+Pj4gMTYgJiAweGZmLCBoaSA+Pj4gOCAmIDB4ZmYsIGhpICYgMHhmZiwgbG8gPj4+IDI0LCBsbyA+Pj4gMTYgJiAweGZmLCBsbyA+Pj4gOCAmIDB4ZmYsIGxvICYgMHhmZl07XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQnl0ZSByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cbiAgICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xuICAgIHJldHVybiBsZSA/IExvbmcuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmcuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcbiAgICByZXR1cm4gbmV3IExvbmcoYnl0ZXNbMF0gfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1szXSA8PCAyNCwgYnl0ZXNbNF0gfCBieXRlc1s1XSA8PCA4IHwgYnl0ZXNbNl0gPDwgMTYgfCBieXRlc1s3XSA8PCAyNCwgdW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICAgIHJldHVybiBuZXcgTG9uZyhieXRlc1s0XSA8PCAyNCB8IGJ5dGVzWzVdIDw8IDE2IHwgYnl0ZXNbNl0gPDwgOCB8IGJ5dGVzWzddLCBieXRlc1swXSA8PCAyNCB8IGJ5dGVzWzFdIDw8IDE2IHwgYnl0ZXNbMl0gPDwgOCB8IGJ5dGVzWzNdLCB1bnNpZ25lZCk7XG4gIH07XG4gIFxuICB2YXIgX2RlZmF1bHQgPSBMb25nO1xuICBleHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbiAgcmV0dXJuIFwiZGVmYXVsdFwiIGluIGV4cG9ydHMgPyBleHBvcnRzLmRlZmF1bHQgOiBleHBvcnRzO1xufSkoe30pO1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIExvbmc7IH0pO1xuZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSBtb2R1bGUuZXhwb3J0cyA9IExvbmc7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiXG5jb25zdCBhcGkgPSByZXF1aXJlKCdAdGVtcG9yYWxpby93b3JrZmxvdy9saWIvd29ya2VyLWludGVyZmFjZS5qcycpO1xuXG5hcGkub3ZlcnJpZGVHbG9iYWxzKCk7XG5cbmV4cG9ydHMuYXBpID0gYXBpO1xuXG5leHBvcnRzLmltcG9ydFdvcmtmbG93cyA9IGZ1bmN0aW9uIGltcG9ydFdvcmtmbG93cygpIHtcbiAgcmV0dXJuIHJlcXVpcmUoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy94cC9Eb2N1bWVudHMvYWlycG9ydC9kZW1vcy9ldGhlcnMtZGVtb3MvZXRoZXJzLWRlbW8vc3JjL3dvcmtlci93b3JrZmxvd3MudHNcIik7XG59XG5cbmV4cG9ydHMuaW1wb3J0SW50ZXJjZXB0b3JzID0gZnVuY3Rpb24gaW1wb3J0SW50ZXJjZXB0b3JzKCkge1xuICByZXR1cm4gW1xuICAgIHJlcXVpcmUoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy94cC9Eb2N1bWVudHMvYWlycG9ydC9kZW1vcy9ldGhlcnMtZGVtb3MvZXRoZXJzLWRlbW8vbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtlci9saWIvd29ya2Zsb3ctbG9nLWludGVyY2VwdG9yLmpzXCIpXG4gIF07XG59XG4iXSwibmFtZXMiOlsicHJveHlBY3Rpdml0aWVzIiwiaGVsbG9Xb3JsZCIsImdldEdhc1ByaWNlIiwicmV0cnkiLCJpbml0aWFsSW50ZXJ2YWwiLCJtYXhpbXVtQXR0ZW1wdHMiLCJzdGFydFRvQ2xvc2VUaW1lb3V0IiwiZ2FzUHJpY2VXb3JrZmxvdyIsIm5hbWUiLCJyZXN1bHQiXSwic291cmNlUm9vdCI6IiJ9